<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="bxxiao">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="bxxiao">
<meta property="og:description" content="nothing">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bxxiao">
<meta property="article:tag" content="bxxiao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>bxxiao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bxxiao" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bxxiao</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/MySQL/MySQL%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/MySQL/MySQL%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-30 13:05:17" itemprop="dateCreated datePublished" datetime="2021-08-30T13:05:17+08:00">2021-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-01 12:09:03" itemprop="dateModified" datetime="2021-09-01T12:09:03+08:00">2021-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p><strong>索引是存储引擎用于快速找到记录的一种数据结构</strong>。其作用相当于是一个 “目录”，在这个目录中可以快速找到想要的内容。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/30/MySQL/MySQL%E7%B4%A2%E5%BC%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/MySQL/InnoDB%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/MySQL/InnoDB%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81/" class="post-title-link" itemprop="url">MySQL事务、锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-30 13:05:17 / 修改时间：13:06:17" itemprop="dateCreated datePublished" datetime="2021-08-30T13:05:17+08:00">2021-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​        <strong>事务是逻辑上的一组操作，即一个或多个SQL语句，要么都执行，要么都不执行</strong>。<strong>如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚</strong>。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功， 则事物被顺利执行。</p>
<p>​        事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h2 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h2><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200716162156.png"></p>
<ol>
<li><p><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。<strong>事务的原子性确保动作要么全部完成，要么完全不起作用</strong>；</p>
</li>
<li><p><strong>隔离性（Isolation）：</strong> 并发访问数据库时，<strong>一个用户的事务不被其他事务所干扰</strong>，各并发事务之间是独立的；<strong>一个事务所做的修改在最终提交以前，对其它事务是不可见的</strong>。</p>
</li>
<li><p><strong>持久性（Durability）：</strong> 一旦事务提交，则其所做的修改将会永远保存到数据库中。<strong>即使系统发生崩溃，事务执行的结果也不能丢失</strong>。</p>
</li>
<li><p><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，<strong>多个事务对同一个数据读取的结果是相同的</strong>；</p>
<ul>
<li><p><strong>ACID 里的 AID 都是数据库的特征，也就是依赖数据库的具体实现。而唯独这个 C，实际上它依赖于应用层，也就是依赖于开发者。这里的一致性是指<font color="red">系统从一个正确的状态，迁移到另一个正确的状态</font>。什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态。而事务具备 ACID 里 C 的特性是说通过事务的 AID 来保证我们的一致性</strong>。</p>
<p>（来自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31346392/answer/362597203">https://www.zhihu.com/question/31346392/answer/362597203</a> 作者：孟波）</p>
</li>
</ul>
</li>
</ol>
<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<p><strong style="color:red">几个特性的关系</strong>：</p>
<ul>
<li><strong>只有满足一致性，事务的执行结果才是正确的</strong>。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在<strong>并发情况下</strong>，多个事务并行执行，<strong>事务不仅要满足原子性，还需要满足隔离性，才能满足一致性</strong>。</li>
<li><strong>事务满足持久化是为了能应对系统崩溃的情况</strong>。</li>
</ul>
<h2 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h2><p>事务可分为隐式事务和显式事务。<strong style="color:red">隐式事务如 DML 语言（insert、update、delete），每一个语句都是一个事务</strong>；而显式事务通过sql语句开启事务跟关闭事务，一个事务可有多条语句。</p>
<p><strong>msyql默认关闭事务，通过<code>SHOW VARIABLES LIKE &#39;%autocommit%&#39;;</code>命令可看到``autocommit=ON`，即自动提交默认开启。创建事务前需关闭自动提交</strong>。<strong><span style="color:red;">事务中不能包括DDL语句</span></strong>。</p>
<p>显示事务的创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.开启事务</span></span><br><span class="line"><span class="comment"># 若是设置 autocommit 为 0，则默认开始事务，最后使用commit提交即可</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">START</span> TRASACTION;</span><br><span class="line"><span class="comment">--编写事务语句</span></span><br><span class="line">语句1</span><br><span class="line">语句2</span><br><span class="line">...</span><br><span class="line"><span class="comment">--结束事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>



<p>一个转账的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>(</span><br><span class="line">	username <span class="built_in">VARCHAR</span>(<span class="number">10</span>)，</span><br><span class="line">	money <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">account</span> <span class="keyword">VALUES</span>(<span class="string">&#x27;zhangsan&#x27;</span>， <span class="number">1000</span>)，(<span class="string">&#x27;xiaoming&#x27;</span>， <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#转账例子</span></span><br><span class="line"><span class="comment">#开启事务（关闭事务自动提交）</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">#事务语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">1500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line"><span class="comment">#提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>



<h3 id="回滚点SAVEPOINT"><a href="#回滚点SAVEPOINT" class="headerlink" title="回滚点SAVEPOINT"></a>回滚点SAVEPOINT</h3><p>​        回滚点跟<code>ROLLBACK</code>搭配使用，其作用是设置一个保存点，当执行<code>ROLLBACK</code>时回滚到保存点。</p>
<p>eg：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> a;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> a;</span><br></pre></td></tr></table></figure>

<p>执行以上语句后查询account表，可发现只删除了id为2的记录。</p>
<h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2><p>图解：<a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">CS-Note</a> </p>
<p>​        在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（<strong>多个用户对同一数据进行操作</strong>）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><p><strong>脏读（Dirty read）:</strong> <strong>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的</strong>，比如可能出现错误而回滚事务，导致修改后的数据没有存入数据库。</p>
</li>
<li><p><strong>丢失修改（Lost to modify）:</strong> <strong>指在一个事务读取一个数据时，另外一个事务也访问了该数据，随后在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被覆盖掉了（即丢失了），因此称为丢失修改</strong>。 </p>
</li>
<li><p><strong>不可重复读（Unrepeatableread）:</strong> <strong>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的结果可能不一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读</strong>。（事务1读数据的过程中，事务2把数据给改了，导致事务1两次读的数据不同）</p>
</li>
<li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，<strong>第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</strong>。（<strong>在同一事务下，连续执行两次同样的SQL语句第二次的SQL语句可能返回之前不存在的行</strong>）</p>
</li>
</ul>
<p><strong><span style="color:red">不可重复读和幻读区别</span></strong>： </p>
<p><strong>不可重复读的重点是数据的值被修改，比如多次读取一条记录发现其中某些列的值被修改</strong>，幻读的重点在于<strong>新增或者删除比如多次读取一条记录发现记录增多或减少了</strong>。</p>
<p><strong>产生并发不一致性问题的主要原因是破坏了事务的隔离性</strong>，解决方法是<strong>通过并发控制来保证隔离性</strong>。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h2 id="MySQL的事务隔离级别"><a href="#MySQL的事务隔离级别" class="headerlink" title="MySQL的事务隔离级别"></a>MySQL的事务隔离级别</h2><p><strong><span style="color:red">SQL 标准定义了四个隔离级别：</span></strong> </p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong><span style="color:red">可能会导致脏读、幻读或不可重复读</span></strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong><span style="color:red">可以阻止脏读，但是幻读或不可重复读仍有可能发生</span></strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> <strong>保证在同一个事务中多次读取同一数据的结果是一样的</strong>，除非数据是被本身事务自己所修改，<span style="color:red"><strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></span>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> <strong>最高的隔离级别，完全服从ACID的隔离级别</strong>。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但效率极低。该标准类似于线程锁。</li>
</ul>
<p>可总结为下表（<strong>打勾表示可能发生</strong>）</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>MySQL <strong>InnoDB 存储引擎</strong>的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。可以<strong>通过<code>SELECT @@tx_isolation;</code>命令</strong>来查看</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>【<strong><span style="color:red">这里需要注意的是</span></strong>：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是<strong>Next-Key Lock 锁算法</strong>，因此<strong><span style="color:red">可以避免幻读的产生</span></strong>，这与其他数据库系统(如 SQL Server) 是不同的。所以说<strong><span style="color:red">InnoDB 存储引擎的默认支持的隔离级别已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别</span></strong>。】—— 存疑</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，<strong>但是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读），<span style="color:red"> 并不会有任何性能损失</span></strong>。</p>
</blockquote>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<p>设置事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span>/<span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> </span><br><span class="line"><span class="keyword">read</span> uncommitted | <span class="keyword">read</span> committed | repeatable <span class="keyword">read</span>(默认) | <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure>



<h2 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h2><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul>
<li>互斥锁（Exclusive）：简写为 <strong>X 锁</strong>，又称<strong>写锁</strong>。</li>
<li>共享锁（Shared）：简写为 <strong>S 锁</strong>，又成<strong>读锁</strong>。</li>
</ul>
<p>读写锁的 <strong>2 个规定</strong>：</p>
<ul>
<li>一个事务对对象 A 加了 X 锁，就可以读写数据。加锁期间其他事务不能对对象 A 加任何锁。</li>
<li>一个事务对对象 A 加了 S 锁，就可以读数据，但不能写数据。加锁期间其他事务可以对对象 A 加 S 锁，但不能加 X 锁。</li>
</ul>
<p>另外，<strong>X 锁和 S 锁可以是表级锁也可以是行级锁</strong>。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁<strong>都是表锁</strong>，用来<strong>表示一个事务想要在表中的某些数据行上加 X 锁或 S 锁</strong>。有以下两个规定：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行 S 锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁<strong>或者更强的锁</strong>。</li>
<li>意向排他锁（IX）：事务打算给数据行加行 X 锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>大部分情况下锁都是由存储引擎自动加的，比如在执行 UPDATE、INSERT、DELETE 时，InnoDB 会给涉及的数据行加 X 锁。</p>
<h4 id="为什么使用意向锁"><a href="#为什么使用意向锁" class="headerlink" title="为什么使用意向锁"></a>为什么使用意向锁</h4><p><strong style="color:red">在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，需要检查表 A 是否已被加锁，且需要检查表的每一行是否被加锁，这是非常耗时的</strong>。（X 锁和任何锁都互斥）</p>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁（<strong>表锁</strong>），<strong>只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁</strong>，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败（<strong>注意这里指的是对整个表 A 加 X 锁，不是要对行加锁</strong>），<strong>这样就不用检查每一行是否有锁</strong>，提高效率。</p>
<h4 id="各类锁的兼容关系"><a href="#各类锁的兼容关系" class="headerlink" title="各类锁的兼容关系"></a>各类锁的兼容关系</h4><p>X/S/IX/IS 的兼容关系：（来自参考链接）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210420105522070.png" alt="image-20210420105522070"></p>
<p>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</p>
<p><strong style="color:red">注意上图的兼容关系针对的是表级锁</strong>，比如表级的 X 和 IX 不兼容。<strong>但行级的 X 锁和 IX 锁是兼容的，即若是一个表已经被加 IX 锁，也允许一个事务对某一行加 X 锁</strong>：事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。</p>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><p><strong>1.三级封锁协议</strong>：</p>
<ul>
<li><p><strong>一级封锁协议</strong>：事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</p>
<p>可以避免丢失修改，但不能保证可重复读和脏读。</p>
</li>
<li><p><strong>二级封锁协议</strong>：一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后方可释放 S 锁。</p>
<p>除了可以避免丢失修改，也可以避免脏读，因为若其他事务的 X 锁未释放，当前事务无法加 S 锁，也就不能读。但不能避免不可重复读，因为读完就把锁释放了。</p>
</li>
<li><p><strong>三级封锁协议</strong>：一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，<strong>直到事务结束才释放</strong>。二级封锁协议是读完就释放 S 锁，<strong>而三级协议则是等到事务结束才释放</strong>。</p>
<p><strong>进一步避免不可重复读</strong>。</p>
<p><strong>2. 两段锁协议</strong>：</p>
</li>
</ul>
<p>两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。</p>
<p>两段封锁法可以这样来实现：事务开始后就处于加锁阶段，<strong>一直到执行 ROLLBACK 和 COMMIT 之前都是加锁阶段</strong>。ROLLBACK 和 COMMIT 使事务进入解锁阶段，即在 ROLLBACK 和 COMMIT 模块中 DBMS 释放所有封锁。</p>
<ol>
<li><p>在对任何数据进行读、写操作之前，要申请并获得对该数据的封锁。</p>
</li>
<li><p>每个事务中，<strong>所有的封锁请求先于所有的解锁请求</strong>。</p>
</li>
</ol>
<p>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p>
<blockquote>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
</blockquote>
<h3 id="MySQL-隐式与显式锁定"><a href="#MySQL-隐式与显式锁定" class="headerlink" title="MySQL 隐式与显式锁定"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>





<h3 id="InnoDB的3种行锁算法"><a href="#InnoDB的3种行锁算法" class="headerlink" title="InnoDB的3种行锁算法"></a>InnoDB的3种行锁算法</h3><p>InnoDB的 3 种行锁算法：</p>
<ul>
<li>Record Lock：单个行记录上的锁。</li>
<li>Gap Lock：间隙锁。索引一个范围，但不包含记录本身。</li>
<li>Next-key Lock：Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身，锁定区间是左开右闭。</li>
</ul>
<p><strong>Next-key Lock 算法是 Repeatable read 隔离级别下才使用的。在加锁期间在被锁的范围内不能增加或删除，避免了幻读</strong>。</p>
<p><strong>Repeatable read 隔离级别下</strong>：</p>
<ul>
<li><p><strong>执行普通的 select 语句（没有显示加锁）时使用的都是一致性非锁定读</strong>，即只会读取当前事务之前的数据，不存在幻读的问题，也就没有必要使用 Next-key Lock 算法。</p>
</li>
<li><p><strong style="color:red">而若是使用一致性锁定读（即显示加锁），因为总是会读取已提交的最新版本的数据，所以不作特殊处理的话会出现幻读</strong>，InnoDB 在一致性锁定读下会使用 Next-key Lock 来避免幻读，<strong style="color:red">即 Repeatable read 隔离级别下只有使用一致性锁定读时 Next-key Lock 算法才会生效</strong>。</p>
</li>
<li><p><strong style="color:red">另外要注意的是，Next-key Lock 具体的说是为了避免 RR 隔离级别下一致性锁定读的幻读问题，一致性非锁定读是没有幻读问题的</strong>。</p>
</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="MVCC概述"><a href="#MVCC概述" class="headerlink" title="MVCC概述"></a>MVCC概述</h3><p>MVCC，Muti-Version Concurrency Control，<strong>多版本并发控制</strong>。<strong style="color:red">它是通过保存数据在某个时间点的快照来实现的</strong>，在<strong>很多情况下可以避免加锁</strong>，开销更低。</p>
<p><strong style="color:red">InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，其中一个保存了行的创建时间，一个保存行的过期时间（或者说是删除时间）。这里说是“时间”，实际指的是系统版本号，所以上述 2 个“时间”可以理解为【创建时的版本号】以及记录【被删除时的版本号】</strong>。<strong>每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较</strong>。</p>
<blockquote>
<p>使用 begin 或 start transaction 开始事务后，系统版本号并不会立即递增，</p>
</blockquote>
<p>在 REPEATABLE READ （可重复读）隔离级别下，MVCC 对不同 SQL 的操作：</p>
<ul>
<li><p>SELECT：符合以下两个条件的记录，才能返回作为查询结果：</p>
<ul>
<li><strong>行的系统版本号小于或等于当前事务的系统版本号</strong>，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。<strong style="color:red">这样就避免了不可重复读的情况，因为其他事务修改后数据的系统版本号会大于当前事务的系统版本号</strong>。（同时也避免了脏读）</li>
<li>行的删除版本未定义，或者大于当前事务版本号（<strong>即在当前事务时该行还未被删除</strong>）。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ul>
</li>
<li><p>INSERT：InnoDB <strong>为新插入的每一行保存当前系统版本号作为行版本号</strong>。</p>
<blockquote>
<p>注意执行 INSERT 插入的行保存的版本号的【当前的系统版本号】，而不是当前事务的版本号。</p>
</blockquote>
</li>
<li><p>DELETE：InnoDB <strong>为删除的每一行保存当前系统版本号作为行删除标识</strong>。</p>
</li>
<li><p>UPDATE：InnoDB <strong>插入一行新记录，保存当前系统版本号作为新行的版本号，同时保存当前系统版本号到原来的行作为行删除标识</strong>。（旧行并没有从物理上删除）</p>
</li>
</ul>
<blockquote>
<p>对于 READ COMMITTED 隔离级别，insert、delete、update 的操作应该是一样的。</p>
</blockquote>
<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。<strong>缺点</strong>是每个快照都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>
<p><strong>InnoDB 的 MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作</strong>。</p>
<h3 id="一致性非锁定读-锁定读"><a href="#一致性非锁定读-锁定读" class="headerlink" title="一致性非锁定读/锁定读"></a>一致性非锁定读/锁定读</h3><ul>
<li><p>InnoDB 的 MVCC 中，默认情况下是读取数据是采用一致性非锁定读的，<strong>即如果当前行正在进行 DELETE 或 UPDATE，这时读取操作不会去等待行上锁的释放，而是去读取该行的一个快照版本（老版本）</strong>。且在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下一致性非锁定读有所区别：</p>
<ul>
<li>REPEATABLE READ 总是读取事务开始时的行数据版本；</li>
<li>对于 READ COMMITTED ，每次总是读取最新已提交版本。</li>
</ul>
</li>
<li><p>某些情况下需要对读取操作加锁保证数据的逻辑一致性，这需要通过加锁语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ... for update</span><br><span class="line">select ... lock in share mode</span><br></pre></td></tr></table></figure>

<p><strong>前者对读取的行加 X 锁；后者对读取的行加 S 锁</strong>。这就是一致性锁定读。<strong style="color:red">一致性锁定读读取的总是最新的（已提交）数据</strong>。</p>
</li>
</ul>
<p>InnoDB 的 MVCC 下（或者说，在 InnoDB 的 READ COMMITED 和 REPETABLE READ 隔离级别下），普通的 select 语句（没有显式加锁）都是使用一致性非锁定读，而若是显示加锁则使用一致性锁定读。</p>
<h3 id="关于加锁"><a href="#关于加锁" class="headerlink" title="关于加锁"></a>关于加锁</h3><p>select 的 2 种显示加锁方式<strong style="color:red">一般会在事务块中使用，且在事务结束时才会释放锁，同样的，在一个事务中使用 update 、insert 加的锁也需要等到事务结束才释放</strong>。</p>
<blockquote>
<p>在网上看到一些文章说 2 个显示加锁语句只有开启事务才会生效，这种说法似乎是错的，或者说，<strong>如果没有显示开启事务，则单独一条加锁的 select 语句就是一个单独的事务，加锁语句是会生效的</strong>。</p>
</blockquote>
<p>另外，即使某个记录被加上排他（X）锁，一个普通的 SELECT 语句也是可以读取该记录的，而若是该 SELECT 语句有显示加锁，则会阻塞。</p>
<p>示例 1 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 连接1 中先执行：</span><br><span class="line">begin;</span><br><span class="line">SELECT * from index_test where a &#x3D; 3 for UPDATE;</span><br><span class="line"></span><br><span class="line"># 随后在连接2 中执行以下语句会阻塞</span><br><span class="line">SELECT b from index_test where a &#x3D; 3 for UPDATE;</span><br><span class="line"></span><br><span class="line"># 连接1 中提交事务后，连接2 的查询语句就可以获得锁继续执行</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>示例 2 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 连接1 中先执行：</span><br><span class="line">begin;</span><br><span class="line">SELECT * from index_test where a &#x3D; 3 for UPDATE;</span><br><span class="line"></span><br><span class="line"># 随后在连接2 中执行以下语句，发现并不会阻塞</span><br><span class="line"># 但若是在连接1 中修改数据但不提交事务，则连接2 读取不到提交的数据（默认情况下）</span><br><span class="line">SELECT b from index_test where a &#x3D; 3;</span><br></pre></td></tr></table></figure>



<h3 id="MVCC与隔离级别"><a href="#MVCC与隔离级别" class="headerlink" title="MVCC与隔离级别"></a>MVCC与隔离级别</h3><p>这里大概说明一下 InnoDB 是如何通过 MVCC 实现 REPEATABLE READ 和 READ COMMITTED 隔离级别的。</p>
<ol>
<li><p>READ COMMITTED</p>
<p>一个事务对数据进行修改，<strong>在 commit 时</strong>会生成一条新的数据快照，这个快照的版本比原来的数据的版本高。<strong>在该隔离级别下，事务在读取数据时都会读取最高版本的行记录，所以若是一个事务修改数据后没有 commit ，也就没有提交更新版本的数据快照，修改的数据就不会被其他事务读取，从而避免了脏读</strong>。但避免不了不可重复读，因为事务只要提交了修改，这个修改就可以被其他事务读取到。</p>
</li>
<li><p>REPEATABLE READ</p>
<p>REPEATABLE READ 隔离级别下读取数据<strong>只会读取版本号小于等于当前事务的行数据</strong>，<strong style="color:red">在当前事务持续期间，其他事务即使修改了数据并 commit ，因为 commit 后的新数据的版本比当前事务高，所以不会被当前事务读取到，从而避免了不可重复读</strong>。另外，在该隔离级别下，<strong>InnoDB 使用了 Next-key 锁算法，所以还可以避免幻读</strong>。</p>
</li>
</ol>
<h3 id="关于事务ID-TODO"><a href="#关于事务ID-TODO" class="headerlink" title="关于事务ID(TODO)"></a>关于事务ID(TODO)</h3><p>每开始一个事务，系统中的事务 id （系统版本号）会自增 1 。</p>
<blockquote>
<p>在 MySQL 5.7 中的测试情况：</p>
<p>执行 BEGIN 并不会使事务 id 自增，只有当执行 update、insert 或当前读等涉及到加锁的操作时才会使事务 id 自增。</p>
<p>且执行普通的 select 时也会分配一个 id ，但该 id 很大，跟系统版本 id 不同，目前还不知道是啥。（TODO）</p>
</blockquote>
<p>可以通过以下语句查询当前事务的 id ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TRX_ID FROM INFORMATION_SCHEMA.INNODB_TRX  WHERE TRX_MYSQL_THREAD_ID &#x3D; CONNECTION_ID();</span><br></pre></td></tr></table></figure>

<p>单独使用（没有开启事务）一个 <code>select ... for update</code> 或 <code>select ... lock in share mode</code> 会使系统版本号加 1 ，但使用一个普通的 select 语句则不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前所有进行中的事务信息</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"></span><br><span class="line"># 查看系统的事务 id （找到 trx counter 字段）</span><br><span class="line">SHOW ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure>



<hr>
<p>参考：</p>
<ul>
<li><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL" target="_blank">javaGuide</a>  </li>
<li><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理-CS-Note</a>  </li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903645125820424">索引和锁-Java3y</a>  </li>
<li>《高性能MySQL》</li>
<li>《MySQL技术内幕-InnoDB存储引擎》</li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/MySQL/%E5%AE%89%E8%A3%85&%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/MySQL/%E5%AE%89%E8%A3%85&%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">MySQL安装、卸载等操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-30 13:05:17 / 修改时间：13:05:56" itemprop="dateCreated datePublished" datetime="2021-08-30T13:05:17+08:00">2021-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MySQL5-8-安装（压缩包版）"><a href="#MySQL5-8-安装（压缩包版）" class="headerlink" title="MySQL5.* 8.* 安装（压缩包版）"></a>MySQL5.* 8.* 安装（压缩包版）</h2><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43715354/article/details/109354222">链接</a> </p>
<p>*<em>MySQL5.</em> 和 8.0.22 都可以照这个安装方法，这里以 5.7.30 为例**。</p>
<blockquote>
<p>使用 installer 只能安装在 c 盘 。</p>
</blockquote>
<ul>
<li><p>官网下载 5.7.30 zip 压缩包。</p>
</li>
<li><p>解压，重命名。</p>
</li>
<li><p>Path 环境变量中添加：（即 bin 目录路径）(<strong>这一步应该可以省略</strong>)</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:<span class="symbol">\P</span>rogram Files<span class="symbol">\M</span>ySQL<span class="symbol">\m</span>ysql-5.7.30<span class="symbol">\b</span>in</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装目录下创建 my.ini 配置文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\Program Files\MySQL\mysql-<span class="number">5.7</span>.<span class="number">30</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\Program Files\MySQL\mysql-<span class="number">5.7</span>.<span class="number">30</span>\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为utf8mb4</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment">#mysql_native_password</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br></pre></td></tr></table></figure>
</li>
<li><p>管理员运行 cmd，进入 bin 目录，执行命令进行初始化： </p>
<p>这里日志信息会打印在控制台，<strong>要注意会生成一个暂时密码</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装服务：（后面的参数是指定服务名，若省略则默认为 MySQL）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --install mysql5.7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果提示服务已存在，进行移除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -remove MySQL-Server-Name</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>启动 MySQL 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql5.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入<code>mysql -u root -p</code> </p>
</li>
<li><p>输入上述随机生成的密码进入数据库。进入后需要修改密码，因为随机生成的密码在登录后会过期。（这时若不修改密码，执行一切sql语句都会报错，提醒修改密码）</p>
</li>
<li><p>修改密码的命令：</p>
<ul>
<li><p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;newPassword&#39;;</code> </p>
</li>
<li><p><code>flush privileges;</code> </p>
</li>
</ul>
</li>
</ul>
<h2 id="同一个主机切换MySQL版本"><a href="#同一个主机切换MySQL版本" class="headerlink" title="同一个主机切换MySQL版本"></a>同一个主机切换MySQL版本</h2><p>右键我的计算机，管理，服务，关闭、启动。</p>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><ol>
<li><p>登录 MySQL 。</p>
</li>
<li><p>查询密码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">select</span> host,<span class="keyword">user</span>,authentication_string <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mysql 5.7.9以后废弃了password字段和password()函数；authentication_string:字段表示用户密码。</p>
</blockquote>
</li>
<li><p>将 authentication_string 置空：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="string">&#x27;&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> host=<span class="string">&#x27;xx&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;newPassword&#x27;</span>;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tmdsleep/p/10967432.html">MySQL8.*修改密码</a> </li>
</ul>
<h2 id="MySQL卸载"><a href="#MySQL卸载" class="headerlink" title="MySQL卸载"></a>MySQL卸载</h2><p>MySQL的卸载：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=249">https://www.bilibili.com/video/BV12b411K7Zu?p=249</a>  第6集</p>
<h2 id="MySQL服务的启动和关闭"><a href="#MySQL服务的启动和关闭" class="headerlink" title="MySQL服务的启动和关闭"></a>MySQL服务的启动和关闭</h2><p>可通过</p>
<p><strong>【右键我的电脑】-》【管理】-》【服务和应用程序】-》【服务】-》【找到MySQL】-》【双击，选择启动/关闭】</strong> </p>
<p>或者：</p>
<p><strong>以【管理员身份运行命令行】-》【输入命令<code>net stop/start mysqlServerName</code>】</strong> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/IDEA/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/IDEA/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">IDEA的一些使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-30 13:02:36 / 修改时间：13:03:09" itemprop="dateCreated datePublished" datetime="2021-08-30T13:02:36+08:00">2021-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>该笔记基于IDEA-2019版本</p>
</blockquote>
<h2 id="提高运行速度"><a href="#提高运行速度" class="headerlink" title="提高运行速度"></a>提高运行速度</h2><p>在idea安装目录的bin目录下的idea.exe.vmoptions文件，调整<code>Xms</code>跟<code>Xmx</code>两个参数的值可提高运行速度，但要注意电脑的运行内存是否足够。</p>
<h2 id="恢复默认设置"><a href="#恢复默认设置" class="headerlink" title="恢复默认设置"></a>恢复默认设置</h2><p>在用户目录中，有一个<code>.IntelliJIdea2019.3</code>目录，该目录下有个<code>config</code>跟一个<code>system</code>目录，前者存放关于IDEA一些设置相关的配置文件。可以通过将这两个目录删除来实现恢复默认设置（在重启idea时会自动创建这两个文件，但之前设置的快捷键、模板等将被重置）。</p>
<h2 id="工具条"><a href="#工具条" class="headerlink" title="工具条"></a>工具条</h2><p>【View】-》【Appearance】-》【选中Tool Bar】，打开工具条。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200814222041.png"></p>
<h2 id="IDEA中的Project和Module"><a href="#IDEA中的Project和Module" class="headerlink" title="IDEA中的Project和Module"></a>IDEA中的Project和Module</h2><p>参考链接：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/65448689">https://blog.csdn.net/qq_35246620/article/details/65448689</a> </p>
</blockquote>
<p>在 IntelliJ IDEA 中<code>Project</code>是最顶级的结构单元，然后就是<code>Module</code>，一个<code>Project</code>可以有多个<code>Module</code>。</p>
<p>一个<code>Project</code>是由一个或多个<code>Module</code>组成，</p>
<ul>
<li>当为单<code>Module</code>项目的时候，这个单独的<code>Module</code>实际上就是一个<code>Project</code>；</li>
<li>当为多<code>Module</code>项目的时候，多个模块处于同一个<code>Project</code>之中，此时彼此之间具有互相依赖的关联关系。</li>
</ul>
<p>此外， IntelliJ IDEA 的<code>Project</code>是一个不具备任何编码设置、构建等开发功能的概念，其主要作用就是起到一个项目定义、范围约束、规范类型的效果，这个目录在命名上应该有其代表性的意义。在缺省情况下，IntelliJ IDEA 是默认单<code>Project</code>单<code>Module</code>的，这时<code>Project</code>和<code>Module</code>合二为一。</p>
<p>要删除Module时，需要进入<code>Project Structure</code>，在左边选择<code>Modules</code>，右边视图中选中要删除的Module，点击上方的<code>-</code>（或右键delete）即可。此时在项目中移除了对应Module，但在磁盘中没有删除Module对应目录，需手动删除。</p>
<p><strong>在一个Module中，可以通过在本Module的imi文件中配置引入其他Module的内容</strong>。可以使用<code>Alt+Enter</code>的提示功能自动配置。</p>
<h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><h3 id="鼠标悬停显示文档"><a href="#鼠标悬停显示文档" class="headerlink" title="鼠标悬停显示文档"></a>鼠标悬停显示文档</h3><p>【Settings】-》【Editor】-》【General】-》【视图右边滑到最下面，勾上<code>show quik documentation on mouse move</code>】</p>
<p>下方的Tooltip delay设置延迟时间。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145751019.png" alt="image-20200815145751019" style="zoom:67%;" />

<h3 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135642.png" style="zoom:67%;" />



<h3 id="显示方法间的分隔符"><a href="#显示方法间的分隔符" class="headerlink" title="显示方法间的分隔符"></a>显示方法间的分隔符</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135936.png"></p>
<h3 id="忽略大小写提示的差别"><a href="#忽略大小写提示的差别" class="headerlink" title="忽略大小写提示的差别"></a>忽略大小写提示的差别</h3><p>如图取消勾选即可。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815140939775.png" alt="image-20200815140939775"></p>
<p>效果：输入S跟s的提示将变的一样。</p>
<h3 id="多个文件的标签多行显示"><a href="#多个文件的标签多行显示" class="headerlink" title="多个文件的标签多行显示"></a>多个文件的标签多行显示</h3><p>打开多个文件时，让多个文件的标签分成多行显示。如图，取消勾选。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141445072.png" alt="image-20200815141445072" style="zoom:80%;" />





<h3 id="设置代码编辑区各部分样式"><a href="#设置代码编辑区各部分样式" class="headerlink" title="设置代码编辑区各部分样式"></a>设置代码编辑区各部分样式</h3><p>设置如单行注释、多行注释、方法等字体的样式。在框框内点击不同位置可自动跳转到对应的设置。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141938283.png" alt="image-20200815141938283" style="zoom: 67%;" />



<h3 id="当导入同一个包的类超过多少时使用"><a href="#当导入同一个包的类超过多少时使用" class="headerlink" title="当导入同一个包的类超过多少时使用*"></a>当导入同一个包的类超过多少时使用<code>*</code></h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815142453764.png" alt="image-20200815142453764" style="zoom: 67%;" />



<h3 id="设置类的头部信息"><a href="#设置类的头部信息" class="headerlink" title="设置类的头部信息"></a>设置类的头部信息</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143009247.png" alt="image-20200815143009247" style="zoom:67%;" />



<h3 id="设置编码（全局）"><a href="#设置编码（全局）" class="headerlink" title="设置编码（全局）"></a>设置编码（全局）</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143239051.png" alt="image-20200815143239051" style="zoom:67%;" />



<h3 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h3><p>也可同时勾上框框第二项，启动多模块并行编译。但会占用更多内存。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815144738928.png" alt="image-20200815144738928" style="zoom:67%;" />



<h3 id="多个代码文件垂直-水平显示"><a href="#多个代码文件垂直-水平显示" class="headerlink" title="多个代码文件垂直/水平显示"></a>多个代码文件垂直/水平显示</h3><p>右键标签页，如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145150886.png" alt="image-20200815145150886" style="zoom: 80%;" />

<p>效果：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145304470.png" alt="image-20200815145304470" style="zoom: 67%;" />

<h3 id="CTRL-插入注释时带缩进"><a href="#CTRL-插入注释时带缩进" class="headerlink" title="CTRL+/ 插入注释时带缩进"></a><code>CTRL+/</code> 插入注释时带缩进</h3><p>设置Java文件：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135428506.png" alt="image-20200818135428506" style="zoom:67%;" />

<p>XML文件同理：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135625076.png" alt="image-20200818135625076" style="zoom:67%;" />



<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/VariatioZbw/article/details/105626147">https://blog.csdn.net/VariatioZbw/article/details/105626147</a></p>
</blockquote>
<h3 id="为main方法传递参数"><a href="#为main方法传递参数" class="headerlink" title="为main方法传递参数"></a>为main方法传递参数</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013713294/article/details/53020293">https://blog.csdn.net/u013713294/article/details/53020293</a></p>
</blockquote>
<p>有时需要使用main方法的args参数，而为args参数赋值一般在命令行中，如下：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java <span class="comment">//编译</span></span><br><span class="line">java Test para<span class="name">m1</span> para<span class="name">m2</span> para<span class="name">m3</span> ... <span class="comment">//运行Test类，param是传递给main方法的参数</span></span><br></pre></td></tr></table></figure>



<p>在idea中可以设置参数，在main方法运行时把这些参数传递给它，步骤如下：</p>
<ol>
<li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213818332.png" style="zoom:80%;" />

<p>或</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213902857.png" style="zoom:80%;" />
</li>
<li><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924214508649.png" alt="image-20200924214508649"></p>
<p>点击OK，运行main方法时即会传入设置的参数。</p>
</li>
</ol>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815152625644.png" alt="image-20200815152625644" style="zoom: 80%;" />

<p>查看/修改快捷键：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815233545855.png" alt="image-20200815233545855" style="zoom: 67%;" />



<p><strong>快捷键大全</strong>：</p>
<blockquote>
<p>以下大部分来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p>
</blockquote>
<h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + F</td>
<td align="left">在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + R</td>
<td align="left">在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Z</td>
<td align="left">撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Y</td>
<td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + X</td>
<td align="left">剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + C</td>
<td align="left">复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + D</td>
<td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + W</td>
<td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + E</td>
<td align="left">显示最近打开的文件记录列表</td>
</tr>
<tr>
<td align="left">Ctrl + N</td>
<td align="left">根据输入的 <strong>类名</strong> 查找类文件</td>
</tr>
<tr>
<td align="left">Ctrl + G</td>
<td align="left">在当前文件跳转到指定行处</td>
</tr>
<tr>
<td align="left">Ctrl + J</td>
<td align="left">插入自定义动态代码模板</td>
</tr>
<tr>
<td align="left">Ctrl + P</td>
<td align="left">方法参数提示显示</td>
</tr>
<tr>
<td align="left">Ctrl + Q</td>
<td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td align="left">Ctrl + U</td>
<td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td align="left">Ctrl + B</td>
<td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td>
</tr>
<tr>
<td align="left">Ctrl + K</td>
<td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + T</td>
<td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + H</td>
<td align="left">显示当前类的层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + O</td>
<td align="left">选择可重写的方法</td>
</tr>
<tr>
<td align="left">Ctrl + I</td>
<td align="left">选择可继承的方法</td>
</tr>
<tr>
<td align="left">Ctrl + +</td>
<td align="left">展开代码</td>
</tr>
<tr>
<td align="left">Ctrl + -</td>
<td align="left">折叠代码</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + [</td>
<td align="left">移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td align="left">Ctrl + ]</td>
<td align="left">移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td align="left">Ctrl + F1</td>
<td align="left">在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td align="left">Ctrl + F3</td>
<td align="left">调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td align="left">Ctrl + F4</td>
<td align="left">关闭当前编辑文件</td>
</tr>
<tr>
<td align="left">Ctrl + F8</td>
<td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td align="left">Ctrl + F9</td>
<td align="left">执行 Make Project 操作</td>
</tr>
<tr>
<td align="left">Ctrl + F11</td>
<td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td align="left">Ctrl + F12</td>
<td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td align="left">Ctrl + Tab</td>
<td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td align="left">Ctrl + Enter</td>
<td align="left">智能分隔行</td>
</tr>
<tr>
<td align="left">Ctrl + End</td>
<td align="left">跳到文件尾</td>
</tr>
<tr>
<td align="left">Ctrl + Home</td>
<td align="left">跳到文件头</td>
</tr>
<tr>
<td align="left">Ctrl + Space</td>
<td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Delete</td>
<td align="left">删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + BackSpace</td>
<td align="left">删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + 1,2,3…9</td>
<td align="left">定位到对应数值的书签位置</td>
</tr>
<tr>
<td align="left">Ctrl + 左键单击</td>
<td align="left">在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td align="left">Ctrl + 光标定位</td>
<td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td align="left">Ctrl + 左方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 右方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 前方向键</td>
<td align="left">等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td align="left">Ctrl + 后方向键</td>
<td align="left">等效于鼠标滚轮向后效果</td>
</tr>
</tbody></table>
<h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + `</td>
<td align="left">显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td align="left">Alt + Q</td>
<td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td align="left">Alt + F1</td>
<td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td align="left">Alt + F2</td>
<td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td align="left">Alt + F3</td>
<td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td align="left">Alt + F7</td>
<td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td align="left">Alt + F8</td>
<td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td align="left">Alt + Home</td>
<td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td align="left">Alt + Enter</td>
<td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Alt + Insert</td>
<td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td align="left">Alt + 左方向键</td>
<td align="left">按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 右方向键</td>
<td align="left">按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 前方向键</td>
<td align="left">当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 后方向键</td>
<td align="left">当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 1,2,3…9</td>
<td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
<tr>
<td align="left">Alt + 7</td>
<td align="left">显示当前类的所有方法、成员变量等</td>
</tr>
</tbody></table>
<h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Shift + F1</td>
<td align="left">如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td align="left">Shift + F2</td>
<td align="left">跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td align="left">Shift + F3</td>
<td align="left">在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td align="left">Shift + F4</td>
<td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td align="left">Shift + F6</td>
<td align="left">对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td align="left">Shift + F7</td>
<td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td align="left">Shift + F8</td>
<td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td align="left">Shift + F9</td>
<td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F10</td>
<td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F11</td>
<td align="left">弹出书签显示层</td>
</tr>
<tr>
<td align="left">Shift + Tab</td>
<td align="left">取消缩进</td>
</tr>
<tr>
<td align="left">Shift + ESC</td>
<td align="left">隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td align="left">Shift + End</td>
<td align="left">选中光标到当前行尾位置</td>
</tr>
<tr>
<td align="left">Shift + Home</td>
<td align="left">选中光标到当前行头位置</td>
</tr>
<tr>
<td align="left">Shift + Enter</td>
<td align="left">在当前行的下一行另起新行</td>
</tr>
<tr>
<td align="left">Shift+Alt+Enter</td>
<td align="left">在当前行的上一行另起新行</td>
</tr>
<tr>
<td align="left">Shift + 左键单击</td>
<td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
<tr>
<td align="left">Shift + 滚轮前后滚动</td>
<td align="left">当前文件的横向滚动轴滚动</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Alt + L</td>
<td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + O</td>
<td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + I</td>
<td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + T</td>
<td align="left">对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + J</td>
<td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + H</td>
<td align="left">调用层次</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + B</td>
<td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + V</td>
<td align="left">快速引进变量</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Y</td>
<td align="left">同步、刷新</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + S</td>
<td align="left">打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F7</td>
<td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F11</td>
<td align="left">切换全屏模式</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Enter</td>
<td align="left">光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Home</td>
<td align="left">弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Space</td>
<td align="left">类名自动完成</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 左方向键</td>
<td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 右方向键</td>
<td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 前方向键</td>
<td align="left">在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 后方向键</td>
<td align="left">在查找模式下，跳到下个查找的文件</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + F</td>
<td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + R</td>
<td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + J</td>
<td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Z</td>
<td align="left">取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + W</td>
<td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + N</td>
<td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + U</td>
<td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + T</td>
<td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + C</td>
<td align="left">复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + E</td>
<td align="left">显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + H</td>
<td align="left">显示方法层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + B</td>
<td align="left">跳转到类型声明处</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + I</td>
<td align="left">快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + A</td>
<td align="left">查找动作 / 设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + /</td>
<td align="left">代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + [</td>
<td align="left">选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + ]</td>
<td align="left">选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + +</td>
<td align="left">展开所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + -</td>
<td align="left">折叠所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F7</td>
<td align="left">高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F8</td>
<td align="left">在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F9</td>
<td align="left">编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F12</td>
<td align="left">编辑器最大化</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Space</td>
<td align="left">智能代码提示</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Enter</td>
<td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">退回到上次修改的地方</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 1,2,3…9</td>
<td align="left">快速添加指定数值的书签</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 前方向键</td>
<td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 后方向键</td>
<td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + Shift + N</td>
<td align="left">选择 / 添加 task</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td align="left">Alt + Shift + C</td>
<td align="left">查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">添加到收藏夹</td>
</tr>
<tr>
<td align="left">Alt + Shift + I</td>
<td align="left">查看项目当前文件</td>
</tr>
<tr>
<td align="left">Alt + Shift + F7</td>
<td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td align="left">Alt + Shift + F9</td>
<td align="left">弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + F10</td>
<td align="left">弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + 左键双击</td>
<td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td align="left">Alt + Shift + 前方向键</td>
<td align="left">移动光标所在行向上移动</td>
</tr>
<tr>
<td align="left">Alt + Shift + 后方向键</td>
<td align="left">移动光标所在行向下移动</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + Alt + V</td>
<td align="left">无格式黏贴</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + N</td>
<td align="left">前往指定的变量 / 方法</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + S</td>
<td align="left">打开当前项目设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + C</td>
<td align="left">复制参考信息</td>
</tr>
</tbody></table>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">F2</td>
<td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">F3</td>
<td align="left">在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td align="left">F4</td>
<td align="left">编辑源</td>
</tr>
<tr>
<td align="left">F7</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td align="left">F8</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td align="left">F9</td>
<td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td align="left">F11</td>
<td align="left">添加书签</td>
</tr>
<tr>
<td align="left">F12</td>
<td align="left">回到前一个工具窗口</td>
</tr>
<tr>
<td align="left">Tab</td>
<td align="left">缩进</td>
</tr>
<tr>
<td align="left">ESC</td>
<td align="left">从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td align="left">连按两次Shift</td>
<td align="left">弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody></table>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>查看/设置模板：</p>
<p>Live Templates中可以查看、<strong>编辑、添加以及删除</strong>模板：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142838850.png" alt="image-20200816142838850" style="zoom:80%;" />



<p>Postfix Completion中只能查看、禁用。下图的Before框表示模板的预定义形式，After表示输出效果。比如下图的例子，输入<code>foo.forr</code>，摁下enter。将输出after框的模板。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142928743.png" alt="image-20200816142928743" style="zoom:67%;" />



<h3 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816153643738.png" alt="image-20200816153643738" style="zoom: 80%;" />

<p>如上图操作，输入模板组名，确定。选中创建的模板组，点击<code>+</code>，点击<code>Live Template</code>在组中添加新模板。</p>
<p>设置新模板：</p>
<ul>
<li>1处填写模板缩写</li>
<li>2处填写模板的描述</li>
<li>3处定义模板内容。<strong>例子中模板的意义：</strong>输入test按下enter出现模板后，光标会跳至<code>$var1$</code>位置，输入完成后按enter，光标跳至<code>$var2$</code>处。</li>
</ul>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154245765.png" alt="image-20200816154245765"></p>
<p>下一步，点击define，选择java：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154543995.png" alt="image-20200816154543995" style="zoom:67%;" />



<p>点击OK即可。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200821195633214.png" alt="image-20200821195633214" style="zoom:67%;" />



<h3 id="idea自带模板"><a href="#idea自带模板" class="headerlink" title="idea自带模板"></a>idea自带模板</h3><table>
<thead>
<tr>
<th>Before</th>
<th align="left">After</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>psvm</code></td>
<td align="left"><code>public static void main(String[] args) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>sout</code></td>
<td align="left"><code>System.out.println();</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>soutm</code></td>
<td align="left"><code>System.out.println(&quot;当前方法的全限定名&quot;);</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>soutp</code></td>
<td align="left"><code>System.out.println(&quot;c = &quot; + c);</code></td>
<td align="left">以<code>valueName=value</code><br>的形式输出</td>
</tr>
<tr>
<td><code>soutv</code></td>
<td align="left">与上同</td>
<td align="left">输出某一变量</td>
</tr>
<tr>
<td><code>variable.sout</code></td>
<td align="left"><code>System.out.println(variable);</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>fori</code> （<strong>递增</strong>）</td>
<td align="left"><code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></td>
<td align="left">输入完成后光标跳至第一个i后<br>可改变变量名；按enter光标跳至&lt;后<br>再按enter跳至<code>&#123;&#125;</code>中</td>
</tr>
<tr>
<td><code>arrs/List/Set.fori</code></td>
<td align="left"><code>for (int i = 0; i &lt; xxx.size(); i++) &#123;&#125;</code></td>
<td align="left">可对数组、集合使用。</td>
</tr>
<tr>
<td><code>forr</code>（递减）</td>
<td align="left">与上同理</td>
<td align="left"></td>
</tr>
<tr>
<td><code>arrs/List/Set.forr</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td><code>iter</code></td>
<td align="left"><code>for (T t : arrs) &#123;&#125;</code></td>
<td align="left">对某一数组使用forEach循环</td>
</tr>
<tr>
<td><code>arrs.iter</code></td>
<td align="left">同上</td>
<td align="left">对指定数组使用forEach循环</td>
</tr>
<tr>
<td><code>itar</code></td>
<td align="left"><code>for (int i = 0; i &lt; arr.length; i++) &#123;int i1 =arr[i];&#125;</code></td>
<td align="left">对代码中上一个数组使用普通for循环</td>
</tr>
<tr>
<td><code>ifn</code></td>
<td align="left"><code>if (xxx == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>value.null</code></td>
<td align="left"><code>if (value == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>inn</code> （if not null）</td>
<td align="left"><code>if (st != null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>value.nn</code></td>
<td align="left"><code>if (value == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>prsf</code></td>
<td align="left"><code>private static final</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psfi</code></td>
<td align="left"><code>public static final int</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psfs</code></td>
<td align="left"><code>public static final String</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psf</code></td>
<td align="left"><code>public static final</code></td>
<td align="left"></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="快捷创建Mybatis主配置文件"><a href="#快捷创建Mybatis主配置文件" class="headerlink" title="快捷创建Mybatis主配置文件"></a>快捷创建Mybatis主配置文件</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130058653.png" alt="image-20200914130058653" style="zoom: 80%;" />



<p>填写Name以及文件类型（Extension），并在方框内写入初始代码：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130320437.png" alt="image-20200914130320437"></p>
<p>Apply，即完成模板设置。</p>
<p>右键New创建文件时，即可看到创建的模板：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130454583.png" alt="image-20200914130454583" style="zoom:80%;" />





<h2 id="版本控制（git）"><a href="#版本控制（git）" class="headerlink" title="版本控制（git）"></a>版本控制（git）</h2><h3 id="克隆GitHub的项目到idea中"><a href="#克隆GitHub的项目到idea中" class="headerlink" title="克隆GitHub的项目到idea中"></a>克隆GitHub的项目到idea中</h3><p>1.先在idea中配置好git安装目录：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817131825434.png" style="zoom: 67%;" />



<p>2.添加GitHub账户</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817132350071.png" alt="image-20200817132350071" style="zoom: 67%;" />



<p>3.从GitHub上clone仓库：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134058705.png" alt="image-20200817134058705" style="zoom:80%;" />

<p>或者：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134723950.png" alt="image-20200817134723950" style="zoom:80%;" />

<p>4.填写仓库信息</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134256096.png" alt="image-20200817134256096" style="zoom:80%;" />



<p>5.是否为clone的仓库创建新项目，选择yes：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134413600.png" alt="image-20200817134413600" style="zoom:67%;" />

<p>后面是创建项目的一些选项，此处省略。</p>
<p>完成。</p>
<p>6.clone后，在idea中左侧的项目框右键：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135922566.png" alt="image-20200817135922566" style="zoom:67%;" />

<p>即可看到git的各种操作。</p>
<p>没有add的文件在idea中会显示为红色。</p>
<h3 id="将本地项目Share到GitHub"><a href="#将本地项目Share到GitHub" class="headerlink" title="将本地项目Share到GitHub"></a>将本地项目Share到GitHub</h3><p>这种方式将会在GitHub创建一个仓库，并将项目push到该仓库。</p>
<p>步骤：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135325861.png" alt="image-20200817135325861" style="zoom:80%;" />



<p>后续步骤简单，省略。</p>
<h2 id="Idea自带的文件修改历史功能"><a href="#Idea自带的文件修改历史功能" class="headerlink" title="Idea自带的文件修改历史功能"></a>Idea自带的文件修改历史功能</h2><p>右键一个文件-》【Local History】=》【show History】，即可看到文件的修改历史。</p>
<p>本地历史的相关信息保存在<code>C:\User\.IntelliJIdea2019.3\system\LocalHistory</code>下。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>调试的界面和各种按钮，<strong>鼠标悬停在按钮上可查看快捷键信息</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141152314.png" alt="image-20200817141152314" style="zoom:80%;" />

<p><strong>各种操作的含义</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817140516654.png" alt="image-20200817140516654" style="zoom: 67%;" />



<h3 id="为断点添加条件"><a href="#为断点添加条件" class="headerlink" title="为断点添加条件"></a>为断点添加条件</h3><p>即在该断点停止的条件是满足设置的条件。</p>
<p>例子：</p>
<p>创建一个for循环，并在输出语句添加断点：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141741524.png" alt="image-20200817141741524" style="zoom:80%;" />

<p>右键断点，在condition中设置条件：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141829128.png" alt="image-20200817141829128" style="zoom:80%;" />

<p>启动Debug，停止时i的值是60：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817142010635.png" alt="image-20200817142010635" style="zoom:67%;" />



<h3 id="调试过程中查看变量的值"><a href="#调试过程中查看变量的值" class="headerlink" title="调试过程中查看变量的值"></a>调试过程中查看变量的值</h3><p>基本数据类型的值可直接在界面上查看，如上述例子。对于引用类型变量，若要查看具体的属性信息，可将鼠标悬停在变量上，点击<code>+</code>即可查看。</p>
<h2 id="创建Javadoc文档"><a href="#创建Javadoc文档" class="headerlink" title="创建Javadoc文档"></a>创建Javadoc文档</h2><p>步骤：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817150847896.png" alt="image-20200817150847896" style="zoom:80%;" />



<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817151557958.png" alt="image-20200817151557958" style="zoom:67%;" />



<p><strong>PS</strong>：命令行参数中，指定的字符集要和项目的字符集一致。</p>
<h2 id="清除缓存和索引"><a href="#清除缓存和索引" class="headerlink" title="清除缓存和索引"></a>清除缓存和索引</h2><p>IDEA首次加载项目时会创建索引。</p>
<p>IntelliJ IDEA的缓存和索引<strong>主要是用来加快文件查询， 从而加快各种查找、代码提示等操作的速度</strong>。但是， IntelliJ IDEA的索引和缓存并不是一直会良好地支持IntelliJ IDEA的，某些特殊条件下， IntelliJ IDEA的缓存和索引文件也是会损坏的， 比如：断电、蓝屏引起的强制关机， 当你重新打开IntelliJ IDEA， 很可能Intell IDEA会报各种莫名其妙错误。这种情况可以清理下缓存和索引。如下：</p>
<p>【File】-》【Invalidate cache/Restart】，选择invalidate and restart。</p>
<p>或者将<code>C:\User\.IntelliJIdea2019.3\system</code>文件删除（需要idea先关闭），并再次启动idea，等待其重新创建索引即可。</p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="下载maven导入jar包的源码和依赖"><a href="#下载maven导入jar包的源码和依赖" class="headerlink" title="下载maven导入jar包的源码和依赖"></a>下载maven导入jar包的源码和依赖</h3><p>点击右侧边栏的maven，如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215147737.png" alt="image-20200820215147737" style="zoom:80%;" />

<p>选择<code>Download Sources</code>下载源码的jar包；选择<code>Download Documentation</code>下载说明文档（javadoc文件）；或者两者都下载。</p>
<p>打开maven的仓库目录，按下图找到对应目录：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215358815.png" alt="image-20200820215358815" style="zoom: 80%;" />



<p>如该图中到仓库下的<code>com\google\protobuf\protobuf-java\3.11.4</code>目录下，可看见下载的javadoc和sources的jar包。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215629801.png" alt="image-20200820215629801" style="zoom: 80%;" />



<h3 id="maven项目构建可执行jar包（包含导入的依赖）"><a href="#maven项目构建可执行jar包（包含导入的依赖）" class="headerlink" title="maven项目构建可执行jar包（包含导入的依赖）"></a>maven项目构建可执行jar包（包含导入的依赖）</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dzblog/p/6913809.html">https://www.cnblogs.com/dzblog/p/6913809.html</a></p>
</blockquote>
<ol>
<li><p>pom.xml文件中配置插件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此处指定main方法入口的class --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>包含main方法的入口类全限定名<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行package命令：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924215425450.png" alt="image-20200924215425450"></p>
</li>
<li><p>在target目录下即可看见项目的包含依赖的可执行jar包。</p>
</li>
</ol>
<blockquote>
<p>不包含依赖、包含部分依赖的打包方式见参考链接。</p>
</blockquote>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/IDEA/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/IDEA/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/" class="post-title-link" itemprop="url">IDEA快捷键大全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-30 13:02:36 / 修改时间：13:03:01" itemprop="dateCreated datePublished" datetime="2021-08-30T13:02:36+08:00">2021-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>以下绝大部分copy自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p>
</blockquote>
<h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><span style="color:red;">Ctrl + F</span></strong></td>
<td align="left">在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + R</td>
<td align="left">在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Z</td>
<td align="left">撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Y</td>
<td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + X</td>
<td align="left">剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + C</td>
<td align="left">复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + D</td>
<td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + W</td>
<td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + E</td>
<td align="left">显示最近打开的文件记录列表</td>
</tr>
<tr>
<td align="left">Ctrl + N</td>
<td align="left">根据输入的 <strong>类名</strong> 查找类文件</td>
</tr>
<tr>
<td align="left">Ctrl + G</td>
<td align="left">在当前文件跳转到指定行处</td>
</tr>
<tr>
<td align="left">Ctrl + J</td>
<td align="left">插入自定义动态代码模板</td>
</tr>
<tr>
<td align="left">Ctrl + P</td>
<td align="left">方法参数提示显示</td>
</tr>
<tr>
<td align="left">Ctrl + Q</td>
<td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td align="left">Ctrl + U</td>
<td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td align="left">Ctrl + B</td>
<td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td>
</tr>
<tr>
<td align="left">Ctrl + K</td>
<td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + T</td>
<td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left"><strong>Ctrl + H</strong></td>
<td align="left"><strong>显示当前类的层次结构</strong></td>
</tr>
<tr>
<td align="left">Ctrl + O</td>
<td align="left">选择可重写的方法</td>
</tr>
<tr>
<td align="left">Ctrl + I</td>
<td align="left">选择可继承的方法</td>
</tr>
<tr>
<td align="left">Ctrl + +</td>
<td align="left">展开代码</td>
</tr>
<tr>
<td align="left">Ctrl + -</td>
<td align="left">折叠代码</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + [</td>
<td align="left">移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td align="left">Ctrl + ]</td>
<td align="left">移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td align="left">Ctrl + F1</td>
<td align="left">在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td align="left">Ctrl + F3</td>
<td align="left">调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td align="left">Ctrl + F4</td>
<td align="left">关闭当前编辑文件</td>
</tr>
<tr>
<td align="left">Ctrl + F8</td>
<td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td align="left">Ctrl + F9</td>
<td align="left">执行 Make Project 操作</td>
</tr>
<tr>
<td align="left">Ctrl + F11</td>
<td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td align="left">Ctrl + F12</td>
<td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td align="left">Ctrl + Tab</td>
<td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td align="left">Ctrl + Enter</td>
<td align="left">智能分隔行</td>
</tr>
<tr>
<td align="left">Ctrl + End</td>
<td align="left">跳到文件尾</td>
</tr>
<tr>
<td align="left">Ctrl + Home</td>
<td align="left">跳到文件头</td>
</tr>
<tr>
<td align="left">Ctrl + Space</td>
<td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Delete</td>
<td align="left">删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + BackSpace</td>
<td align="left">删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + 1,2,3…9</td>
<td align="left">定位到对应数值的书签位置</td>
</tr>
<tr>
<td align="left">Ctrl + 左键单击</td>
<td align="left">在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td align="left">Ctrl + 光标定位</td>
<td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td align="left">Ctrl + 左方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 右方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 前方向键</td>
<td align="left">等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td align="left">Ctrl + 后方向键</td>
<td align="left">等效于鼠标滚轮向后效果</td>
</tr>
</tbody></table>
<h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + `</td>
<td align="left">显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td align="left">Alt + Q</td>
<td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td align="left">Alt + F1</td>
<td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td align="left">Alt + F2</td>
<td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td align="left">Alt + F3</td>
<td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td align="left">Alt + F7</td>
<td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td align="left">Alt + F8</td>
<td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td align="left">Alt + Home</td>
<td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td align="left">Alt + Enter</td>
<td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Alt + Insert</td>
<td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td align="left">Alt + 左方向键</td>
<td align="left">按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 右方向键</td>
<td align="left">按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 前方向键</td>
<td align="left">当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 后方向键</td>
<td align="left">当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 1,2,3…9</td>
<td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
</tbody></table>
<h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Shift + F1</td>
<td align="left">如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td align="left">Shift + F2</td>
<td align="left">跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td align="left">Shift + F3</td>
<td align="left">在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td align="left">Shift + F4</td>
<td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td align="left">Shift + F6</td>
<td align="left">对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td align="left">Shift + F7</td>
<td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td align="left">Shift + F8</td>
<td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td align="left">Shift + F9</td>
<td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F10</td>
<td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F11</td>
<td align="left">弹出书签显示层</td>
</tr>
<tr>
<td align="left">Shift + Tab</td>
<td align="left">取消缩进</td>
</tr>
<tr>
<td align="left">Shift + ESC</td>
<td align="left">隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td align="left">Shift + End</td>
<td align="left">选中光标到当前行尾位置</td>
</tr>
<tr>
<td align="left">Shift + Home</td>
<td align="left">选中光标到当前行头位置</td>
</tr>
<tr>
<td align="left">Shift + Enter</td>
<td align="left">在当前行的下一行另起新行</td>
</tr>
<tr>
<td align="left">Shift+Alt+Enter</td>
<td align="left">在当前行的上一行另起新行</td>
</tr>
<tr>
<td align="left">Shift + 左键单击</td>
<td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
<tr>
<td align="left">Shift + 滚轮前后滚动</td>
<td align="left">当前文件的横向滚动轴滚动</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><span style="color:red;">Ctrl + Alt + L</span></strong></td>
<td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + O</td>
<td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + I</td>
<td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + T</td>
<td align="left">对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + J</td>
<td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + H</td>
<td align="left">调用层次</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + B</td>
<td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + V</td>
<td align="left">快速引进变量</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Y</td>
<td align="left">同步、刷新</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + S</td>
<td align="left">打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F7</td>
<td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F11</td>
<td align="left">切换全屏模式</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Enter</td>
<td align="left">光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Home</td>
<td align="left">弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Space</td>
<td align="left">类名自动完成</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 左方向键</td>
<td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 右方向键</td>
<td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 前方向键</td>
<td align="left">在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 后方向键</td>
<td align="left">在查找模式下，跳到下个查找的文件</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + F</td>
<td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + R</td>
<td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + J</td>
<td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Z</td>
<td align="left">取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + W</td>
<td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + N</td>
<td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + U</td>
<td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + T</td>
<td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + C</td>
<td align="left">复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + E</td>
<td align="left">显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + H</td>
<td align="left">显示方法层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + B</td>
<td align="left">跳转到类型声明处</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + I</td>
<td align="left">快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + A</td>
<td align="left">查找动作 / 设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + /</td>
<td align="left">代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + [</td>
<td align="left">选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + ]</td>
<td align="left">选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + +</td>
<td align="left">展开所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + -</td>
<td align="left">折叠所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F7</td>
<td align="left">高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F8</td>
<td align="left">在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F9</td>
<td align="left">编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F12</td>
<td align="left">编辑器最大化</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Space</td>
<td align="left">智能代码提示</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Enter</td>
<td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">退回到上次修改的地方</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 1,2,3…9</td>
<td align="left">快速添加指定数值的书签</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 前方向键</td>
<td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 后方向键</td>
<td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + Shift + N</td>
<td align="left">选择 / 添加 task</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td align="left">Alt + Shift + C</td>
<td align="left">查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">添加到收藏夹</td>
</tr>
<tr>
<td align="left">Alt + Shift + I</td>
<td align="left">查看项目当前文件</td>
</tr>
<tr>
<td align="left">Alt + Shift + F7</td>
<td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td align="left">Alt + Shift + F9</td>
<td align="left">弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + F10</td>
<td align="left">弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + 左键双击</td>
<td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td align="left">Alt + Shift + 前方向键</td>
<td align="left">移动光标所在行向上移动</td>
</tr>
<tr>
<td align="left">Alt + Shift + 后方向键</td>
<td align="left">移动光标所在行向下移动</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + Alt + V</td>
<td align="left">无格式黏贴</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + N</td>
<td align="left">前往指定的变量 / 方法</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + S</td>
<td align="left">打开当前项目设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + C</td>
<td align="left">复制参考信息</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">F2</td>
<td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">F3</td>
<td align="left">在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td align="left">F4</td>
<td align="left">编辑源</td>
</tr>
<tr>
<td align="left">F7</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td align="left">F8</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td align="left">F9</td>
<td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td align="left">F11</td>
<td align="left">添加书签</td>
</tr>
<tr>
<td align="left">F12</td>
<td align="left">回到前一个工具窗口</td>
</tr>
<tr>
<td align="left">Tab</td>
<td align="left">缩进</td>
</tr>
<tr>
<td align="left">ESC</td>
<td align="left">从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td align="left">连按两次Shift</td>
<td align="left">弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/IDEA/idea%E5%B8%B8%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/IDEA/idea%E5%B8%B8%E7%94%A8/" class="post-title-link" itemprop="url">IDEA常用快捷键&操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-30 13:02:36 / 修改时间：13:02:53" itemprop="dateCreated datePublished" datetime="2021-08-30T13:02:36+08:00">2021-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;&emsp;</p>
<ul>
<li>ctrl+w：逐渐向外层选中</li>
<li>CTRL+shift+上下：当前行上下移</li>
<li>SHIFT+F10：运行main</li>
<li>CTRL+F2：停止运行</li>
<li>shift+esc：关闭下方窗口</li>
<li>CTRL+shift+左右：跳转至上/下一个方法（上/下一个历史光标位置）</li>
<li>CTRL+F12：弹出窗口形式查看当前类的所有方法</li>
<li>Alt+7：左边小窗口查看当前类所有方法</li>
<li>SHIFT + F2：定位到报错处（红线）</li>
<li>CTRL + R：替换指定文本。</li>
<li>SHIFT + F6：批量修改变量、方法名。</li>
<li>CTRL + ALT + V：抽取变量（<strong>已改为ALT + X</strong>）</li>
<li>CTRL + ALT + B/左键：方法具体实现</li>
<li>CTRL + ALT + M：将选中代码提取为方法</li>
<li>CTRL + ALT + P：抽取为方法参数，并修改方法被引用的地方</li>
<li>ALT + 1：打开Project 窗口。</li>
<li>CTRL + E：最近文件窗口。</li>
<li>CTRL + P：方法、构造器参数提示。</li>
<li>ALT + F7：查看指定方法/变量等被引用的次数和位置。</li>
</ul>
<p>&emsp;&emsp;</p>
<ul>
<li><p>debug时，下方的Frames窗口对应虚拟机栈，其中每个项就是一个栈帧（对应一个方法），右边的Variables对应该栈帧的局部变量表。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209202217531.png" alt="image-20210209202217531"></p>
</li>
<li><p>多个线程下调试时，右键断电，选择Thread</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212458998.png" alt="image-20210209212458998"></p>
<p>此时在此时选择线程：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212821981.png" alt="image-20210209212821981"></p>
</li>
<li><p>debug过程可以修改变量的值：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210222235056874.png" alt="image-20210222235056874"></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">网络总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 13:00:30" itemprop="dateModified" datetime="2021-08-30T13:00:30+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是“网络协议”？"><a href="#什么是“网络协议”？" class="headerlink" title="什么是“网络协议”？"></a>什么是“网络协议”？</h2><p>计算机网络中的数据交换<strong>必须遵守事先约定好的规则</strong>。<strong>这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）</strong>。<strong>网络协议</strong>（Network Protocol），简称为协议，<strong>是为进行网络中的数据交换而建立的规则、标准或约定</strong>。</p>
<p><strong>网络协议的三要素</strong> </p>
<ul>
<li><strong>语法</strong>  数据与控制信息的结构或格式</li>
<li><strong>语义</strong>  控制信息的意义，需要发出何种控制信息，完成何种动作以及做出何种响应。</li>
<li><strong>同步</strong>  事件实现顺序的详细说明。</li>
</ul>
<h2 id="分层网络模型"><a href="#分层网络模型" class="headerlink" title="分层网络模型"></a>分层网络模型</h2><h3 id="为什么分层？"><a href="#为什么分层？" class="headerlink" title="为什么分层？"></a>为什么分层？</h3><p><strong>分层的目的就是为了将困难的问题简单化</strong>，并且如果分层了，在使用的时候就<strong>可以仅仅关注需要关注的层次，而不用理会其他层</strong>。如果需要改动设计的时候，只需要把变动的层替换即可，并不用涉及到其他的层次。</p>
<h3 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h3><p>OSI的七层协议体系结构概念清楚，理论完整<strong>但复杂且不实用</strong>。<strong>TCP/IP是四层的体系结构：应用层、运输层网际层和网络接口层</strong>。<strong>但</strong>最下面的网络接口层并没有具体内容。因此往往采取折中的办法，即<strong>综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构</strong>。</p>
<p><strong>OSI、TCP/IP、五层协议结构的图示</strong>：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200405153045896.png" alt="image-20200405153045896"></p>
<p><strong>每一层向上一层提供服务，且对上层是透明的，同时每一层会使用其下一层的服务</strong>。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层决定了向用户提供应用服务时通信的活动</strong>。</p>
<p>应用层位于最上层，电脑或⼿机使用的应用软件都是在应用层实现。<strong>应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的</strong>，就类似于，我们寄快递的时候， 只需要把包裹交给快递员，由他负责运输快递，我们不需要关⼼快速是如何被运输的。<br>⽽且应用层是⼯作在操作系统中的用户态，传输层及以下则工作在内核态。</p>
<p>应用层的协议有 HTTP、SMTP、FTP、DNS 等。</p>
<p><strong>应用层交互的数据单元称为报文</strong>（message）。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>DNS，Domain Name System，即域名系统。</p>
<p><strong>其主要任务是将域名映射为对应的 IP 地址。DNS 协议运行在 UDP 之上</strong>，使用 <strong>53 号端口</strong> 。DNS 通常是<strong>被其他应用层协议所使用</strong>的，包括 HTTP 、 SMTP 和 FTP。</p>
<p>DNS 是：</p>
<p>①一个由分层的 DNS 服务器（DN server）实现的<strong>分布式数据库</strong> ; 分布式数据库是指，<strong>每个站点只保留它自己的那部分数据</strong>。</p>
<p>②一个使得主机能够查询分布式数据库的应用层协议。</p>
<blockquote>
<p>DNS 还包括其他功能。</p>
</blockquote>
<h4 id="DNS-服务器层级关系"><a href="#DNS-服务器层级关系" class="headerlink" title="DNS 服务器层级关系"></a>DNS 服务器层级关系</h4><p>域名具有层次结构，从上到下依次为：根域名（<code>.</code>）、顶级域名（<code>com/cn/edu/gov</code>）、二级域名（<code>google/baidu/att</code>）。</p>
<p>DNS 系统包含了大量的 DNS 服务器，它们以层次方式组织，对应着域名的层次可以分为：</p>
<ul>
<li><p><strong>根 DNS 服务器</strong>。根据域名的顶级域（com、cn 等）映射到对应的顶级域 DNS 服务器。</p>
</li>
<li><p><strong>顶级域（Top-Level Domain，TLD） DNS 服务器</strong>。这些服务器负责顶级域名如 com 、 org 、 net 、 edu 和 gov ，将域名映射到对应的权威 DNS 服务器。</p>
</li>
<li><p><strong>权威 DNS 服务器</strong>。这些服务器上真正<strong>保存了主机名到 IP 地址的映射</strong>。在因特网上具有公共可访问主机的每个组织机构需要有一个权威 DNS 服务器，<strong>服务器里保存了该组织内主机的 DNS 记录</strong>。</p>
<blockquote>
<p>或者支付费用，让这些记录存储在某个服务提供商的一个权威 DNS 服 务器中。</p>
</blockquote>
</li>
</ul>
<p>它们的层级关系如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210429122112026.png" alt="image-20210429122112026" style="zoom:80%;" />



<p>还有一类重要的 DNS 服务器称为<strong>本地 DNS 服务器</strong>。它不在上述的层级体系中。</p>
<p>每个 ISP (如一 个大学、一个系、一个公司或一个居民区的 ISP) 都有一台本地 DNS 服务器(也叫默认名字服务器) 。本地 DNS 服务器<strong>通常“邻近”本主机</strong>，比如在同一个局域网、或距离（物理距离）近、或只需几次的路由跳转。<strong>当主机发出 DNS 请求时，该请求会被发往本地 DNS 服务器，它起着代理的作用，将该请求转发到 DNS 服务器层次结构中，并把结果返回给主机</strong>。</p>
<h4 id="DNS-工作过程"><a href="#DNS-工作过程" class="headerlink" title="DNS 工作过程"></a>DNS 工作过程</h4><p>假设请求主机想知道域名 <code>abc.cs.school.edu</code> 对应的 IP 地址，DNS 解析过程如下：</p>
<ul>
<li><p>主机向本地 DNS 服务器发送一个 DNS 查询报文。</p>
</li>
<li><p>本地 DNS 服务器收到请求后，会先<strong>检查是否有 <code>abc.cs.school.edu</code> 对应的缓存</strong>，有则返回；否则将发送查询报文至根 DNS 服务器。</p>
</li>
<li><p>根 DNS 服务器<strong>向本地 DNS 服务器返回</strong>对应的顶级域 DNS 服务器（<code>edu</code>）的 IP 地址。</p>
</li>
<li><p>本地 DNS 服务器继续发送查询报文至顶级域 DNS 服务器（<code>edu</code>）。</p>
</li>
<li><p>顶级域 DNS 服务器（<code>edu</code>）<strong>向本地 DNS 服务器返回对应权威 DNS 服务器（<code>school.edu</code>）的 IP 地址</strong>。</p>
</li>
<li><p>本地 DNS 服务器再次发送查询报文至权威 DNS 服务器（<code>school.edu</code>），权威 DNS 服务器向本地 DNS 服务器发送 <code>abc.cs.school.edu</code> 对应的 IP 地址。</p>
<blockquote>
<p>若二级域名 <code>school</code> 包含多个子域（比如大学里的每个系都有一个权威 DNS 服务器），那么权威 DNS 服务器（<code>school.edu</code>）还需要向本地 DNS 服务器发送对应的权威 DNS 服务器（<code>cs.school.edu</code>）的 IP 地址，然后本地 DNS 服务器需要再次向权威 DNS 服务器（<code>cs.school.edu</code>）发送查询，权威 DNS 服务器（<code>cs.school.edu</code>）最终才返回 <code>abc.cs.school.edu</code> 对应的 IP 地址。</p>
</blockquote>
</li>
<li><p>本地 DNS 服务器把 IP 地址响应回主机，并存在缓存中，结束。</p>
</li>
</ul>
<p>图示：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210429162429610.png" alt="image-20210429162429610" style="zoom:80%;" />

<p>可以看到本地 DNS 服务器起着代理的作用，将该请求转发到 DNS 服务器层次结构中，最后把得到的结果返回给主机。</p>
<h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><p>本地 DNS 服务器获取一个域名的 IP 地址后，会存入本地缓存，下次主机请求该域名时，直接返回缓存的 IP 地址即可。<strong>缓存在一段时间后会失效</strong>。</p>
<p>另外，本地 DNS 服务器<strong>还可以缓存顶级域 DNS 服务器的 IP 地址</strong>，所以允许本地 DNS 服务器绕过根 DNS 服务器。</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>运输层的任务就是<strong>负责向两台主机中的<font color="red">进程之间</font>的通信提供通用的数据传输服务。应用层的进程利用该服务传送应用层报文</strong>。</p>
<p>运输层有<strong>复用和分用</strong>的功能：复用就是<strong>多个应用层进程可同时使用运输层的服务</strong>；分用和复用相反，是运输层<strong>把收到的信息分别交付上面应用层中的相应进程</strong>。</p>
<p>运输层主要使用以下两种协议：</p>
<ul>
<li><p><strong>传输控制协议 TCP</strong>（Transmission Control Protocol） 提供面向连接的、可靠的数据传输服务。应用层要传输的数据可能会比较大，如果直接传输会不好控制，所以当传输层的数据包大于 <strong>MSS（TCP 最大报文段长度）</strong>时，就要将数据包分段传输，<strong>这样即使中途有⼀个分块丢失或损坏了，只需要重新这⼀个分块，⽽不用重新发送整个数据包</strong>。每个分块就是一个<strong>报文段</strong>（segment）。</p>
<p>⼀台设备上可能会有很多应用在接收或者传输数据，因此需要用⼀个编号将应用区分开来，这个编号就是<strong>端⼝</strong>。接收方可以根据端口号识别出该报⽂是发送给哪个应用。</p>
</li>
<li><p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是<strong>用户数据报</strong>。</p>
</li>
</ul>
<p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p>
<h3 id="为什么需要运输层"><a href="#为什么需要运输层" class="headerlink" title="为什么需要运输层"></a>为什么需要运输层</h3><p><strong>IP层的IP地址只是标识了两台主机，只能实现两个主机间的通信，而真正进行通信的是两个主机中的实体（进程），运输层通过端口来标识主机中的进程，实现进程间的通信</strong>。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP，User Datagram Protocol，用户数据报协议。</p>
<p><strong>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能， 这就是复用分用的功能以及差错检测的功能</strong>。UDP的主要特点是：</p>
<ul>
<li><strong>无连接</strong>。即发送数据之前不用建立连接。</li>
<li>UDP使用<strong>尽最大努力交付</strong>。</li>
<li>UDP是<strong>面向报文</strong>的。即应用层交下来的报文，UDP既不合并，也不拆分，只加上UDP首部后直接发送；相应的，接收时去除首部后直接上交应用层。</li>
<li><strong>没有拥塞控制</strong>。即网络的拥塞不会使源主机发送速率降低。但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信）</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li>
<li>首部开销小，8B。</li>
</ul>
<h3 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h3><p>TCP，Transmission Control Protocol，传输控制协议。</p>
<p>TCP的主要特点：</p>
<ul>
<li><strong>面向连接</strong>。即使用tcp之前（通信之前）需要建立可靠连接，通信完毕后释放连接。</li>
<li>每一个TCP连接<strong>只能有两个端点</strong>。<ul>
<li>TCP连接的端点叫做<strong>套接字（socket）</strong>，一个套接字<strong>由<code>IP地址:端口号</code>组成</strong>。<strong>一个TCP连接由两个套接字唯一确定</strong>。</li>
</ul>
</li>
<li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据， <strong>无差错、不丢失、不重复，并且按序到达</strong>。</li>
<li>TCP提供<strong>全双工通信</strong>。TCP允许<strong>通信双方的应用进程在任何时候都能发送数据</strong>。<ul>
<li><strong style="color:red">TCP连接的两端都设有发送缓存和接收缓存， 用来临时存放双向通信的数据</strong>。<strong>在发送时，应用程序在把数据传送给TCP的缓存后， 就可以做自己的事， 而TCP在合适的时候把数据发送出去。在接收时， TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</strong>。</li>
</ul>
</li>
<li><strong>面向字节流</strong>。<strong style="color:red">TCP中的“流”(stream) 指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块(<strong>大小不等</strong>) ， 但TCP把应用程序交下来的数据<strong>仅仅看成是一连串的无结构的字节流</strong>。TCP并不知道所传送的字节流的含义。TCP<strong>不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</strong>。<strong>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</strong>。</li>
</ul>
<h3 id="TCP可靠传输原理"><a href="#TCP可靠传输原理" class="headerlink" title="TCP可靠传输原理"></a>TCP可靠传输原理</h3><p>（来自JavaGuide）</p>
<p>概述：</p>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待协议的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组</strong>。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就<strong>重传前面发送过的分组</strong>（认为刚才发送过的分组丢失了）。因此<strong>每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些</strong>。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。</p>
<p><strong>若收到重复分组，就丢弃该分组，但同时还要发送确认</strong>。<strong>连续 ARQ 协议</strong> 可提高信道利用率。</p>
<p><strong>3) 确认丢失和确认迟到</strong>                   </p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下<strong>两点措施</strong>：<strong>1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。</strong> </li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。<strong>处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1</strong>。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。<strong>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</strong>。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> <strong>不能向发送方反映出接收方已经正确收到的所有分组的信息</strong>。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h4 id="滑动窗口实现流量控制"><a href="#滑动窗口实现流量控制" class="headerlink" title="滑动窗口实现流量控制"></a>滑动窗口实现流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率</strong>。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>​    </p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫<strong>拥塞</strong>。<strong>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载</strong>。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<blockquote>
<p>cwnd指拥塞窗口长度</p>
</blockquote>
<ul>
<li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是<strong>先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。<strong>每当出现超时的时候重新开始发送时即使用慢开始</strong>。</p>
</li>
<li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是<strong>让拥塞窗口cwnd缓慢增大</strong>，即每经过一个往返时间RTT就把发送放的cwnd加1。</p>
</li>
<li><p><strong>快重传与快恢复（fast retransmit and recovery，FRR）</strong>：采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。<strong>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认（这里已收到的报文段是指失序段之前的报文段）</strong>。</p>
<p>如图（来自《计算机网络》所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3；但却收到了M4。本来接收方可以什么都不做。<strong>但按照快重传算法，接收方必须立即发送对M2的重复确认（注意是M2）</strong>，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送Ms和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M的确认，其中后3个都是重复确认。<strong>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞</strong>。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210307172719911.png" alt="image-20210307172719911"></p>
<p>相应的，<strong>发送方知道只是丢失个别报文段，重新发送数据时不会启动慢开始，而是执行快恢复算法，即适当调整cwnd大小</strong>（如除以2），并执行拥塞避免。</p>
</li>
</ul>
<h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308171503072.png" alt="image-20210308171503072"></p>
<p>其中部分字段含义：</p>
<ul>
<li>序号（seq）。TCP 是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。<strong>序号字段值指的是本报文段所发送的数据的第一个字节的序号</strong>。</li>
<li>确认号（ack）。<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为 N ，则标识序号 1 ~ N-1 的字节都已正确收到。</li>
<li>确认 ACK （控制位） 。<strong>仅当ACK=1时确认号字段才有效</strong>。当ACK=0时， 确认号无效。TCP规定，<strong>在连接建立后所有传送的报文段都必须把ACK置1</strong>。</li>
<li>同步 SYN （控制位）。<strong>在连接建立时用来同步序号</strong>。<strong>当SYN=1而ACK=0时，表明这是一个连接请求报文段</strong>。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此， <strong>SYN置为1就表示这是一个连接请求或连接接受报文</strong>。</li>
<li>终止 FIN （控制位）。用来释放一个连接。<strong>当FIN=1时， 表明此报文段的发送方的数据已发送完毕，并要求释放运输连接</strong>。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>《计算机网络 第7版》中称为“三报文握手”。</p>
<p>图片来自《计算机网络 第7版》</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308162534931.png" alt="image-20210308162534931"></p>
<p> A 为客户端，B 为服务器端。</p>
<blockquote>
<p>ack 指确认号字段，ACK 是6个控制位之一。</p>
</blockquote>
<ul>
<li><strong>首先 B 处于 LISTEN（监听）状态</strong>，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，（同步字段）SYN=1，（ACK=0），<strong>选择一个初始的序号 x</strong>，即 <code>SYN=1, seq=x</code> 。</li>
<li>B 收到连接请求报文，<strong>如果同意建立连接，则向 A 发送连接确认报文</strong>，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。即 <code>SYN=1, ACK=1, seq=y, ack=x+1</code> 。</li>
<li><strong>A 收到 B 的连接确认报文后，还要向 B 发出确认</strong>，确认号为 y+1，序号为 x+1。即 <code>ACK=1, ack=y+1, seq=x+1</code> 。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><strong style="color:red">为什么需要最后一次握手（确认）？</strong> </p>
<p><strong>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</strong>。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求若最后还是到达了服务器，<strong>如果不进行三次握手</strong>，那么服务器就会打开两个连接。<strong>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，服务器接不到确认也就不会打开连接</strong>。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308164017342.png" alt="image-20210308164017342"></p>
<ul>
<li>A 发送连接释放报文，FIN=1，并停止发送数据。 <code>FIN=1, seq=u</code> 。<strong>A进入“终止等待状态1”</strong>。</li>
<li>B 收到之后发出确认：<code>ACK=1, ack=u+1, seq=v</code> 。<strong>此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</strong>，即从 A -》B 这个方向的连接释放了。<strong>此时 B 进入“关闭等待”状态</strong></li>
<li>A收到确认后，<strong>进入“终止等待状态2”。等待B的连接释放报文段</strong>。</li>
<li><strong>B 发出确认后会发送还没发送完的数据</strong>，当 B 已经没有要向 A 发送的数据时，<strong>发送连接释放报文，FIN=1</strong>。 <code>FIN=1, ACK=1, seq=w, ack=u+1</code> 。<strong>B 进入“最后确认”状态</strong>。</li>
<li>A 收到后发出确认： <code>ACK=1, seq=u+1, ack=w+1</code> ，<strong>进入 TIME-WAIT （时间等待）状态，此时连接还没有释放，A 会等待 2 MSL（Maximum Segment Lifetime，最大报文存活时间）后释放连接</strong>。</li>
<li><strong>B 收到 A 的确认后释放连接</strong>。</li>
</ul>
<p>客户端接收到服务器端的 FIN 报文后还需要等待一个时间计时器设置的时间 2MSL。<strong>这么做有两个理由</strong>：</p>
<ul>
<li><strong>确保最后一个确认报文能够到达</strong>。如果 B 没收到 A 发送来的确认报文，会超时重传连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生，这时 A 会重新发送确认报文，<strong>并将计时重新设置为 2 MSL</strong>。</li>
<li>等待一段时间是为了<strong>让本连接持续时间内所产生的所有报文都从网络中消失使得下一个新的连接不会出现旧的连接请求报文，如已失效的连接请求报文段</strong>。</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层负责<strong>为<font color="red">主机之间</font>提供通信服务</strong>。<strong>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送，即网络层的数据单元是分组或包</strong>。</p>
<p><strong>网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机</strong>。与对方计算机之间通过多台计算机或网络设备进行传输时，<strong>网络层所起的作用就是在众多的选项内选择一条传输路线</strong>。</p>
<p>网络层使用的主要协议是 IP 协议。</p>
<p>另外要注意的是，<strong>运输层并不负责将数据从一个设备传输到另一个设备</strong>，它只作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能由网络层负责。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>路由器在转发分组时，需要知道 IP 地址对应的具体设备，<strong>数据链路层专门用来标识网络中的设备</strong>，它主要为⽹络层提供链路级别传输的服务。</p>
<p>数据链路层常简称为链路层。在两个相邻结点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息</strong>（如同步信息、地址信息、差错控制等）。</p>
<p>在接收数据时，<strong>控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束</strong>。这样，<strong>数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层</strong>。</p>
<p><strong>控制信息还使接收端能够检测到所收到的帧中有无差错</strong>。如发现<strong>有差错</strong>，数据链路层就<strong>丢弃出了差错的帧</strong>，以免浪费网络资源。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>当数据准备要从设备发送到网络时，<strong>需要把数据包转换成电信号，让其可以在物理介质中传输</strong>，这⼀层就是物理层 ，它主要是为数据链路层提供⼆进制传输的服务。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html">运输层</a> </p>
<p>《计算机网络 第7版》</p>
<p>《小林coding-图解网络pdf》</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 13:00:34" itemprop="dateModified" datetime="2021-08-30T13:00:34+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-HTTP-概述"><a href="#1-HTTP-概述" class="headerlink" title="1. HTTP 概述"></a>1. HTTP 概述</h2><p><strong>HTTP，即 Hypertext Transfer Protocol ，超文本传输协议，是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong>。</p>
<p>HTTP 协议用于客户端和服务器端之间的通信，客户端、服务器端之间通过请求和响应的交换达成通信。</p>
<p><strong>HTTP 协议是基于 TCP 协议的</strong>。</p>
<h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><p>URI，即<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符，<strong>用来唯一标识某一互联网资源名称的字符串</strong>。</p>
<p>URL，<strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符，是 URI 是子集，它<strong>可以用来标识和定位一个互联网资源，也可以理解为它是用位置来唯一标识一个资源</strong>。</p>
<p><strong>HTTP 通过 URL 来标识一个资源</strong>。</p>
<p>URL 的格式：（来自《图解HTTP》）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210426201533829.png" alt="image-20210426201533829"></p>
<p>其中，登录信息和片段标识符可选。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21950864/answer/154309494">HTTP 协议中 URI 和 URL 有什么区别？-知乎</a> </li>
</ul>
<h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p><strong>HTTP 是一种<font color="red">无状态协议</font>，HTTP 自身不对通信状态进行保存，也就是说<font color="red">协议对于发送过的请求或响应都不做持久化处理，无法根据之前的状态进行本次的请求处理</font></strong>。这是为了更快地处理大量事务，确保协议的可伸缩性。</p>
<h3 id="HTTP-1-1-特性"><a href="#HTTP-1-1-特性" class="headerlink" title="HTTP(1.1) 特性"></a>HTTP(1.1) 特性</h3><p>HTTP 最凸出的<strong>优点是「简单、灵活和易于扩展、应用广泛和跨平台」</strong>。</p>
<p><strong>1.简单</strong> </p>
<p>HTTP 报文的格式简单，易于理解，学习和使用门槛低。且 HTTP 是无状态的，所以不用使用额外的信息来记录状态。</p>
<p><strong>2.灵活和易于扩展</strong> </p>
<p>HTTP 协议的请求方法、状态码、首部字段等的<strong>组成和长度都没有固定要求，开发人员可以进行自定义和扩充</strong>。</p>
<p><strong>3.应用广泛和跨平台</strong> </p>
<p>PC 端、移动端的各类软件、APP 都广泛应用 HTTP，HTTP 协议具有天然的跨平台性。</p>
<p>HTTP 的<strong>缺点</strong>也很明显，就是<strong>无状态和不安全</strong>：</p>
<ul>
<li>无状态的特性让 HTTP 更简单的同时，也存在缺点。对于一些需要记录状态的场景，比如登录，购物车等，需要用其他方法来解决，如 Cookie、Session。这会带来额外的开销。</li>
<li>HTTP/1.1 是明文传输的，这可以为调试带来便利性，但却是毫无安全性的：<ul>
<li>对于一些账号<strong>密码</strong>，若是用明文传输，很容易就<strong>被窃取</strong>；</li>
<li>且 HTTP/1.1 不验证通信方的身份，可能遭遇<strong>伪装</strong>；</li>
<li>无法保证报文的完整性，可能被<strong>篡改</strong>。</li>
</ul>
</li>
</ul>
<p>另外，HTTP/1.1 <strong>允许同时创建多个 TCP 连接</strong>实现并发和缩短延迟。</p>
<h2 id="2-代理、网关、隧道"><a href="#2-代理、网关、隧道" class="headerlink" title="2. 代理、网关、隧道"></a>2. 代理、网关、隧道</h2><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>代理是一种有转发功能的应用程序，它扮演了<strong>位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端</strong>。</p>
<p>代理服务器不会改变请求的 URI ，它会直接把请求发送给源服务器。在 HTTP 通信过程中，可级联多台代理服务器，每经过一台代理服务器，都需要通过 Via 首部字段记录。</p>
<p>代理服务器的作用：</p>
<ul>
<li>缓存。</li>
<li>访问控制等。</li>
</ul>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作机制跟代理服务器类似，是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。</p>
<p><strong>网关可以将 HTTP 请求转换为其他协议的通信</strong>。可以在客户端与网关之间的通信线路上加密以确保连接的安全。</p>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行<strong>安全的通信</strong>。</p>
<h2 id="3-HTTP-报文"><a href="#3-HTTP-报文" class="headerlink" title="3. HTTP 报文"></a>3. HTTP 报文</h2><p>HTTP 报文分为<strong>请求报文和响应报文</strong>。它们的结构如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210427003605931.png" alt="image-20210427003605931" style="zoom:80%;" />

<ul>
<li>请求报文和响应报文的起始行不同。</li>
<li><strong>首部字段有 4 种类型：请求首部字段、响应首部字段、通用首部字段、实体首部字段</strong>。</li>
<li><strong>报文主体可以为空</strong>。</li>
</ul>
<h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210426235929111.png" alt="image-20210426235929111"></p>
<p>其中，<strong>请求行的结构是</strong>：<code>请求方法+空格+URL+空格+HTTP版本</code>。</p>
<p>一个报文示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.example.com/?param1=1&amp;param2=2 HTTP/1.1</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 xxx</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210427000221955.png" alt="image-20210427000221955"></p>
<p>其中，状态行的结构是：<code>HTTP版本+空格+状态码+状态码描述</code>。</p>
<p>一个响应报文示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Age: 529651</span><br><span class="line">Cache-Control: max-age=604800</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 648</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class="line">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line">Keep-Alive: timeout=4</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc/16DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class="line">	// 省略... </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h2 id="4-HTTP-方法"><a href="#4-HTTP-方法" class="headerlink" title="4. HTTP 方法"></a>4. HTTP 方法</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>获取资源。</p>
<p>GET 方法的请求若带有参数，则是以 <code>@k1=v1&amp;k2=v2...</code> 的方式出现在 URL 中。如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span> /test/demo_form.asp?name<span class="number">1</span>=value<span class="number">1</span>&amp;name<span class="number">2</span>=value<span class="number">2</span> HTTP/<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>传输实体的主体。</p>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
<p>POST 请求的参数是在实体主体中。如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test/demo_form.asp</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br><span class="line"></span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<p>更多 POST 和 GET 的区别：<a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E5%8F%82%E6%95%B0">POST 和 GET 比较</a> </p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p><strong>上传文件</strong>，要求在请求报文的主体中包含文件内容，然后保存到请求 URL 指定的位置。</p>
<blockquote>
<p>也可以理解为修改文件，但修改是完全替代原文件的。</p>
</blockquote>
<p>HTTP/1.1 的 PUT 方法不带验证机制，任何人都可以上传文件，存在<strong>安全性问题</strong>，所以一般不用该方法。</p>
<p>若是 Web 应用采用 REST（REpresentational State Transfer，表征状态转移） 架构，则可能开放 PUT 方法。</p>
<h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>对资源进行<strong>部分修改</strong>。</p>
<p>PUT 也可以用于修改资源，但只能完全替代原始资源，PATCH 允许部分修改。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>获得报文首部。</p>
<p>HEAD 方法和 GET 方法一样，只是<strong>不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等</strong>。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除文件。DELETE 方法<strong>按请求 URI 删除指定的资源</strong>。</p>
<p>HTTP/1.1 的 DELETE 一样<strong>不带验证机制</strong>，一般不使用。当配合 Web 应用程序的验证机制，或遵守 REST 标准时有可能开放。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>询问支持的方法。用来询问 <strong>URI 指定的资源支持的方法</strong>。</p>
<p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p><strong>追踪路径</strong>。服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 <strong>Max-Forwards 首部字段中填入数值</strong>，每经过一个服务器就会减 1，当数值<strong>为 0 时就停止传输</strong>，最后接收到请求的服务器端则返回状态码 200 OK 的响应。</p>
<p>通常不会使用 TRACE，并且它<strong>容易受到 XST 攻击</strong>（Cross-Site Tracing，跨站追踪）。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p><strong>要求用隧道协议连接代理服务器</strong>。CONNECT 方法<strong>要求在与代理服务器通信时建立隧道</strong>，实现<strong>用隧道协议进行 TCP 通信</strong>。</p>
<p>主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<p>CONNECT 方法的格式：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONEECT 代理服务器名:port HTTP版本</span><br></pre></td></tr></table></figure>

<p>一个示例：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210427105409153.png" alt="image-20210427105409153"></p>
<h2 id="5-HTTP-状态码"><a href="#5-HTTP-状态码" class="headerlink" title="5. HTTP 状态码"></a>5. HTTP 状态码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>状态码告知从服务器端返回的请求结果。借助状态码，客户端可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">类别</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">Informational（信息性状态码）</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">Success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">Client Error（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">Server Error（服务器错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<p>以下是一些常见状态码。</p>
<h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul>
<li><strong>200 OK</strong>：最常见的状态码，<strong>表示资源正常处理完成</strong>。</li>
<li><strong>204 No Content</strong>：请求处理成功，但<strong>没有资源可返回，即返回的响应报文不包含实体的主体部分</strong>。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong>：表示客户端使用 Content-Range 进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul>
<li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p>
<blockquote>
<p>永久性重定向表示原 URL 不应再被使用，而应该优先选用新的 URL。</p>
</blockquote>
</li>
<li><p><strong>302 Found</strong> ：临时性重定向</p>
<blockquote>
<p>有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问。在这种情况下可以使用临时重定向。</p>
</blockquote>
</li>
<li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
<blockquote>
<p>虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p>
</blockquote>
</li>
<li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
<blockquote>
<p><strong>304 虽然被划分在 3XX 类别中，但是和重定向没有关系</strong>。</p>
</blockquote>
</li>
<li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
</ul>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul>
<li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p>
</li>
<li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
<blockquote>
<p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。</p>
</blockquote>
</li>
<li><p><strong>403 Forbidden</strong> ：请求被拒绝。如没有访问权限等情况。</p>
</li>
<li><p><strong>404 Not Found</strong>：资源未找到。</p>
</li>
</ul>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>5XX 的响应结果表明服务器本身发生错误。</p>
<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。如抛出异常。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<hr>
<blockquote>
<p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。 比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种 情况也经常遇到。</p>
</blockquote>
<h2 id="6-HTTP-首部字段"><a href="#6-HTTP-首部字段" class="headerlink" title="6. HTTP 首部字段"></a>6. HTTP 首部字段</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>HTTP 首部字段可以<strong>为客户端和服务器的通信提供额外的重要信息</strong>。</p>
<p>其结构为：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名：字段值</span><br></pre></td></tr></table></figure>

<p>字段值可以一个或多个，且可以是 <code>key=value</code> 的形式。</p>
<p>示例：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Keep-Alive: timeout&#x3D;15, max&#x3D;100</span><br></pre></td></tr></table></figure>

<p>HTTP 首部字段分为以下 4 种类型。 </p>
<ul>
<li><strong>通用首部字段</strong>（General Header Fields）：请求报文和响应报文两方都会使用的首部。 </li>
<li><strong>请求首部字段</strong>（Request Header Fields）：请求报文中使用的首部字段。</li>
<li><strong>响应首部字段</strong>（Response Header Fields）：响应报文中使用的首部字段。</li>
<li><strong>实体首部字段</strong>（Entity Header Fields）：<strong>针对</strong>请求报文和响应报文的<strong>实体部分使用的首部</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E5%9B%9B%E3%80%81http-%E9%A6%96%E9%83%A8">HTTP首部字段总览</a> </p>
<p>一些常见字段：</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Cache-Control</strong></td>
<td align="center">控制缓存的行为</td>
</tr>
<tr>
<td align="center"><strong>Connection</strong></td>
<td align="center">控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td align="center"><strong>Date</strong></td>
<td align="center">创建报文的日期时间</td>
</tr>
<tr>
<td align="center"><strong>Via</strong></td>
<td align="center">代理服务器的相关信息</td>
</tr>
</tbody></table>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><ul>
<li><p><strong>Accept</strong>：通知服务器用户代理<strong>能够处理的媒体类型及媒体类型的相对优先级</strong>。可使用 type/subtype 这种形式，一次指定多种媒体类型。优先级使用 <code>q=N</code> 表示，N 是 0-1 的小数。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml;q=<span class="number">0</span>.<span class="number">5</span>,application/xml;q=<span class="number">0</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Accept-Charset</strong>：通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>-Charset: iso-<span class="number">8859</span>-<span class="number">5</span>, unicode-<span class="number">1</span>-<span class="number">1</span>;q=<span class="number">0</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Accept-Encoding</strong>：告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。</p>
</li>
<li><p><strong>Accept-Language</strong>：告知服务器用户代理能够处理的自然语言集（指中文或英文等）。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>-Language: zh-cn,zh;q=<span class="number">0</span>.<span class="number">7</span>,en-us,en;q=<span class="number">0</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Referer</strong>：告知服务器发起该请求的 URI 。即可以<strong>知道请求是从哪个 Web 页面发起的</strong>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Referer:</span> <span class="attr">http:</span><span class="comment">//www.hackr.jp/index.htm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Range</strong>：只获取指定资源的指定部分。如下表示请求获取从第 5001 字节至第 10000 字节的资源：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=<span class="number">5001</span><span class="number">-10000</span></span><br></pre></td></tr></table></figure>

<p>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 <code>206 Partial Content</code> 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及<strong>全部资源</strong>。</p>
</li>
<li><p><strong>Max-Forwards</strong>：通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段<strong>指定可经过的服务器最大数目</strong>。每经过一个服务器值减 1 。为 0 时不再进行转发直接返回响应。</p>
</li>
<li><p><strong>Host</strong>：请求资源所在服务器。</p>
</li>
</ul>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><ul>
<li><p><strong>Accept-Ranges</strong>：服务器告知客户端自己能否处理范围请求。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes <span class="regexp">//</span> 可以处理</span><br><span class="line">Accept-Ranges: none <span class="regexp">//</span> 不可以处理</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ETag</strong>：唯一标识一个资源的字符串。</p>
<p>仅凭 URI 指定缓存的资源不具备唯一性，比如同一个 URI 有中文和英文两个版本。资源被缓存时，就会被分配唯一性标识，以区分资源的不同版本。</p>
</li>
<li><p><strong>Location</strong>：令客户端重定向至指定 URI 。基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI 。</p>
</li>
<li><p><strong>Server</strong>：告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/<span class="number">2</span>.<span class="number">2</span>.<span class="number">17</span> (Unix)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Vary</strong>：该字段可对缓存进行控制，由源服务器发送给缓存服务器。</p>
<p>代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，比如 <code>Vary: Accept-Language</code>，<strong>若请求指定的 Accept-Language 与缓存一致，则返回该缓存</strong>；否则需要从源服务器获取资源。</p>
</li>
</ul>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><ul>
<li><p><strong>Allow</strong>：资源可支持的 HTTP 方法。</p>
</li>
<li><p><strong>Content-Encoding</strong>：实体主体适用的编码方式。</p>
</li>
<li><p><strong>Content-Language</strong>：实体主体的自然语言。</p>
</li>
<li><p><strong>Content-Length</strong>：实体主体的大小</p>
</li>
<li><p><strong>Content-Location</strong>：给出与报文主体部分相对应的 URI 。如访问 <code>http://www.hackr.jp/</code> 返回的对象却是 <code>http://www.hackr.jp/index-ja.html</code> 等情况。</p>
</li>
<li><p><strong>Content-Range</strong>：返回响应时使用的首部字段，表示当前发送部分及整个实体大小。</p>
<p>如下表示资源总大小是 10000 字节，当前发送的是第 5001-10000 个字节。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes <span class="number">5001</span><span class="number">-10000</span>/<span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Content-Type</strong>：实体主体的媒体类型。</p>
</li>
<li><p><strong>Expires</strong>：告知资源失效时间。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">04</span> Jul <span class="number">2012</span> <span class="number">08</span>:<span class="number">26</span>:<span class="number">05</span> GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Last-Modified</strong>：资源的最后修改日期时间。</p>
</li>
</ul>
<h2 id="7-HTTP-的应用"><a href="#7-HTTP-的应用" class="headerlink" title="7. HTTP 的应用"></a>7. HTTP 的应用</h2><p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E4%BA%94%E3%80%81%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8">链接</a> </p>
<h2 id="8-HTTP-和-HTTPS"><a href="#8-HTTP-和-HTTPS" class="headerlink" title="8. HTTP 和 HTTPS"></a>8. HTTP 和 HTTPS</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>HTTP/1.1 及之前是采用明文传输的，<strong>存在信息被窃取、篡改跟伪造的风险</strong>。</p>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议。如图：（图片来自小林coding）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210428105419529.png" alt="image-20210428105419529" style="zoom:80%;" />

<blockquote>
<p>SSL，Secure Socket Layer，安全套接层协议</p>
<p>TLS，Transport Layer Secure，传输层安全协议</p>
</blockquote>
<p>SSL/TLS 协议提供了以下机制：</p>
<ul>
<li><strong>信息加密</strong>：通过混合加密的方式（<strong>对称加密</strong>和<strong>非对称加密</strong>结合）对信息加密。</li>
<li><strong>校验机制</strong>：防止内容被篡改而无法发现。</li>
<li><strong>身份证书</strong>：证明自己的身份，<strong>防止身份伪造</strong>。</li>
</ul>
<p>这些机制解决了 HTTP/1.0 的安全问题。</p>
<h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ol>
<li>HTTP 是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 <strong>HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输</strong>。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li><strong>HTTPS 协议需要向 CA（证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。是需要花钱的。</li>
</ol>
<h2 id="9-HTTP-的演变"><a href="#9-HTTP-的演变" class="headerlink" title="9. HTTP 的演变"></a>9. HTTP 的演变</h2><h3 id="HTTP-1-0-gt-gt-HTTP-1-1"><a href="#HTTP-1-0-gt-gt-HTTP-1-1" class="headerlink" title="HTTP/1.0 &gt;&gt; HTTP/1.1"></a>HTTP/1.0 &gt;&gt; HTTP/1.1</h3><p>HTTP 初始版本是短连接的，每进行一次通信（一次请求+一次响应）就断开连接。</p>
<p>HTTP/1.1 使用了长连接和管道传输进行优化。</p>
<p>但 HTTP/1.1 还是有<strong>性能瓶颈</strong>：</p>
<ul>
<li><p>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</p>
</li>
<li><p>发送冗长的首部。</p>
</li>
<li><p><strong>对于管道传输，客户端可以不用等待响应连续发出多个请求，但服务器需要按请求的顺序返回响应，所以如果前面的请求阻塞住了，那么服务器就不会响应后面的请求，这就是队头阻塞</strong>；</p>
<p>如果要实现多个请求并发，只能通过创建多个 TCP 连接的方式。这是以<strong>牺牲性能为代价的，且导致 TCP 连接的利用率低下</strong>。</p>
</li>
<li><p>没有请求优先级控制；</p>
</li>
<li><p><strong>请求只能从客户端开始，服务器只能被动响应</strong>。</p>
</li>
</ul>
<h3 id="HTTP-1-1-gt-gt-HTTP-2"><a href="#HTTP-1-1-gt-gt-HTTP-2" class="headerlink" title="HTTP/1.1 &gt;&gt; HTTP/2"></a>HTTP/1.1 &gt;&gt; HTTP/2</h3><p><strong>HTTP/2 协议是基于 HTTPS 的</strong>，所以 HTTP/2 的安全性也是有保障的。</p>
<p>HTTP/2 相比 HTTP/1.1 性能上的改进：</p>
<ol>
<li><p><strong>头部压缩</strong>。如果同时发出的多个请求的头部字段是一样的或是相似的，那么，协议会<strong>消除重复的字段</strong>。</p>
<blockquote>
<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>
</blockquote>
</li>
<li><p>HTTP/2 的报文<strong>采用二进制的形式</strong>。头信息和数据体都是二进制，并且<strong>统称为帧（frame）：头信息帧和数据帧</strong>。如图：（图片来自小林coding）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210428112049440.png" alt="image-20210428112049440" style="zoom:80%;" />

<p><strong>使用二进制对计算机友好</strong>，计算机收到报文后可以直接处理，无需进行解析。</p>
<p>帧是最小的通信单位，一个请求或响应的所有帧称为一个<strong>数据流</strong>。每个帧需要做标记，指明它属于哪个数据流。</p>
</li>
<li><p>在通信过程中，<strong>只会有一个 TCP 连接存在，在这个连接上并发处理多个 HTTP 请求或响应。每个请求或响应对应一个数据流（Stream），来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装</strong>。</p>
<p>这种方式可以不按顺序处理请求，<strong>避免了队头阻塞的情况</strong>。</p>
<p>另外，<strong>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</strong>。</p>
</li>
<li><p><strong>服务器推送</strong>。HTTP/2 在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
</li>
</ol>
<p>HTTP/2 的缺点：</p>
<ul>
<li>HTTP/2 中，多个 HTTP 请求/响应是基于一个 TCP 连接的，所以<strong>当有某个包丢失时，会触发 TCP 的重传机制，这样之后的 TCP 报文段都会被阻塞住，即未处理完的 HTTP 请求/响应阻塞至丢失的包重传完成</strong>。</li>
<li>客户端和服务端之间<strong>建立连接需要 6 次交互</strong>：TCP 3 次握手 + TLS/1.3 的 3 次握手。</li>
</ul>
<h3 id="HTTP-2-gt-gt-HTTP-3"><a href="#HTTP-2-gt-gt-HTTP-3" class="headerlink" title="HTTP/2 &gt;&gt; HTTP/3"></a>HTTP/2 &gt;&gt; HTTP/3</h3><p>HTTP/2 多个请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。这是基于 TCP 的问题，<strong>HTTP/3 把 HTTP 下层 TCP 协议改成了基于 UDP 的 QUIC 协议</strong>，解决了 HTTP/2 丢包阻塞的问题。</p>
<p>HTTP/1 &gt;&gt; HTTP/3 的演变：（图片来自小林coding）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210428150235411.png" alt="image-20210428150235411" style="zoom:80%;" />\</p>
<p>UDP 是不可靠传输的，没有 TCP 的重传等机制，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输：</p>
<ul>
<li>当某个流发生丢包时，<strong>只会阻塞这个流，其他流不会受到影响</strong>。</li>
<li>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li>
<li>QUIC 把 HTTP/2 的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html">CS-Note - CyC2018</a> </li>
<li>《图解HTTP》</li>
<li>《小林coding - 图解网络pdf》</li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">30 张图解 HTTP 常见的面试题 - 小林coding</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:59:54" itemprop="dateModified" datetime="2021-08-30T12:59:54+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>定义：<strong>在当前进程中，通过单例模式创建的类有且只有一个实例</strong>。</p>
<p>单例有如下几个特点：</p>
<ul>
<li>在Java应用中，单例模式<strong>需要保证在一个JVM中，该对象只有一个实例存在</strong>。</li>
<li><strong>构造器必须是私有的</strong>，外部类无法通过调用构造器方法创建该实例。</li>
<li><strong>没有公开的set方法</strong>，外部类无法调用set方法创建该实例。</li>
<li>提供一个公开的get方法获取唯一的这个实例。</li>
</ul>
<p>单例模式的好处：</p>
<ul>
<li>某些类创建比较频繁，<strong>对于一些大型的对象，节省很大的系统开销</strong>。</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li>
<li>系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个，会造成系统混乱。</li>
<li>避免了对资源的重复占用</li>
</ul>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在<strong>程序启动或单例模式类被首次主动使用的时候</strong>，单例模式实例被创建。<strong>总之，饿汉式体现的是想提前把对象创建好</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式没有线程安全问题，instance是在Singleton类初始化时创建的，JVM可以保证线程安全。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式单例在第一次调用getInstance才创建实例。</p>
<h3 id="线程不安全实现"><a href="#线程不安全实现" class="headerlink" title="线程不安全实现"></a>线程不安全实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Singleton2.getInstance());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行多次，可以看到获取对象不是同一个。</p>
<p><strong>应用场景</strong>：如果这个数据是经常访问的热点数据，那我就可以在系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了；反之，数据使用频率较低，则使用懒汉式，避免资源浪费。</p>
<h3 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h3><p>getInstance加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样能保证线程安全，但是<strong>效率过低，实例被创建后调用getInstance依然需要加锁</strong>。</p>
<p>通过双检锁（double-checked）做两次判断优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意INSTANCE需要加上<code>volatile</code>关键字，避免指令重排序问题</strong>。<code>INSTANCE = new Singleton();</code>并不是原子操作，JVM可能会先执行赋值操作再执行初始化操作，</p>
<p>没加volatile时线程不安全的情况：</p>
<ul>
<li>A、B同时进入第一个if。</li>
<li>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</li>
<li>由于JVM内部的优化机制，JVM可能会<strong style="color:red">先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块</strong>。</li>
<li>随后B进入synchronized块，由于instance此时不是null，<strong>因此它马上离开了synchronized块并将结果返回给调用该方法的程序</strong>。</li>
<li>此时若B线程马上使用Singleton实例，<strong>却发现它没有被初始化，于是错误发生了</strong>。</li>
</ul>
<p>缺点：<strong>由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高</strong>。</p>
<p>可以使用静态内部类实现。</p>
<h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>使用内部类来维护单例的实现，<strong>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的</strong>。</p>
<h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举来实现单实例控制会更加<strong>简洁，而且JVM从根本上提供保障，绝对防止多次实例化</strong>，是更简洁、高效、安全的实现单例的方式。</p>
<h2 id="为什么不用静态方法而用单例模式？"><a href="#为什么不用静态方法而用单例模式？" class="headerlink" title="为什么不用静态方法而用单例模式？"></a>为什么不用静态方法而用单例模式？</h2><p>（来自参考连接）</p>
<p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，<strong>面向对象的代码提供一个更好的编程思想</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ">设计模式系列 - 单例模式</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">七大基本原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:59:56" itemprop="dateModified" datetime="2021-08-30T12:59:56+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式的七大原则如下：</p>
<ul>
<li>单一职责原则 (Single Responsibility Principle)</li>
<li>接口隔离原则 (Interface Segregation Principle)</li>
<li>开放-关闭原则 (Open-Closed Principle)</li>
<li>里氏替换原则 (Liskov Substitution Principle)</li>
<li>依赖倒转原则 (Dependence Inversion Principle)</li>
<li>迪米特法则（Law Of Demeter）</li>
<li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li>
</ul>
<h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>通俗地说，单一职责原则即<strong>一个类只负责一项职责（不是只有一个方法）</strong>。</p>
<p>假设某个类 P 负责两个不同的职责：职责 P1 和 职责 P2，那么当职责 P1 需求发生改变而需要修改类 P，有可能会导致原来运行正常的职责 P2 功能发生故障。</p>
<p>在实际编程中比较难严格的遵守该原则，可以作一些折中处理，比如若是一个类中方法个数比较少，可以在方法级别上遵守该原则（此时在类级别上可能不遵守）。<strong>只有逻辑足够简单，才可以在代码级别上违背单一职责原则</strong>。</p>
<p>单一职责原则的作用和细节：</p>
<ul>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>通常情况下，应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ul>
<h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>接口隔离原则指：<strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</strong>：</p>
<p>被依赖的类实现一个接口，就需要实现接口的所有方法，但这个类在被使用时可能只用到其中部分方法。也就是只要接口中出现的方法，不管依赖于它的类是否需要该方法，实现类都必须去实现这些方法，这就不符合接口隔离原则。可以对接口进行拆分，让实现类只实现需要的接口。</p>
<p>示例（见来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89%EF%BC%9A">https://zhuanlan.zhihu.com/p/24614363）：</a></p>
<img src="https://pic4.zhimg.com/80/v2-ec9b282b367e9c148a7963b5b23c60e7_720w.png" style="zoom:80%;" />

<p>类 A 依赖于 接口 I 中的方法 1，2，3 ，类 B 是对类 A 的具体实现。类 C 依赖接口 I 中的方法 1，4，5，类 D 是对类 C 的具体实现。对于类B和类D来说，<strong>虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。</strong> </p>
<p>用代码表示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line">	 <span class="comment">// 类 B 只需要实现方法 1，2, 3，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line">	<span class="comment">// 类 D 只需要实现方法 1，4，5，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        A a = <span class="keyword">new</span> A();  </span><br><span class="line">        a.depend1(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());  </span><br><span class="line">          </span><br><span class="line">        C c = <span class="keyword">new</span> C();  </span><br><span class="line">        c.depend1(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend2(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend3(<span class="keyword">new</span> D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以对接口根据下图进行拆分：</p>
<img src="https://pic3.zhimg.com/80/v2-7611098e41bcfbf5113d978b47fc8466_720w.png" style="zoom:80%;" />

<p>代码可修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><strong>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</strong>。</li>
<li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
</ol>
<h2 id="依赖倒转原则（DIP）"><a href="#依赖倒转原则（DIP）" class="headerlink" title="依赖倒转原则（DIP）"></a>依赖倒转原则（DIP）</h2><p>定义：<strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象</strong>。进一步说，<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。<strong>依赖倒转原则的核心思想就是面向接口编程</strong>。</p>
<p>依赖倒转原则是基于这样的设计理念：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给实现类去完成。</p>
<p>示例：（来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89">https://zhuanlan.zhihu.com/p/24614363）</a></p>
<p>一个场景：母亲给孩子讲故事，只要给她一本书，她就可照着书给孩子讲故事了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Book book)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(book.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>假如有一天，给的是一份报纸，而不是一本书，让这个母亲讲下报纸上的故事，报纸的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p><strong>显然这个母亲完成不了这个任务。只有将Mother类中的Book换成Newspaper才能完成</strong>。但若是以后换成杂志等其他读物，又得进行修改。原因是 Mother 和 Book之间的耦合度太高了。<strong>可以引入一个抽象接口 IReader表示读物，让书和报纸去实现这个接口，那么无论提供什么样的读物，该母亲都能读</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(IReader reader)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(reader.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个例子中，Mother类代表高层模块，读物相关的类则代表低层模块，在修改示例之前，是高层依赖于低层代码，Mother类要按着Book类来；修改后则符合依赖倒转原则，低层的读物依着高层的Mother来。</p>
<p><strong>实际情况中，代表高层模块的 Mother 类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒转原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险</strong>。</p>
<h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p><strong>面向对象中继承性的问题</strong>：有一功能 P1, 由类 A 完成，现需要将功能 P1 进行扩展，扩展后的功能为 P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则<strong>子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障</strong>。</p>
<p>里氏替换原则：</p>
<ul>
<li><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li>
<li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法</strong>。</li>
<li><strong>子类中尽量不要重写父类的方法</strong>。</li>
</ul>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而<strong>里氏替换原则就是表达了这一层含义</strong>。</p>
<p>根据该原则，对于上述的继承性问题：当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能 P2，尽量不要修改父类方法预期的行为。</p>
<h2 id="开放-关闭原则（OCP）"><a href="#开放-关闭原则（OCP）" class="headerlink" title="开放-关闭原则（OCP）"></a>开放-关闭原则（OCP）</h2><p>**开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改。(Open for extension, close for modification，对扩展开放，对修改关闭)**。</p>
<p>一个软件满足 OCP 原则后的两项优点：</p>
<ol>
<li><strong>能够扩展已存在的系统</strong>，能够提供新的功能满足新的需求，因此该软件有着很强的适应性和灵活性。</li>
<li>已存在的模块，特别是那些重要的抽象模块，不需要被修改，那么该软件就有很强的稳定性和持久性。</li>
</ol>
<p>示例：</p>
<p>有个生产电脑的公司，根据输入的类型，生产出不同的电脑，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Computer c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;macbook&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Macbook();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;surface&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Surface();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的代码违背了开放 - 关闭原则，<strong>如果需要添加新的电脑产品，需要修改 produceComputer 原本已有的方法</strong>，正确的方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Macbook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MSFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Surface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的方式应该是将 Factory 抽象成接口，让具体的工厂(如苹果工厂，微软工厂)去实现它，生产它们公司相应的产品，这样写有利于扩展，如果这是需要新增加戴尔工厂生产戴尔电脑，我们仅仅需要创建新的电脑类和新的工厂类，而不需要去修改已经写好的代码。</p>
<p>总结：</p>
<ol>
<li><strong>OCP 可以具有良好的可扩展性，可维护性</strong>。</li>
<li><strong>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它</strong>。</li>
</ol>
<h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><p>迪米特法则又称为<strong>最少知道原则</strong>，它表示<strong>一个对象应该对其它对象保持最少的了解</strong>。**<font color="red">通俗来说就是，只与直接的朋友通信</font>**。</p>
<p><strong>什么是直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，<strong>称出现在成员变量、方法参数、方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类则不是直接的朋友</strong>。根据迪米特法则，**<font color="red">陌生的类最好不要作为局部变量的形式出现在类的内部</font>**。</p>
<p><strong>对于被依赖的类来说，无论逻辑多么复杂，都尽量的将逻辑封装在类的内部，对外提供 public 方法，不对泄漏任何信息</strong>。</p>
<p>示例：</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个 SchoolManager 对象 </span></span><br><span class="line">    SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager(); </span><br><span class="line">    <span class="comment">//输出学院员工id和学校员工id</span></span><br><span class="line">    schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学校员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工管理类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回学院的所有员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;CollegeEmployee&gt; list = newArrayList&lt;CollegeEmployee&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="comment">//这里我们增加了 10 个员工到 </span></span><br><span class="line">            list CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回所有学校员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;Employee&gt; list = newArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">            list Employee emp = <span class="keyword">new</span> Employee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出学校和学院员工id</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//获取到学院员工 </span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以看到SchoolManager的printAllEmployee方法中，<strong>CollegeEmployee并不是SchoolManager的直接朋友，不符合迪米特法则</strong>。</p>
<p>可以将打印CollegeEmployee部分的代码封装进CollegeManager中：</p>
<p>CollegeManager中添加新的public方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">    List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而可以在SchoolManager中通过CollegeManager调用该方法来打印所有学院员工id，SchoolManager.printAllEmployee方法改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">	sub.printEmployee();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">    List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="组合-聚合复用原则（CRP）"><a href="#组合-聚合复用原则（CRP）" class="headerlink" title="组合/聚合复用原则（CRP）"></a>组合/聚合复用原则（CRP）</h2><p>组合/聚合复用原则指的是<strong>在实际开发设计中，尽量使用组合/聚合，不要使用类继承</strong>。</p>
<p>在面向对象的设计中，<strong>如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类，如果基类的实现发生了改变，则子类的实现也不得不改变</strong>。</p>
<ul>
<li><p>总体说来，组合或者聚合好过于继承。</p>
</li>
<li><p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363">https://zhuanlan.zhihu.com/p/24614363</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bxxiao</p>
  <div class="site-description" itemprop="description">nothing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bxxiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
