<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bxxiao</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-01T04:09:03.344Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>bxxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://example.com/2021/08/30/MySQL/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2021/08/30/MySQL/MySQL%E7%B4%A2%E5%BC%95/</id>
    <published>2021-08-30T05:05:17.441Z</published>
    <updated>2021-09-01T04:09:03.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p><strong>索引是存储引擎用于快速找到记录的一种数据结构</strong>。其作用相当于是一个 “目录”，在这个目录中可以快速找到想要的内容。</p><a id="more"></a><p>来自《高性能MySQL》：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210715154047829.png" alt="image-20210715154047829"></p><p>MYSQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p><p><strong>索引可以包含一个或多个列，当索引对多个值进行排序时按照的是定义索引列时的顺序</strong>。</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B - Tree 索引"></a>B - Tree 索引</h3><p>不同存储引擎的 B - Tree 索引的底层数据结构可能不同，<strong>对于 InnoDB，其使用的是 B+ 树数据结构</strong>。</p><p><strong>使用 B+ 树查找数据可以避免全表扫描，大幅提升效率</strong>。其中，<strong>B+ 树的叶子结点指向的是被索引的数据（即表记录），这些叶子结点是按顺序窜起来的链表，所以 B+ 树索引同样适合做范围查找</strong>。</p><h4 id="如何命中索引"><a href="#如何命中索引" class="headerlink" title="如何命中索引"></a>如何命中索引</h4><p><strong>B - Tree 索引有以下类型的有效匹配</strong>：</p><ul><li><p><strong>全键值匹配</strong>：指和索引中的所有列进行匹配。</p></li><li><p><strong>匹配最左前缀（最左匹配原则）：若不是按照索引的最左列开始依次匹配，则不能触发索引，且如果某个列的范围查找可以触发索引，则之后的列都不能使用索引优化查询，且不能跳过索引中的列</strong>。</p><p>更通俗点的说法：<strong>查询条件中出现的列必须依次跟索引中的列对应，且当遇到非等值比较，则后续列将不能进行匹配</strong>。</p><blockquote><p>如有索引 <code>(a,b,c,d)</code>，查询条件 <code>a=1 and b=2 and c&gt;3 and d=4</code>，则会在每个节点依次命中 a、b、c，无法命中 d 。<strong>即在查找时，只跟索引的 a、b、c 值进行比较</strong>。</p></blockquote><p><strong style="color:red">但对于 <code>=,in</code> ，其实是不需要考虑字段顺序的，mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列</strong>。</p><p>例子：如有索引 <code>(a,b,c,d)</code>，查询条件 <code>c&gt;3 and b=2 and a=1 and d&lt;4</code>与 <code>a=1 and c&gt;3 and b=2 and d&lt;4</code>等顺序都是可以的，MySQL会自动优化为 <code>a=1 and b=2 and c&gt;3 and d&lt;4</code>，依次命中a、b、c。</p></li><li><p><strong>匹配列前缀</strong>：只匹配某一列值的开头一小部分，如查找 name 字段以 “ J ” 开头的记录。<strong>MYSQL 能在索引中做最左前缀匹配的 LIKE 比较，即类似 <code>Xyz%</code> 的形式</strong>，但是如果是通配符开头的 LIKE 查询，如 <code>%xyt%</code> ，存储引擎就无法儆比较匹配。这种情况下， MYSQL 只能提取数据行的值而不是索引值来做比较。</p></li><li><p><strong>索引列不能是表达式的一部分或函数的参数</strong>，否则索引不能生效。</p></li></ul><p><strong>B+ 树中的结点还可以用于 ORDER BY 排序，若是一个 ORDER BY 子句后的列字段可以对应一个索引，则这个索引也可以用于排序</strong>。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引基于哈希表实现，<strong style="color:red">只有精确匹配所有索引列的查询才有效（需要全键值匹配且只能等值比较）</strong>。<strong>哈希索引会根据所有索引列的值计算出哈希值，并直接定位到记录</strong>。</p><p>哈希索引优点明显，就是查找速度非常快。</p><p>缺点同样明显，哈希表不能保证有序性：</p><ul><li><strong>索引哈希索引不适用于范围查找和排序</strong>。</li><li><strong>不支持部分索引列匹配查找</strong>。</li><li><strong>只支持等值比较匹配</strong>。</li><li>若是哈希碰撞很多，则维护成本较高。</li></ul><p>另外，Innodb 引擎有一个特殊的功能叫做“<strong>自适应哈希索引</strong>( adaptive hash index)”。<strong>当 Innodb 注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引</strong>，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速的哈希查找。<strong>这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能</strong>。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引就是<strong>索引和数据一起存放</strong>的索引，当表有聚簇索引时，<strong>它的数据行是存放在聚簇索引的叶子节点中的</strong>。</p><p>聚簇索引是主键的索引，<strong>即是通过主键列来组织索引的</strong>。另外，在 innodb 中，<strong style="color:red">若一个表没有指定主键列，innodb 会选择第一个（这里的顺序指的是创建索引时第一个创建的）唯一的非空索引（Unique、Not Null）作为主键，若是没有则自动创建一个 6 byte 大小的主键列</strong>。一个表只能有一个聚簇索引。</p><p>聚簇索引的<strong>优点</strong>：</p><ul><li>一般情况下，聚簇索引的<strong>查询速度</strong>比非聚簇索引要<strong>更快，因为数据行就存储在聚簇索引上</strong>。定位到了结点，就相当于定位到了数据。</li><li>对于主键的排序和范围查找速度快。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>。按主键的顺序插入是速度最快的方法；否则速度会较慢，比如若是插入的新数据需要插入到一个已满的结点，则会造成结点分裂，这时需要额外的开销来维护 B+ 树结构。</li><li><strong>更新索引列（主键列）的值的代价大</strong>。需要将更新的结点移动到新的位置。一般主键列是不允许修改的。</li></ul><p><strong style="color:red">InnoDB 引擎中，其数据文件本身就是索引文件（聚簇索引），InnoDB 的表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引，即聚簇索引（或聚集索引）</strong>。而其余的索引都作为辅助索引，<strong>辅助索引的 data 域存储相应记录主键的值而不是地址</strong>，这也是和 MyISAM 不同的地方。（MyISAM 的索引都是数据和索引分开存储）</p><p>InnoDB 中，在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，<strong>在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂</strong>。</p><h3 id="非聚簇索引（辅助索引）"><a href="#非聚簇索引（辅助索引）" class="headerlink" title="非聚簇索引（辅助索引）"></a>非聚簇索引（辅助索引）</h3><p><strong>非聚簇索引又叫辅助索引、二级索引</strong>。</p><p>InnoDB 中非聚簇索引的<strong>叶结点中没有存储全部数据行数据，除了索引的键值外，存储的是数据行对应的主键值</strong>。即索引结构和数据分开存放。</p><p>在非聚簇索引中定位到结点时，还需要根据这个主键值到聚簇（主键）索引中再次查询，定位到数据行，<strong>这个操作称为回表查询</strong>。</p><p>常见的二级索引：</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p>InnoDB 和 myisam关于聚簇索引、二级索引的存储方式差别：（来自《高性能MySQL》）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210716204841233.png" alt="image-20210716204841233" style="zoom: 80%;" /><p>即 InnoDB 中主键索引是聚簇索引；<strong>MyISAM 的索引文件和数据文件是分离的，索引中的叶子结点的 data 域都是指向数据行的指针</strong>。</p><blockquote><p>这里的指针应该可以直接定位到具体的数据行，而不用再进行回表</p></blockquote><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>如果一个索引包含（覆盖）查询所需要的全部字段，则称为覆盖索引</strong>。</p><p><strong style="color:red">这里的 “所需要的全部字段” 包括 Where 子句之后的字段，还有 select 之后的列</strong>。</p><p>因为包含了所需的全部字段，所以<strong>定位到叶结点时，直接从索引中获取值即可，不用根据主键值进行回表查询，节省了大量 IO 操作的时间</strong>。</p><p>覆盖索引的优点：</p><ul><li><p>InnoDB 中，<strong>如果一个查询可以命中覆盖索引，则不需要进行回表查询，从索引中获取列值即可</strong>。这是覆盖索引最主要的用处。</p></li><li><p>索引条目一般小于数据行大小，可以减少数据访问量。</p></li><li><p>因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于 IO 密集型的范围査询会比随机从磁盘读取每一行数据的 IO 要少得多。</p></li></ul><p><strong>当一个查询命中覆盖索引时，EXPLAIN 命令的 extra 列会显示 <code>Using index</code></strong> 。</p><blockquote><p>《高性能MySQL》页码P217：</p><p>InnoDB 的二级索引中包含主键列的值，可以利用这个主键列来进行覆盖查询，比如一个表的主键是 a ，存在一个普通索引 (b) ，则 (a,b) 可以使用覆盖索引。</p><p>但是测试之后似乎不行：</p><p>表ab，列 a 是主键，b 是一个普通索引列，不管是 (a,b) 还是 (b,a) 都不能命中索引。</p></blockquote><h2 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h2><p>优点：</p><ul><li>索引极大减少需要扫描的数据量。</li><li>对于 B-Tree 索引，因为其有序性，可以用来做 ORDER BY 和 GROUP BY 操作。<strong>可以帮助服务器减少排序和临时表</strong>。</li><li>某些索引中会存储实际的值字段值，所以<strong>某些查询使用索引就能完全完成查询</strong>，不用再去执行读数据。</li></ul><p>索引并不是总是有效。<strong>只有当索引带来的查询收益大于其维护代价时才使用索引。如果数据量较小，大部分情况下全表扫描效率更高；中到大型数据量则索引非常有效；但若是特大型数据则使用索引的代价会过高</strong>。</p><h2 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h2><h3 id="使用选择性高的字段创建索引"><a href="#使用选择性高的字段创建索引" class="headerlink" title="使用选择性高的字段创建索引"></a>使用选择性高的字段创建索引</h3><p>索引的<strong>选择性</strong>（又叫<strong>区分度</strong>）：指索引列中，<strong>不重复的值和表记录总数的比值</strong>。</p><p>选择性越高，查询效率越高——<strong>选择性高的索引可以让 MySQL 在查找时过程掉更多的行</strong>。</p><p><strong>尽量使用选择性高的字段创建索引</strong>。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引即将字段值的部分前缀作为索引。<strong>对于长文本值使用前缀索引可以节省空间</strong>。</p><p><strong>所以可以考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><p>另外，<strong>前缀索引不支持order by 、group by</strong> 。</p><h3 id="联合索引取代单列索引"><a href="#联合索引取代单列索引" class="headerlink" title="联合索引取代单列索引"></a>联合索引取代单列索引</h3><p>尽可能的考虑建立联合索引，而不是为每个列单独创建一个索引。</p><p><strong>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+ 树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且当执行插入、更新或修改索引等操作时，耗费的时间也是较多的，因为需要维护相关的所有单列索引。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升</strong>。</p><blockquote><p>但单列索引相比联合索引并不总是没用的，具体见下文的冗余索引。</p></blockquote><h3 id="合适的索引列顺序"><a href="#合适的索引列顺序" class="headerlink" title="合适的索引列顺序"></a>合适的索引列顺序</h3><p>联合索引的索引顺序是很重要的，要根据常用的查询语句来定义索引列的顺序，判断是否命中索引要根据<strong>最左匹配原则</strong>。</p><h3 id="使用聚簇索引"><a href="#使用聚簇索引" class="headerlink" title="使用聚簇索引"></a>使用聚簇索引</h3><p>使用聚簇索引，<strong>即使用主键进行查询</strong>。</p><p>在聚簇索引中顺序插入行。</p><p>顺序插入主键的缺点：（来自《高性能MySQL》）</p><p>对于高并发工作负载，在 InnoDB 中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUT0 INCREMENT锁机制;如果遇到这个问题，则可能需要考虑重新设计表或者应用，或者更改 innodb autoinc1 ock mode配置。如果你的服务器版本还不支持 innodb autoinc lock mode参数，可以升级到新版本的 Innodb,可能对这种场景会工作得更好。</p><h3 id="去除冗余和重复索引"><a href="#去除冗余和重复索引" class="headerlink" title="去除冗余和重复索引"></a>去除冗余和重复索引</h3><p><strong>重复索引指的是在相同的列上创建了相同类型的索引</strong>。</p><p>示例：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210720101922020.png" alt="image-20210720101922020"></p><p><strong>MySQL 的 unique 和 主键都是通过索引实现</strong>，因此以上的 unique 和  index 是多余的。</p><p><strong>冗余索引</strong>：对于索引 <code>(a) (a,b)</code> ，其中 <code>(a)</code> 是冗余的，因为能命中前者，则一定能命中后者，这时使用后者即可。</p><p><strong>创建冗余索引通常发生在为表添加新索引的时候</strong>。例如，增加一个新的索引 (AB)，而不是扩展已有的索引 (A) 。<strong>还有一种情况是将一个索引扩展为 (A ID) ，其中 ID 是主键，对于 Innodb 来说，主键列已经包含在二级索引中了，所以这也是冗余的</strong>。</p><p><strong>但冗余索引不一定总是没用的</strong>：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210717223610524.png" alt="image-20210717223610524"></p><p><strong>冗余索引太多也会导致 insert、update、delete 等操作变慢 （需要同时更新索引）。</strong> </p><blockquote><p>存疑：因为二级索引的叶子节点包含了主键值，所以在列 (A) 上的索引就相当于在 (A,ID) 上的索引。但如果将索引扩展为 (AB) ，则变成了 (AB,ID)。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>1.选择合适的字段创建索引：</strong></p><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h2 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h2><ul><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ul><h2 id="InnoDB的数据页结构"><a href="#InnoDB的数据页结构" class="headerlink" title="InnoDB的数据页结构"></a>InnoDB的数据页结构</h2><p>InnoDB 的数据页结构：（来自《InnoDB存储引擎》）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210720183547986.png" alt="image-20210720183547986" style="zoom:67%;" /><p>InnoDB 的存储引擎表总是 B+ 树索引组织的，<strong>结点是数据页，是 InnoDB 中的最小磁盘单位</strong>。</p><p>这里重点说明 User Records 和 Page Directory 部分：</p><ul><li><p><strong>User Records</strong> 即存放实际数据行的部分。<strong>这些行记录依次串成一条单链表</strong>。</p></li><li><p>Page Directory 是 User Records 中的记录的<strong>稀疏目录</strong>。<strong>存储这些记录的位置</strong>。</p></li><li><p>它们的关系大致如下：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210720200437692.png" alt="image-20210720200437692" style="zoom: 67%;" /></li><li><p>在 Page Directory 中的<strong>记录是按索引值排序</strong>的，<strong>所以可以通过二叉查找快速定位到对应的槽</strong>（Slot），但因为一个槽是对应多个记录的，<strong>所以还需要到对应的槽中遍历找到具体的行记录</strong>。</p></li></ul><p><strong style="color:red">B+ 树索引本身并不能找到具体的一条记录，能找到的只是该记录所在的页。数据库把页载入到内存，然后通过 Page Directory（页目录） 再进行二叉查找</strong>。<strong>只不过叉查找的时间复杂度很低，同时在内存中的查找很快，因此通常忽略这部分查找所用的时间</strong>。即<strong>在 B+ 树索引中定位到对应的叶结点，就是定位到了记录所在的页，再根据页记录定位到对应的槽，在槽中遍历找到具体的行记录</strong>。这里说的是在聚簇索引中的情况。</p><p>而若是<strong>没有使用索引，则需要进行全表扫描</strong>，大致过程是：</p><ul><li>遍历聚簇索引的叶结点（<strong>B+ 树的叶结点串成一条双向链</strong>），找到记录所在页；</li><li>由于没有使用索引（主键），所以需要从头开始遍历页中的记录部分（<strong>即遍历单向链</strong>）。</li><li>遍历双向链找到所在页，遍历单链表找到所在记录，<strong>相比于使用索引时的 B+ 树查找和二分查找，效率肯定会低上很多。这就是为什么索引会比全表扫描更快</strong>。</li></ul><hr><p>参考：</p><blockquote><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">数据库索引总结 2</a> </p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=1&sn=410dea1863ba823bec802769e1e6fe8a&chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&token=1676899695&lang=zh_CN&scene=21#wechat_redirect">数据库两个神器索引和锁(修订版)-3y</a></p><p>[数据库索引总结 1](<a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL">https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL</a> Index) </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;索引概述&quot;&gt;&lt;a href=&quot;#索引概述&quot; class=&quot;headerlink&quot; title=&quot;索引概述&quot;&gt;&lt;/a&gt;索引概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;索引是存储引擎用于快速找到记录的一种数据结构&lt;/strong&gt;。其作用相当于是一个 “目录”，在这个目录中可以快速找到想要的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务、锁</title>
    <link href="http://example.com/2021/08/30/MySQL/InnoDB%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81/"/>
    <id>http://example.com/2021/08/30/MySQL/InnoDB%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81/</id>
    <published>2021-08-30T05:05:17.338Z</published>
    <updated>2021-08-30T05:06:17.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​        <strong>事务是逻辑上的一组操作，即一个或多个SQL语句，要么都执行，要么都不执行</strong>。<strong>如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚</strong>。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功， 则事物被顺利执行。</p><p>​        事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h2 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h2><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200716162156.png"></p><ol><li><p><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。<strong>事务的原子性确保动作要么全部完成，要么完全不起作用</strong>；</p></li><li><p><strong>隔离性（Isolation）：</strong> 并发访问数据库时，<strong>一个用户的事务不被其他事务所干扰</strong>，各并发事务之间是独立的；<strong>一个事务所做的修改在最终提交以前，对其它事务是不可见的</strong>。</p></li><li><p><strong>持久性（Durability）：</strong> 一旦事务提交，则其所做的修改将会永远保存到数据库中。<strong>即使系统发生崩溃，事务执行的结果也不能丢失</strong>。</p></li><li><p><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，<strong>多个事务对同一个数据读取的结果是相同的</strong>；</p><ul><li><p><strong>ACID 里的 AID 都是数据库的特征，也就是依赖数据库的具体实现。而唯独这个 C，实际上它依赖于应用层，也就是依赖于开发者。这里的一致性是指<font color="red">系统从一个正确的状态，迁移到另一个正确的状态</font>。什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态。而事务具备 ACID 里 C 的特性是说通过事务的 AID 来保证我们的一致性</strong>。</p><p>（来自<a href="https://www.zhihu.com/question/31346392/answer/362597203">https://www.zhihu.com/question/31346392/answer/362597203</a> 作者：孟波）</p></li></ul></li></ol><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><p><strong style="color:red">几个特性的关系</strong>：</p><ul><li><strong>只有满足一致性，事务的执行结果才是正确的</strong>。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在<strong>并发情况下</strong>，多个事务并行执行，<strong>事务不仅要满足原子性，还需要满足隔离性，才能满足一致性</strong>。</li><li><strong>事务满足持久化是为了能应对系统崩溃的情况</strong>。</li></ul><h2 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h2><p>事务可分为隐式事务和显式事务。<strong style="color:red">隐式事务如 DML 语言（insert、update、delete），每一个语句都是一个事务</strong>；而显式事务通过sql语句开启事务跟关闭事务，一个事务可有多条语句。</p><p><strong>msyql默认关闭事务，通过<code>SHOW VARIABLES LIKE &#39;%autocommit%&#39;;</code>命令可看到``autocommit=ON`，即自动提交默认开启。创建事务前需关闭自动提交</strong>。<strong><span style="color:red;">事务中不能包括DDL语句</span></strong>。</p><p>显示事务的创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.开启事务</span></span><br><span class="line"><span class="comment"># 若是设置 autocommit 为 0，则默认开始事务，最后使用commit提交即可</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">START</span> TRASACTION;</span><br><span class="line"><span class="comment">--编写事务语句</span></span><br><span class="line">语句1</span><br><span class="line">语句2</span><br><span class="line">...</span><br><span class="line"><span class="comment">--结束事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>一个转账的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>(</span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">10</span>)，</span><br><span class="line">money <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">account</span> <span class="keyword">VALUES</span>(<span class="string">&#x27;zhangsan&#x27;</span>， <span class="number">1000</span>)，(<span class="string">&#x27;xiaoming&#x27;</span>， <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#转账例子</span></span><br><span class="line"><span class="comment">#开启事务（关闭事务自动提交）</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">#事务语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">1500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line"><span class="comment">#提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h3 id="回滚点SAVEPOINT"><a href="#回滚点SAVEPOINT" class="headerlink" title="回滚点SAVEPOINT"></a>回滚点SAVEPOINT</h3><p>​        回滚点跟<code>ROLLBACK</code>搭配使用，其作用是设置一个保存点，当执行<code>ROLLBACK</code>时回滚到保存点。</p><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> a;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> a;</span><br></pre></td></tr></table></figure><p>执行以上语句后查询account表，可发现只删除了id为2的记录。</p><h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2><p>图解：<a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">CS-Note</a> </p><p>​        在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（<strong>多个用户对同一数据进行操作</strong>）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><p><strong>脏读（Dirty read）:</strong> <strong>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的</strong>，比如可能出现错误而回滚事务，导致修改后的数据没有存入数据库。</p></li><li><p><strong>丢失修改（Lost to modify）:</strong> <strong>指在一个事务读取一个数据时，另外一个事务也访问了该数据，随后在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被覆盖掉了（即丢失了），因此称为丢失修改</strong>。 </p></li><li><p><strong>不可重复读（Unrepeatableread）:</strong> <strong>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的结果可能不一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读</strong>。（事务1读数据的过程中，事务2把数据给改了，导致事务1两次读的数据不同）</p></li><li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，<strong>第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</strong>。（<strong>在同一事务下，连续执行两次同样的SQL语句第二次的SQL语句可能返回之前不存在的行</strong>）</p></li></ul><p><strong><span style="color:red">不可重复读和幻读区别</span></strong>： </p><p><strong>不可重复读的重点是数据的值被修改，比如多次读取一条记录发现其中某些列的值被修改</strong>，幻读的重点在于<strong>新增或者删除比如多次读取一条记录发现记录增多或减少了</strong>。</p><p><strong>产生并发不一致性问题的主要原因是破坏了事务的隔离性</strong>，解决方法是<strong>通过并发控制来保证隔离性</strong>。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h2 id="MySQL的事务隔离级别"><a href="#MySQL的事务隔离级别" class="headerlink" title="MySQL的事务隔离级别"></a>MySQL的事务隔离级别</h2><p><strong><span style="color:red">SQL 标准定义了四个隔离级别：</span></strong> </p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong><span style="color:red">可能会导致脏读、幻读或不可重复读</span></strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong><span style="color:red">可以阻止脏读，但是幻读或不可重复读仍有可能发生</span></strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> <strong>保证在同一个事务中多次读取同一数据的结果是一样的</strong>，除非数据是被本身事务自己所修改，<span style="color:red"><strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></span>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> <strong>最高的隔离级别，完全服从ACID的隔离级别</strong>。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但效率极低。该标准类似于线程锁。</li></ul><p>可总结为下表（<strong>打勾表示可能发生</strong>）</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>MySQL <strong>InnoDB 存储引擎</strong>的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。可以<strong>通过<code>SELECT @@tx_isolation;</code>命令</strong>来查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure><blockquote><p>【<strong><span style="color:red">这里需要注意的是</span></strong>：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是<strong>Next-Key Lock 锁算法</strong>，因此<strong><span style="color:red">可以避免幻读的产生</span></strong>，这与其他数据库系统(如 SQL Server) 是不同的。所以说<strong><span style="color:red">InnoDB 存储引擎的默认支持的隔离级别已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别</span></strong>。】—— 存疑</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，<strong>但是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读），<span style="color:red"> 并不会有任何性能损失</span></strong>。</p></blockquote><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><p>设置事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span>/<span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> </span><br><span class="line"><span class="keyword">read</span> uncommitted | <span class="keyword">read</span> committed | repeatable <span class="keyword">read</span>(默认) | <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure><h2 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h2><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>互斥锁（Exclusive）：简写为 <strong>X 锁</strong>，又称<strong>写锁</strong>。</li><li>共享锁（Shared）：简写为 <strong>S 锁</strong>，又成<strong>读锁</strong>。</li></ul><p>读写锁的 <strong>2 个规定</strong>：</p><ul><li>一个事务对对象 A 加了 X 锁，就可以读写数据。加锁期间其他事务不能对对象 A 加任何锁。</li><li>一个事务对对象 A 加了 S 锁，就可以读数据，但不能写数据。加锁期间其他事务可以对对象 A 加 S 锁，但不能加 X 锁。</li></ul><p>另外，<strong>X 锁和 S 锁可以是表级锁也可以是行级锁</strong>。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁<strong>都是表锁</strong>，用来<strong>表示一个事务想要在表中的某些数据行上加 X 锁或 S 锁</strong>。有以下两个规定：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行 S 锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁<strong>或者更强的锁</strong>。</li><li>意向排他锁（IX）：事务打算给数据行加行 X 锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>大部分情况下锁都是由存储引擎自动加的，比如在执行 UPDATE、INSERT、DELETE 时，InnoDB 会给涉及的数据行加 X 锁。</p><h4 id="为什么使用意向锁"><a href="#为什么使用意向锁" class="headerlink" title="为什么使用意向锁"></a>为什么使用意向锁</h4><p><strong style="color:red">在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，需要检查表 A 是否已被加锁，且需要检查表的每一行是否被加锁，这是非常耗时的</strong>。（X 锁和任何锁都互斥）</p><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁（<strong>表锁</strong>），<strong>只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁</strong>，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败（<strong>注意这里指的是对整个表 A 加 X 锁，不是要对行加锁</strong>），<strong>这样就不用检查每一行是否有锁</strong>，提高效率。</p><h4 id="各类锁的兼容关系"><a href="#各类锁的兼容关系" class="headerlink" title="各类锁的兼容关系"></a>各类锁的兼容关系</h4><p>X/S/IX/IS 的兼容关系：（来自参考链接）：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210420105522070.png" alt="image-20210420105522070"></p><p>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</p><p><strong style="color:red">注意上图的兼容关系针对的是表级锁</strong>，比如表级的 X 和 IX 不兼容。<strong>但行级的 X 锁和 IX 锁是兼容的，即若是一个表已经被加 IX 锁，也允许一个事务对某一行加 X 锁</strong>：事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。</p><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><p><strong>1.三级封锁协议</strong>：</p><ul><li><p><strong>一级封锁协议</strong>：事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</p><p>可以避免丢失修改，但不能保证可重复读和脏读。</p></li><li><p><strong>二级封锁协议</strong>：一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后方可释放 S 锁。</p><p>除了可以避免丢失修改，也可以避免脏读，因为若其他事务的 X 锁未释放，当前事务无法加 S 锁，也就不能读。但不能避免不可重复读，因为读完就把锁释放了。</p></li><li><p><strong>三级封锁协议</strong>：一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，<strong>直到事务结束才释放</strong>。二级封锁协议是读完就释放 S 锁，<strong>而三级协议则是等到事务结束才释放</strong>。</p><p><strong>进一步避免不可重复读</strong>。</p><p><strong>2. 两段锁协议</strong>：</p></li></ul><p>两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。</p><p>两段封锁法可以这样来实现：事务开始后就处于加锁阶段，<strong>一直到执行 ROLLBACK 和 COMMIT 之前都是加锁阶段</strong>。ROLLBACK 和 COMMIT 使事务进入解锁阶段，即在 ROLLBACK 和 COMMIT 模块中 DBMS 释放所有封锁。</p><ol><li><p>在对任何数据进行读、写操作之前，要申请并获得对该数据的封锁。</p></li><li><p>每个事务中，<strong>所有的封锁请求先于所有的解锁请求</strong>。</p></li></ol><p>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p><blockquote><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p></blockquote><h3 id="MySQL-隐式与显式锁定"><a href="#MySQL-隐式与显式锁定" class="headerlink" title="MySQL 隐式与显式锁定"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h3 id="InnoDB的3种行锁算法"><a href="#InnoDB的3种行锁算法" class="headerlink" title="InnoDB的3种行锁算法"></a>InnoDB的3种行锁算法</h3><p>InnoDB的 3 种行锁算法：</p><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁。索引一个范围，但不包含记录本身。</li><li>Next-key Lock：Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身，锁定区间是左开右闭。</li></ul><p><strong>Next-key Lock 算法是 Repeatable read 隔离级别下才使用的。在加锁期间在被锁的范围内不能增加或删除，避免了幻读</strong>。</p><p><strong>Repeatable read 隔离级别下</strong>：</p><ul><li><p><strong>执行普通的 select 语句（没有显示加锁）时使用的都是一致性非锁定读</strong>，即只会读取当前事务之前的数据，不存在幻读的问题，也就没有必要使用 Next-key Lock 算法。</p></li><li><p><strong style="color:red">而若是使用一致性锁定读（即显示加锁），因为总是会读取已提交的最新版本的数据，所以不作特殊处理的话会出现幻读</strong>，InnoDB 在一致性锁定读下会使用 Next-key Lock 来避免幻读，<strong style="color:red">即 Repeatable read 隔离级别下只有使用一致性锁定读时 Next-key Lock 算法才会生效</strong>。</p></li><li><p><strong style="color:red">另外要注意的是，Next-key Lock 具体的说是为了避免 RR 隔离级别下一致性锁定读的幻读问题，一致性非锁定读是没有幻读问题的</strong>。</p></li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="MVCC概述"><a href="#MVCC概述" class="headerlink" title="MVCC概述"></a>MVCC概述</h3><p>MVCC，Muti-Version Concurrency Control，<strong>多版本并发控制</strong>。<strong style="color:red">它是通过保存数据在某个时间点的快照来实现的</strong>，在<strong>很多情况下可以避免加锁</strong>，开销更低。</p><p><strong style="color:red">InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，其中一个保存了行的创建时间，一个保存行的过期时间（或者说是删除时间）。这里说是“时间”，实际指的是系统版本号，所以上述 2 个“时间”可以理解为【创建时的版本号】以及记录【被删除时的版本号】</strong>。<strong>每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较</strong>。</p><blockquote><p>使用 begin 或 start transaction 开始事务后，系统版本号并不会立即递增，</p></blockquote><p>在 REPEATABLE READ （可重复读）隔离级别下，MVCC 对不同 SQL 的操作：</p><ul><li><p>SELECT：符合以下两个条件的记录，才能返回作为查询结果：</p><ul><li><strong>行的系统版本号小于或等于当前事务的系统版本号</strong>，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。<strong style="color:red">这样就避免了不可重复读的情况，因为其他事务修改后数据的系统版本号会大于当前事务的系统版本号</strong>。（同时也避免了脏读）</li><li>行的删除版本未定义，或者大于当前事务版本号（<strong>即在当前事务时该行还未被删除</strong>）。这可以确保事务读取到的行，在事务开始之前未被删除。</li></ul></li><li><p>INSERT：InnoDB <strong>为新插入的每一行保存当前系统版本号作为行版本号</strong>。</p><blockquote><p>注意执行 INSERT 插入的行保存的版本号的【当前的系统版本号】，而不是当前事务的版本号。</p></blockquote></li><li><p>DELETE：InnoDB <strong>为删除的每一行保存当前系统版本号作为行删除标识</strong>。</p></li><li><p>UPDATE：InnoDB <strong>插入一行新记录，保存当前系统版本号作为新行的版本号，同时保存当前系统版本号到原来的行作为行删除标识</strong>。（旧行并没有从物理上删除）</p></li></ul><blockquote><p>对于 READ COMMITTED 隔离级别，insert、delete、update 的操作应该是一样的。</p></blockquote><p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。<strong>缺点</strong>是每个快照都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p><p><strong>InnoDB 的 MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作</strong>。</p><h3 id="一致性非锁定读-锁定读"><a href="#一致性非锁定读-锁定读" class="headerlink" title="一致性非锁定读/锁定读"></a>一致性非锁定读/锁定读</h3><ul><li><p>InnoDB 的 MVCC 中，默认情况下是读取数据是采用一致性非锁定读的，<strong>即如果当前行正在进行 DELETE 或 UPDATE，这时读取操作不会去等待行上锁的释放，而是去读取该行的一个快照版本（老版本）</strong>。且在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下一致性非锁定读有所区别：</p><ul><li>REPEATABLE READ 总是读取事务开始时的行数据版本；</li><li>对于 READ COMMITTED ，每次总是读取最新已提交版本。</li></ul></li><li><p>某些情况下需要对读取操作加锁保证数据的逻辑一致性，这需要通过加锁语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ... for update</span><br><span class="line">select ... lock in share mode</span><br></pre></td></tr></table></figure><p><strong>前者对读取的行加 X 锁；后者对读取的行加 S 锁</strong>。这就是一致性锁定读。<strong style="color:red">一致性锁定读读取的总是最新的（已提交）数据</strong>。</p></li></ul><p>InnoDB 的 MVCC 下（或者说，在 InnoDB 的 READ COMMITED 和 REPETABLE READ 隔离级别下），普通的 select 语句（没有显式加锁）都是使用一致性非锁定读，而若是显示加锁则使用一致性锁定读。</p><h3 id="关于加锁"><a href="#关于加锁" class="headerlink" title="关于加锁"></a>关于加锁</h3><p>select 的 2 种显示加锁方式<strong style="color:red">一般会在事务块中使用，且在事务结束时才会释放锁，同样的，在一个事务中使用 update 、insert 加的锁也需要等到事务结束才释放</strong>。</p><blockquote><p>在网上看到一些文章说 2 个显示加锁语句只有开启事务才会生效，这种说法似乎是错的，或者说，<strong>如果没有显示开启事务，则单独一条加锁的 select 语句就是一个单独的事务，加锁语句是会生效的</strong>。</p></blockquote><p>另外，即使某个记录被加上排他（X）锁，一个普通的 SELECT 语句也是可以读取该记录的，而若是该 SELECT 语句有显示加锁，则会阻塞。</p><p>示例 1 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 连接1 中先执行：</span><br><span class="line">begin;</span><br><span class="line">SELECT * from index_test where a &#x3D; 3 for UPDATE;</span><br><span class="line"></span><br><span class="line"># 随后在连接2 中执行以下语句会阻塞</span><br><span class="line">SELECT b from index_test where a &#x3D; 3 for UPDATE;</span><br><span class="line"></span><br><span class="line"># 连接1 中提交事务后，连接2 的查询语句就可以获得锁继续执行</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>示例 2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 连接1 中先执行：</span><br><span class="line">begin;</span><br><span class="line">SELECT * from index_test where a &#x3D; 3 for UPDATE;</span><br><span class="line"></span><br><span class="line"># 随后在连接2 中执行以下语句，发现并不会阻塞</span><br><span class="line"># 但若是在连接1 中修改数据但不提交事务，则连接2 读取不到提交的数据（默认情况下）</span><br><span class="line">SELECT b from index_test where a &#x3D; 3;</span><br></pre></td></tr></table></figure><h3 id="MVCC与隔离级别"><a href="#MVCC与隔离级别" class="headerlink" title="MVCC与隔离级别"></a>MVCC与隔离级别</h3><p>这里大概说明一下 InnoDB 是如何通过 MVCC 实现 REPEATABLE READ 和 READ COMMITTED 隔离级别的。</p><ol><li><p>READ COMMITTED</p><p>一个事务对数据进行修改，<strong>在 commit 时</strong>会生成一条新的数据快照，这个快照的版本比原来的数据的版本高。<strong>在该隔离级别下，事务在读取数据时都会读取最高版本的行记录，所以若是一个事务修改数据后没有 commit ，也就没有提交更新版本的数据快照，修改的数据就不会被其他事务读取，从而避免了脏读</strong>。但避免不了不可重复读，因为事务只要提交了修改，这个修改就可以被其他事务读取到。</p></li><li><p>REPEATABLE READ</p><p>REPEATABLE READ 隔离级别下读取数据<strong>只会读取版本号小于等于当前事务的行数据</strong>，<strong style="color:red">在当前事务持续期间，其他事务即使修改了数据并 commit ，因为 commit 后的新数据的版本比当前事务高，所以不会被当前事务读取到，从而避免了不可重复读</strong>。另外，在该隔离级别下，<strong>InnoDB 使用了 Next-key 锁算法，所以还可以避免幻读</strong>。</p></li></ol><h3 id="关于事务ID-TODO"><a href="#关于事务ID-TODO" class="headerlink" title="关于事务ID(TODO)"></a>关于事务ID(TODO)</h3><p>每开始一个事务，系统中的事务 id （系统版本号）会自增 1 。</p><blockquote><p>在 MySQL 5.7 中的测试情况：</p><p>执行 BEGIN 并不会使事务 id 自增，只有当执行 update、insert 或当前读等涉及到加锁的操作时才会使事务 id 自增。</p><p>且执行普通的 select 时也会分配一个 id ，但该 id 很大，跟系统版本 id 不同，目前还不知道是啥。（TODO）</p></blockquote><p>可以通过以下语句查询当前事务的 id ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TRX_ID FROM INFORMATION_SCHEMA.INNODB_TRX  WHERE TRX_MYSQL_THREAD_ID &#x3D; CONNECTION_ID();</span><br></pre></td></tr></table></figure><p>单独使用（没有开启事务）一个 <code>select ... for update</code> 或 <code>select ... lock in share mode</code> 会使系统版本号加 1 ，但使用一个普通的 select 语句则不会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前所有进行中的事务信息</span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"></span><br><span class="line"># 查看系统的事务 id （找到 trx counter 字段）</span><br><span class="line">SHOW ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL" target="_blank">javaGuide</a>  </li><li><a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理-CS-Note</a>  </li><li><a href="https://juejin.cn/post/6844903645125820424">索引和锁-Java3y</a>  </li><li>《高性能MySQL》</li><li>《MySQL技术内幕-InnoDB存储引擎》</li><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;​        &lt;strong&gt;事务是逻辑上的一组操作，即一个或多个SQL语句，要么都执行，要么都不执行&lt;/strong&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装、卸载等操作</title>
    <link href="http://example.com/2021/08/30/MySQL/%E5%AE%89%E8%A3%85&amp;%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/30/MySQL/%E5%AE%89%E8%A3%85&amp;%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-30T05:05:17.336Z</published>
    <updated>2021-08-30T05:05:56.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL5-8-安装（压缩包版）"><a href="#MySQL5-8-安装（压缩包版）" class="headerlink" title="MySQL5.* 8.* 安装（压缩包版）"></a>MySQL5.* 8.* 安装（压缩包版）</h2><p>参考链接：<a href="https://blog.csdn.net/qq_43715354/article/details/109354222">链接</a> </p><p>*<em>MySQL5.</em> 和 8.0.22 都可以照这个安装方法，这里以 5.7.30 为例**。</p><blockquote><p>使用 installer 只能安装在 c 盘 。</p></blockquote><ul><li><p>官网下载 5.7.30 zip 压缩包。</p></li><li><p>解压，重命名。</p></li><li><p>Path 环境变量中添加：（即 bin 目录路径）(<strong>这一步应该可以省略</strong>)</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:<span class="symbol">\P</span>rogram Files<span class="symbol">\M</span>ySQL<span class="symbol">\m</span>ysql-5.7.30<span class="symbol">\b</span>in</span><br></pre></td></tr></table></figure></li><li><p>安装目录下创建 my.ini 配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\Program Files\MySQL\mysql-<span class="number">5.7</span>.<span class="number">30</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\Program Files\MySQL\mysql-<span class="number">5.7</span>.<span class="number">30</span>\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为utf8mb4</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment">#mysql_native_password</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br></pre></td></tr></table></figure></li><li><p>管理员运行 cmd，进入 bin 目录，执行命令进行初始化： </p><p>这里日志信息会打印在控制台，<strong>要注意会生成一个暂时密码</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure></li><li><p>安装服务：（后面的参数是指定服务名，若省略则默认为 MySQL）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --install mysql5.7</span><br></pre></td></tr></table></figure><blockquote><p>如果提示服务已存在，进行移除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -remove MySQL-Server-Name</span><br></pre></td></tr></table></figure></blockquote></li><li><p>启动 MySQL 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql5.7</span><br></pre></td></tr></table></figure></li><li><p>输入<code>mysql -u root -p</code> </p></li><li><p>输入上述随机生成的密码进入数据库。进入后需要修改密码，因为随机生成的密码在登录后会过期。（这时若不修改密码，执行一切sql语句都会报错，提醒修改密码）</p></li><li><p>修改密码的命令：</p><ul><li><p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;newPassword&#39;;</code> </p></li><li><p><code>flush privileges;</code> </p></li></ul></li></ul><h2 id="同一个主机切换MySQL版本"><a href="#同一个主机切换MySQL版本" class="headerlink" title="同一个主机切换MySQL版本"></a>同一个主机切换MySQL版本</h2><p>右键我的计算机，管理，服务，关闭、启动。</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><ol><li><p>登录 MySQL 。</p></li><li><p>查询密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">select</span> host,<span class="keyword">user</span>,authentication_string <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure><blockquote><p>mysql 5.7.9以后废弃了password字段和password()函数；authentication_string:字段表示用户密码。</p></blockquote></li><li><p>将 authentication_string 置空：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="string">&#x27;&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">&#x27;root&#x27;</span> <span class="keyword">and</span> host=<span class="string">&#x27;xx&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>修改密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;newPassword&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><p>参考</p><ul><li><a href="https://www.cnblogs.com/tmdsleep/p/10967432.html">MySQL8.*修改密码</a> </li></ul><h2 id="MySQL卸载"><a href="#MySQL卸载" class="headerlink" title="MySQL卸载"></a>MySQL卸载</h2><p>MySQL的卸载：<a href="https://www.bilibili.com/video/BV12b411K7Zu?p=249">https://www.bilibili.com/video/BV12b411K7Zu?p=249</a>  第6集</p><h2 id="MySQL服务的启动和关闭"><a href="#MySQL服务的启动和关闭" class="headerlink" title="MySQL服务的启动和关闭"></a>MySQL服务的启动和关闭</h2><p>可通过</p><p><strong>【右键我的电脑】-》【管理】-》【服务和应用程序】-》【服务】-》【找到MySQL】-》【双击，选择启动/关闭】</strong> </p><p>或者：</p><p><strong>以【管理员身份运行命令行】-》【输入命令<code>net stop/start mysqlServerName</code>】</strong> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL5-8-安装（压缩包版）&quot;&gt;&lt;a href=&quot;#MySQL5-8-安装（压缩包版）&quot; class=&quot;headerlink&quot; title=&quot;MySQL5.* 8.* 安装（压缩包版）&quot;&gt;&lt;/a&gt;MySQL5.* 8.* 安装（压缩包版）&lt;/h2&gt;&lt;p&gt;参考</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>IDEA的一些使用技巧</title>
    <link href="http://example.com/2021/08/30/IDEA/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2021/08/30/IDEA/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-08-30T05:02:36.866Z</published>
    <updated>2021-08-30T05:03:09.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该笔记基于IDEA-2019版本</p></blockquote><h2 id="提高运行速度"><a href="#提高运行速度" class="headerlink" title="提高运行速度"></a>提高运行速度</h2><p>在idea安装目录的bin目录下的idea.exe.vmoptions文件，调整<code>Xms</code>跟<code>Xmx</code>两个参数的值可提高运行速度，但要注意电脑的运行内存是否足够。</p><h2 id="恢复默认设置"><a href="#恢复默认设置" class="headerlink" title="恢复默认设置"></a>恢复默认设置</h2><p>在用户目录中，有一个<code>.IntelliJIdea2019.3</code>目录，该目录下有个<code>config</code>跟一个<code>system</code>目录，前者存放关于IDEA一些设置相关的配置文件。可以通过将这两个目录删除来实现恢复默认设置（在重启idea时会自动创建这两个文件，但之前设置的快捷键、模板等将被重置）。</p><h2 id="工具条"><a href="#工具条" class="headerlink" title="工具条"></a>工具条</h2><p>【View】-》【Appearance】-》【选中Tool Bar】，打开工具条。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200814222041.png"></p><h2 id="IDEA中的Project和Module"><a href="#IDEA中的Project和Module" class="headerlink" title="IDEA中的Project和Module"></a>IDEA中的Project和Module</h2><p>参考链接：</p><blockquote><p><a href="https://blog.csdn.net/qq_35246620/article/details/65448689">https://blog.csdn.net/qq_35246620/article/details/65448689</a> </p></blockquote><p>在 IntelliJ IDEA 中<code>Project</code>是最顶级的结构单元，然后就是<code>Module</code>，一个<code>Project</code>可以有多个<code>Module</code>。</p><p>一个<code>Project</code>是由一个或多个<code>Module</code>组成，</p><ul><li>当为单<code>Module</code>项目的时候，这个单独的<code>Module</code>实际上就是一个<code>Project</code>；</li><li>当为多<code>Module</code>项目的时候，多个模块处于同一个<code>Project</code>之中，此时彼此之间具有互相依赖的关联关系。</li></ul><p>此外， IntelliJ IDEA 的<code>Project</code>是一个不具备任何编码设置、构建等开发功能的概念，其主要作用就是起到一个项目定义、范围约束、规范类型的效果，这个目录在命名上应该有其代表性的意义。在缺省情况下，IntelliJ IDEA 是默认单<code>Project</code>单<code>Module</code>的，这时<code>Project</code>和<code>Module</code>合二为一。</p><p>要删除Module时，需要进入<code>Project Structure</code>，在左边选择<code>Modules</code>，右边视图中选中要删除的Module，点击上方的<code>-</code>（或右键delete）即可。此时在项目中移除了对应Module，但在磁盘中没有删除Module对应目录，需手动删除。</p><p><strong>在一个Module中，可以通过在本Module的imi文件中配置引入其他Module的内容</strong>。可以使用<code>Alt+Enter</code>的提示功能自动配置。</p><h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><h3 id="鼠标悬停显示文档"><a href="#鼠标悬停显示文档" class="headerlink" title="鼠标悬停显示文档"></a>鼠标悬停显示文档</h3><p>【Settings】-》【Editor】-》【General】-》【视图右边滑到最下面，勾上<code>show quik documentation on mouse move</code>】</p><p>下方的Tooltip delay设置延迟时间。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145751019.png" alt="image-20200815145751019" style="zoom:67%;" /><h3 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135642.png" style="zoom:67%;" /><h3 id="显示方法间的分隔符"><a href="#显示方法间的分隔符" class="headerlink" title="显示方法间的分隔符"></a>显示方法间的分隔符</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135936.png"></p><h3 id="忽略大小写提示的差别"><a href="#忽略大小写提示的差别" class="headerlink" title="忽略大小写提示的差别"></a>忽略大小写提示的差别</h3><p>如图取消勾选即可。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815140939775.png" alt="image-20200815140939775"></p><p>效果：输入S跟s的提示将变的一样。</p><h3 id="多个文件的标签多行显示"><a href="#多个文件的标签多行显示" class="headerlink" title="多个文件的标签多行显示"></a>多个文件的标签多行显示</h3><p>打开多个文件时，让多个文件的标签分成多行显示。如图，取消勾选。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141445072.png" alt="image-20200815141445072" style="zoom:80%;" /><h3 id="设置代码编辑区各部分样式"><a href="#设置代码编辑区各部分样式" class="headerlink" title="设置代码编辑区各部分样式"></a>设置代码编辑区各部分样式</h3><p>设置如单行注释、多行注释、方法等字体的样式。在框框内点击不同位置可自动跳转到对应的设置。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141938283.png" alt="image-20200815141938283" style="zoom: 67%;" /><h3 id="当导入同一个包的类超过多少时使用"><a href="#当导入同一个包的类超过多少时使用" class="headerlink" title="当导入同一个包的类超过多少时使用*"></a>当导入同一个包的类超过多少时使用<code>*</code></h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815142453764.png" alt="image-20200815142453764" style="zoom: 67%;" /><h3 id="设置类的头部信息"><a href="#设置类的头部信息" class="headerlink" title="设置类的头部信息"></a>设置类的头部信息</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143009247.png" alt="image-20200815143009247" style="zoom:67%;" /><h3 id="设置编码（全局）"><a href="#设置编码（全局）" class="headerlink" title="设置编码（全局）"></a>设置编码（全局）</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143239051.png" alt="image-20200815143239051" style="zoom:67%;" /><h3 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h3><p>也可同时勾上框框第二项，启动多模块并行编译。但会占用更多内存。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815144738928.png" alt="image-20200815144738928" style="zoom:67%;" /><h3 id="多个代码文件垂直-水平显示"><a href="#多个代码文件垂直-水平显示" class="headerlink" title="多个代码文件垂直/水平显示"></a>多个代码文件垂直/水平显示</h3><p>右键标签页，如图：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145150886.png" alt="image-20200815145150886" style="zoom: 80%;" /><p>效果：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145304470.png" alt="image-20200815145304470" style="zoom: 67%;" /><h3 id="CTRL-插入注释时带缩进"><a href="#CTRL-插入注释时带缩进" class="headerlink" title="CTRL+/ 插入注释时带缩进"></a><code>CTRL+/</code> 插入注释时带缩进</h3><p>设置Java文件：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135428506.png" alt="image-20200818135428506" style="zoom:67%;" /><p>XML文件同理：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135625076.png" alt="image-20200818135625076" style="zoom:67%;" /><blockquote><p>参考：<a href="https://blog.csdn.net/VariatioZbw/article/details/105626147">https://blog.csdn.net/VariatioZbw/article/details/105626147</a></p></blockquote><h3 id="为main方法传递参数"><a href="#为main方法传递参数" class="headerlink" title="为main方法传递参数"></a>为main方法传递参数</h3><blockquote><p>参考：<a href="https://blog.csdn.net/u013713294/article/details/53020293">https://blog.csdn.net/u013713294/article/details/53020293</a></p></blockquote><p>有时需要使用main方法的args参数，而为args参数赋值一般在命令行中，如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java <span class="comment">//编译</span></span><br><span class="line">java Test para<span class="name">m1</span> para<span class="name">m2</span> para<span class="name">m3</span> ... <span class="comment">//运行Test类，param是传递给main方法的参数</span></span><br></pre></td></tr></table></figure><p>在idea中可以设置参数，在main方法运行时把这些参数传递给它，步骤如下：</p><ol><li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213818332.png" style="zoom:80%;" /><p>或</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213902857.png" style="zoom:80%;" /></li><li><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924214508649.png" alt="image-20200924214508649"></p><p>点击OK，运行main方法时即会传入设置的参数。</p></li></ol><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815152625644.png" alt="image-20200815152625644" style="zoom: 80%;" /><p>查看/修改快捷键：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815233545855.png" alt="image-20200815233545855" style="zoom: 67%;" /><p><strong>快捷键大全</strong>：</p><blockquote><p>以下大部分来自：<a href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p></blockquote><h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + F</td><td align="left">在当前文件进行文本查找 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + R</td><td align="left">在当前文件进行文本替换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Z</td><td align="left">撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Y</td><td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + X</td><td align="left">剪切光标所在行 或 剪切选择内容</td></tr><tr><td align="left">Ctrl + C</td><td align="left">复制光标所在行 或 复制选择内容</td></tr><tr><td align="left">Ctrl + D</td><td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + W</td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + E</td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left">Ctrl + N</td><td align="left">根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td align="left">Ctrl + G</td><td align="left">在当前文件跳转到指定行处</td></tr><tr><td align="left">Ctrl + J</td><td align="left">插入自定义动态代码模板</td></tr><tr><td align="left">Ctrl + P</td><td align="left">方法参数提示显示</td></tr><tr><td align="left">Ctrl + Q</td><td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td align="left">Ctrl + U</td><td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td align="left">Ctrl + B</td><td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td align="left">Ctrl + K</td><td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + T</td><td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + H</td><td align="left">显示当前类的层次结构</td></tr><tr><td align="left">Ctrl + O</td><td align="left">选择可重写的方法</td></tr><tr><td align="left">Ctrl + I</td><td align="left">选择可继承的方法</td></tr><tr><td align="left">Ctrl + +</td><td align="left">展开代码</td></tr><tr><td align="left">Ctrl + -</td><td align="left">折叠代码</td></tr><tr><td align="left">Ctrl + /</td><td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + [</td><td align="left">移动光标到当前所在代码的花括号开始位置</td></tr><tr><td align="left">Ctrl + ]</td><td align="left">移动光标到当前所在代码的花括号结束位置</td></tr><tr><td align="left">Ctrl + F1</td><td align="left">在光标所在的错误代码出显示错误信息</td></tr><tr><td align="left">Ctrl + F3</td><td align="left">调转到所选中的词的下一个引用位置</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭当前编辑文件</td></tr><tr><td align="left">Ctrl + F8</td><td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td align="left">Ctrl + F9</td><td align="left">执行 Make Project 操作</td></tr><tr><td align="left">Ctrl + F11</td><td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td align="left">Ctrl + F12</td><td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td align="left">Ctrl + Enter</td><td align="left">智能分隔行</td></tr><tr><td align="left">Ctrl + End</td><td align="left">跳到文件尾</td></tr><tr><td align="left">Ctrl + Home</td><td align="left">跳到文件头</td></tr><tr><td align="left">Ctrl + Space</td><td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Delete</td><td align="left">删除光标后面的单词或是中文句</td></tr><tr><td align="left">Ctrl + BackSpace</td><td align="left">删除光标前面的单词或是中文句</td></tr><tr><td align="left">Ctrl + 1,2,3…9</td><td align="left">定位到对应数值的书签位置</td></tr><tr><td align="left">Ctrl + 左键单击</td><td align="left">在打开的文件标题上，弹出该文件路径</td></tr><tr><td align="left">Ctrl + 光标定位</td><td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td align="left">Ctrl + 左方向键</td><td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td align="left">Ctrl + 右方向键</td><td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td align="left">Ctrl + 前方向键</td><td align="left">等效于鼠标滚轮向前效果</td></tr><tr><td align="left">Ctrl + 后方向键</td><td align="left">等效于鼠标滚轮向后效果</td></tr></tbody></table><h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + `</td><td align="left">显示版本控制常用操作菜单弹出层</td></tr><tr><td align="left">Alt + Q</td><td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td align="left">Alt + F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left">Alt + F2</td><td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td align="left">Alt + F3</td><td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td align="left">Alt + F7</td><td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td align="left">Alt + F8</td><td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td align="left">Alt + Home</td><td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td></tr><tr><td align="left">Alt + Enter</td><td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td></tr><tr><td align="left">Alt + Insert</td><td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td align="left">Alt + 左方向键</td><td align="left">按左方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 右方向键</td><td align="left">按右方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 前方向键</td><td align="left">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td align="left">Alt + 后方向键</td><td align="left">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td align="left">Alt + 1,2,3…9</td><td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr><tr><td align="left">Alt + 7</td><td align="left">显示当前类的所有方法、成员变量等</td></tr></tbody></table><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Shift + F1</td><td align="left">如果有外部文档可以连接外部文档</td></tr><tr><td align="left">Shift + F2</td><td align="left">跳转到上一个高亮错误 或 警告位置</td></tr><tr><td align="left">Shift + F3</td><td align="left">在查找模式下，查找匹配上一个</td></tr><tr><td align="left">Shift + F4</td><td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td align="left">Shift + F6</td><td align="left">对文件 / 文件夹 重命名</td></tr><tr><td align="left">Shift + F7</td><td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">Shift + F8</td><td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td></tr><tr><td align="left">Shift + F9</td><td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td></tr><tr><td align="left">Shift + F10</td><td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td></tr><tr><td align="left">Shift + F11</td><td align="left">弹出书签显示层</td></tr><tr><td align="left">Shift + Tab</td><td align="left">取消缩进</td></tr><tr><td align="left">Shift + ESC</td><td align="left">隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td align="left">Shift + End</td><td align="left">选中光标到当前行尾位置</td></tr><tr><td align="left">Shift + Home</td><td align="left">选中光标到当前行头位置</td></tr><tr><td align="left">Shift + Enter</td><td align="left">在当前行的下一行另起新行</td></tr><tr><td align="left">Shift+Alt+Enter</td><td align="left">在当前行的上一行另起新行</td></tr><tr><td align="left">Shift + 左键单击</td><td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr><tr><td align="left">Shift + 滚轮前后滚动</td><td align="left">当前文件的横向滚动轴滚动</td></tr></tbody></table><h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Alt + L</td><td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + O</td><td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + I</td><td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td align="left">Ctrl + Alt + T</td><td align="left">对选中的代码弹出环绕选项弹出层</td></tr><tr><td align="left">Ctrl + Alt + J</td><td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td></tr><tr><td align="left">Ctrl + Alt + H</td><td align="left">调用层次</td></tr><tr><td align="left">Ctrl + Alt + B</td><td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td align="left">Ctrl + Alt + V</td><td align="left">快速引进变量</td></tr><tr><td align="left">Ctrl + Alt + Y</td><td align="left">同步、刷新</td></tr><tr><td align="left">Ctrl + Alt + S</td><td align="left">打开 IntelliJ IDEA 系统设置</td></tr><tr><td align="left">Ctrl + Alt + F7</td><td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td align="left">Ctrl + Alt + F11</td><td align="left">切换全屏模式</td></tr><tr><td align="left">Ctrl + Alt + Enter</td><td align="left">光标所在行上空出一行，光标定位到新行</td></tr><tr><td align="left">Ctrl + Alt + Home</td><td align="left">弹出跟当前文件有关联的文件弹出层</td></tr><tr><td align="left">Ctrl + Alt + Space</td><td align="left">类名自动完成</td></tr><tr><td align="left">Ctrl + Alt + 左方向键</td><td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 右方向键</td><td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 前方向键</td><td align="left">在查找模式下，跳到上个查找的文件</td></tr><tr><td align="left">Ctrl + Alt + 后方向键</td><td align="left">在查找模式下，跳到下个查找的文件</td></tr></tbody></table><h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + F</td><td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + R</td><td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + J</td><td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Z</td><td align="left">取消撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + W</td><td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + N</td><td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + U</td><td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + T</td><td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td align="left">Ctrl + Shift + C</td><td align="left">复制当前文件磁盘路径到剪贴板</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">显示最近修改的文件列表的弹出层</td></tr><tr><td align="left">Ctrl + Shift + H</td><td align="left">显示方法层次结构</td></tr><tr><td align="left">Ctrl + Shift + B</td><td align="left">跳转到类型声明处</td></tr><tr><td align="left">Ctrl + Shift + I</td><td align="left">快速查看光标所在的方法 或 类的定义</td></tr><tr><td align="left">Ctrl + Shift + A</td><td align="left">查找动作 / 设置</td></tr><tr><td align="left">Ctrl + Shift + /</td><td align="left">代码块注释 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + [</td><td align="left">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + ]</td><td align="left">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + +</td><td align="left">展开所有代码</td></tr><tr><td align="left">Ctrl + Shift + -</td><td align="left">折叠所有代码</td></tr><tr><td align="left">Ctrl + Shift + F7</td><td align="left">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td align="left">Ctrl + Shift + F8</td><td align="left">在 Debug 模式下，指定断点进入条件</td></tr><tr><td align="left">Ctrl + Shift + F9</td><td align="left">编译选中的文件 / 包 / Module</td></tr><tr><td align="left">Ctrl + Shift + F12</td><td align="left">编辑器最大化</td></tr><tr><td align="left">Ctrl + Shift + Space</td><td align="left">智能代码提示</td></tr><tr><td align="left">Ctrl + Shift + Enter</td><td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Backspace</td><td align="left">退回到上次修改的地方</td></tr><tr><td align="left">Ctrl + Shift + 1,2,3…9</td><td align="left">快速添加指定数值的书签</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 前方向键</td><td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td align="left">Ctrl + Shift + 后方向键</td><td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + Shift + N</td><td align="left">选择 / 添加 task</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">显示添加到收藏夹弹出层</td></tr><tr><td align="left">Alt + Shift + C</td><td align="left">查看最近操作项目的变化情况列表</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">添加到收藏夹</td></tr><tr><td align="left">Alt + Shift + I</td><td align="left">查看项目当前文件</td></tr><tr><td align="left">Alt + Shift + F7</td><td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td align="left">Alt + Shift + F9</td><td align="left">弹出 <code>Debug</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + F10</td><td align="left">弹出 <code>Run</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + 左键双击</td><td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td align="left">Alt + Shift + 前方向键</td><td align="left">移动光标所在行向上移动</td></tr><tr><td align="left">Alt + Shift + 后方向键</td><td align="left">移动光标所在行向下移动</td></tr></tbody></table><h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + Alt + V</td><td align="left">无格式黏贴</td></tr><tr><td align="left">Ctrl + Shift + Alt + N</td><td align="left">前往指定的变量 / 方法</td></tr><tr><td align="left">Ctrl + Shift + Alt + S</td><td align="left">打开当前项目设置</td></tr><tr><td align="left">Ctrl + Shift + Alt + C</td><td align="left">复制参考信息</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">F2</td><td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td></tr><tr><td align="left">F3</td><td align="left">在查找模式下，定位到下一个匹配处</td></tr><tr><td align="left">F4</td><td align="left">编辑源</td></tr><tr><td align="left">F7</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">F8</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">F9</td><td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">F11</td><td align="left">添加书签</td></tr><tr><td align="left">F12</td><td align="left">回到前一个工具窗口</td></tr><tr><td align="left">Tab</td><td align="left">缩进</td></tr><tr><td align="left">ESC</td><td align="left">从工具窗口进入代码文件窗口</td></tr><tr><td align="left">连按两次Shift</td><td align="left">弹出 <code>Search Everywhere</code> 弹出层</td></tr></tbody></table><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>查看/设置模板：</p><p>Live Templates中可以查看、<strong>编辑、添加以及删除</strong>模板：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142838850.png" alt="image-20200816142838850" style="zoom:80%;" /><p>Postfix Completion中只能查看、禁用。下图的Before框表示模板的预定义形式，After表示输出效果。比如下图的例子，输入<code>foo.forr</code>，摁下enter。将输出after框的模板。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142928743.png" alt="image-20200816142928743" style="zoom:67%;" /><h3 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816153643738.png" alt="image-20200816153643738" style="zoom: 80%;" /><p>如上图操作，输入模板组名，确定。选中创建的模板组，点击<code>+</code>，点击<code>Live Template</code>在组中添加新模板。</p><p>设置新模板：</p><ul><li>1处填写模板缩写</li><li>2处填写模板的描述</li><li>3处定义模板内容。<strong>例子中模板的意义：</strong>输入test按下enter出现模板后，光标会跳至<code>$var1$</code>位置，输入完成后按enter，光标跳至<code>$var2$</code>处。</li></ul><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154245765.png" alt="image-20200816154245765"></p><p>下一步，点击define，选择java：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154543995.png" alt="image-20200816154543995" style="zoom:67%;" /><p>点击OK即可。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200821195633214.png" alt="image-20200821195633214" style="zoom:67%;" /><h3 id="idea自带模板"><a href="#idea自带模板" class="headerlink" title="idea自带模板"></a>idea自带模板</h3><table><thead><tr><th>Before</th><th align="left">After</th><th align="left">备注</th></tr></thead><tbody><tr><td><code>psvm</code></td><td align="left"><code>public static void main(String[] args) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>sout</code></td><td align="left"><code>System.out.println();</code></td><td align="left"></td></tr><tr><td><code>soutm</code></td><td align="left"><code>System.out.println(&quot;当前方法的全限定名&quot;);</code></td><td align="left"></td></tr><tr><td><code>soutp</code></td><td align="left"><code>System.out.println(&quot;c = &quot; + c);</code></td><td align="left">以<code>valueName=value</code><br>的形式输出</td></tr><tr><td><code>soutv</code></td><td align="left">与上同</td><td align="left">输出某一变量</td></tr><tr><td><code>variable.sout</code></td><td align="left"><code>System.out.println(variable);</code></td><td align="left"></td></tr><tr><td><code>fori</code> （<strong>递增</strong>）</td><td align="left"><code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></td><td align="left">输入完成后光标跳至第一个i后<br>可改变变量名；按enter光标跳至&lt;后<br>再按enter跳至<code>&#123;&#125;</code>中</td></tr><tr><td><code>arrs/List/Set.fori</code></td><td align="left"><code>for (int i = 0; i &lt; xxx.size(); i++) &#123;&#125;</code></td><td align="left">可对数组、集合使用。</td></tr><tr><td><code>forr</code>（递减）</td><td align="left">与上同理</td><td align="left"></td></tr><tr><td><code>arrs/List/Set.forr</code></td><td align="left"></td><td align="left"></td></tr><tr><td><code>iter</code></td><td align="left"><code>for (T t : arrs) &#123;&#125;</code></td><td align="left">对某一数组使用forEach循环</td></tr><tr><td><code>arrs.iter</code></td><td align="left">同上</td><td align="left">对指定数组使用forEach循环</td></tr><tr><td><code>itar</code></td><td align="left"><code>for (int i = 0; i &lt; arr.length; i++) &#123;int i1 =arr[i];&#125;</code></td><td align="left">对代码中上一个数组使用普通for循环</td></tr><tr><td><code>ifn</code></td><td align="left"><code>if (xxx == null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>value.null</code></td><td align="left"><code>if (value == null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>inn</code> （if not null）</td><td align="left"><code>if (st != null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>value.nn</code></td><td align="left"><code>if (value == null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>prsf</code></td><td align="left"><code>private static final</code></td><td align="left"></td></tr><tr><td><code>psfi</code></td><td align="left"><code>public static final int</code></td><td align="left"></td></tr><tr><td><code>psfs</code></td><td align="left"><code>public static final String</code></td><td align="left"></td></tr><tr><td><code>psf</code></td><td align="left"><code>public static final</code></td><td align="left"></td></tr><tr><td></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="快捷创建Mybatis主配置文件"><a href="#快捷创建Mybatis主配置文件" class="headerlink" title="快捷创建Mybatis主配置文件"></a>快捷创建Mybatis主配置文件</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130058653.png" alt="image-20200914130058653" style="zoom: 80%;" /><p>填写Name以及文件类型（Extension），并在方框内写入初始代码：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130320437.png" alt="image-20200914130320437"></p><p>Apply，即完成模板设置。</p><p>右键New创建文件时，即可看到创建的模板：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130454583.png" alt="image-20200914130454583" style="zoom:80%;" /><h2 id="版本控制（git）"><a href="#版本控制（git）" class="headerlink" title="版本控制（git）"></a>版本控制（git）</h2><h3 id="克隆GitHub的项目到idea中"><a href="#克隆GitHub的项目到idea中" class="headerlink" title="克隆GitHub的项目到idea中"></a>克隆GitHub的项目到idea中</h3><p>1.先在idea中配置好git安装目录：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817131825434.png" style="zoom: 67%;" /><p>2.添加GitHub账户</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817132350071.png" alt="image-20200817132350071" style="zoom: 67%;" /><p>3.从GitHub上clone仓库：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134058705.png" alt="image-20200817134058705" style="zoom:80%;" /><p>或者：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134723950.png" alt="image-20200817134723950" style="zoom:80%;" /><p>4.填写仓库信息</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134256096.png" alt="image-20200817134256096" style="zoom:80%;" /><p>5.是否为clone的仓库创建新项目，选择yes：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134413600.png" alt="image-20200817134413600" style="zoom:67%;" /><p>后面是创建项目的一些选项，此处省略。</p><p>完成。</p><p>6.clone后，在idea中左侧的项目框右键：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135922566.png" alt="image-20200817135922566" style="zoom:67%;" /><p>即可看到git的各种操作。</p><p>没有add的文件在idea中会显示为红色。</p><h3 id="将本地项目Share到GitHub"><a href="#将本地项目Share到GitHub" class="headerlink" title="将本地项目Share到GitHub"></a>将本地项目Share到GitHub</h3><p>这种方式将会在GitHub创建一个仓库，并将项目push到该仓库。</p><p>步骤：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135325861.png" alt="image-20200817135325861" style="zoom:80%;" /><p>后续步骤简单，省略。</p><h2 id="Idea自带的文件修改历史功能"><a href="#Idea自带的文件修改历史功能" class="headerlink" title="Idea自带的文件修改历史功能"></a>Idea自带的文件修改历史功能</h2><p>右键一个文件-》【Local History】=》【show History】，即可看到文件的修改历史。</p><p>本地历史的相关信息保存在<code>C:\User\.IntelliJIdea2019.3\system\LocalHistory</code>下。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>调试的界面和各种按钮，<strong>鼠标悬停在按钮上可查看快捷键信息</strong>：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141152314.png" alt="image-20200817141152314" style="zoom:80%;" /><p><strong>各种操作的含义</strong>：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817140516654.png" alt="image-20200817140516654" style="zoom: 67%;" /><h3 id="为断点添加条件"><a href="#为断点添加条件" class="headerlink" title="为断点添加条件"></a>为断点添加条件</h3><p>即在该断点停止的条件是满足设置的条件。</p><p>例子：</p><p>创建一个for循环，并在输出语句添加断点：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141741524.png" alt="image-20200817141741524" style="zoom:80%;" /><p>右键断点，在condition中设置条件：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141829128.png" alt="image-20200817141829128" style="zoom:80%;" /><p>启动Debug，停止时i的值是60：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817142010635.png" alt="image-20200817142010635" style="zoom:67%;" /><h3 id="调试过程中查看变量的值"><a href="#调试过程中查看变量的值" class="headerlink" title="调试过程中查看变量的值"></a>调试过程中查看变量的值</h3><p>基本数据类型的值可直接在界面上查看，如上述例子。对于引用类型变量，若要查看具体的属性信息，可将鼠标悬停在变量上，点击<code>+</code>即可查看。</p><h2 id="创建Javadoc文档"><a href="#创建Javadoc文档" class="headerlink" title="创建Javadoc文档"></a>创建Javadoc文档</h2><p>步骤：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817150847896.png" alt="image-20200817150847896" style="zoom:80%;" /><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817151557958.png" alt="image-20200817151557958" style="zoom:67%;" /><p><strong>PS</strong>：命令行参数中，指定的字符集要和项目的字符集一致。</p><h2 id="清除缓存和索引"><a href="#清除缓存和索引" class="headerlink" title="清除缓存和索引"></a>清除缓存和索引</h2><p>IDEA首次加载项目时会创建索引。</p><p>IntelliJ IDEA的缓存和索引<strong>主要是用来加快文件查询， 从而加快各种查找、代码提示等操作的速度</strong>。但是， IntelliJ IDEA的索引和缓存并不是一直会良好地支持IntelliJ IDEA的，某些特殊条件下， IntelliJ IDEA的缓存和索引文件也是会损坏的， 比如：断电、蓝屏引起的强制关机， 当你重新打开IntelliJ IDEA， 很可能Intell IDEA会报各种莫名其妙错误。这种情况可以清理下缓存和索引。如下：</p><p>【File】-》【Invalidate cache/Restart】，选择invalidate and restart。</p><p>或者将<code>C:\User\.IntelliJIdea2019.3\system</code>文件删除（需要idea先关闭），并再次启动idea，等待其重新创建索引即可。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="下载maven导入jar包的源码和依赖"><a href="#下载maven导入jar包的源码和依赖" class="headerlink" title="下载maven导入jar包的源码和依赖"></a>下载maven导入jar包的源码和依赖</h3><p>点击右侧边栏的maven，如图：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215147737.png" alt="image-20200820215147737" style="zoom:80%;" /><p>选择<code>Download Sources</code>下载源码的jar包；选择<code>Download Documentation</code>下载说明文档（javadoc文件）；或者两者都下载。</p><p>打开maven的仓库目录，按下图找到对应目录：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215358815.png" alt="image-20200820215358815" style="zoom: 80%;" /><p>如该图中到仓库下的<code>com\google\protobuf\protobuf-java\3.11.4</code>目录下，可看见下载的javadoc和sources的jar包。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215629801.png" alt="image-20200820215629801" style="zoom: 80%;" /><h3 id="maven项目构建可执行jar包（包含导入的依赖）"><a href="#maven项目构建可执行jar包（包含导入的依赖）" class="headerlink" title="maven项目构建可执行jar包（包含导入的依赖）"></a>maven项目构建可执行jar包（包含导入的依赖）</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/dzblog/p/6913809.html">https://www.cnblogs.com/dzblog/p/6913809.html</a></p></blockquote><ol><li><p>pom.xml文件中配置插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此处指定main方法入口的class --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>包含main方法的入口类全限定名<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>执行package命令：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924215425450.png" alt="image-20200924215425450"></p></li><li><p>在target目录下即可看见项目的包含依赖的可执行jar包。</p></li></ol><blockquote><p>不包含依赖、包含部分依赖的打包方式见参考链接。</p></blockquote><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该笔记基于IDEA-2019版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;提高运行速度&quot;&gt;&lt;a href=&quot;#提高运行速度&quot; class=&quot;headerlink&quot; title=&quot;提高运行速度&quot;&gt;&lt;/a&gt;提高运行速度&lt;/h2&gt;&lt;p&gt;在id</summary>
      
    
    
    
    <category term="IDEA" scheme="http://example.com/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="http://example.com/Tag/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷键大全</title>
    <link href="http://example.com/2021/08/30/IDEA/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2021/08/30/IDEA/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</id>
    <published>2021-08-30T05:02:36.864Z</published>
    <updated>2021-08-30T05:03:01.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下绝大部分copy自：<a href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p></blockquote><h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><strong><span style="color:red;">Ctrl + F</span></strong></td><td align="left">在当前文件进行文本查找 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + R</td><td align="left">在当前文件进行文本替换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Z</td><td align="left">撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Y</td><td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + X</td><td align="left">剪切光标所在行 或 剪切选择内容</td></tr><tr><td align="left">Ctrl + C</td><td align="left">复制光标所在行 或 复制选择内容</td></tr><tr><td align="left">Ctrl + D</td><td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + W</td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + E</td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left">Ctrl + N</td><td align="left">根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td align="left">Ctrl + G</td><td align="left">在当前文件跳转到指定行处</td></tr><tr><td align="left">Ctrl + J</td><td align="left">插入自定义动态代码模板</td></tr><tr><td align="left">Ctrl + P</td><td align="left">方法参数提示显示</td></tr><tr><td align="left">Ctrl + Q</td><td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td align="left">Ctrl + U</td><td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td align="left">Ctrl + B</td><td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td align="left">Ctrl + K</td><td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + T</td><td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left"><strong>Ctrl + H</strong></td><td align="left"><strong>显示当前类的层次结构</strong></td></tr><tr><td align="left">Ctrl + O</td><td align="left">选择可重写的方法</td></tr><tr><td align="left">Ctrl + I</td><td align="left">选择可继承的方法</td></tr><tr><td align="left">Ctrl + +</td><td align="left">展开代码</td></tr><tr><td align="left">Ctrl + -</td><td align="left">折叠代码</td></tr><tr><td align="left">Ctrl + /</td><td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + [</td><td align="left">移动光标到当前所在代码的花括号开始位置</td></tr><tr><td align="left">Ctrl + ]</td><td align="left">移动光标到当前所在代码的花括号结束位置</td></tr><tr><td align="left">Ctrl + F1</td><td align="left">在光标所在的错误代码出显示错误信息</td></tr><tr><td align="left">Ctrl + F3</td><td align="left">调转到所选中的词的下一个引用位置</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭当前编辑文件</td></tr><tr><td align="left">Ctrl + F8</td><td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td align="left">Ctrl + F9</td><td align="left">执行 Make Project 操作</td></tr><tr><td align="left">Ctrl + F11</td><td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td align="left">Ctrl + F12</td><td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td align="left">Ctrl + Enter</td><td align="left">智能分隔行</td></tr><tr><td align="left">Ctrl + End</td><td align="left">跳到文件尾</td></tr><tr><td align="left">Ctrl + Home</td><td align="left">跳到文件头</td></tr><tr><td align="left">Ctrl + Space</td><td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Delete</td><td align="left">删除光标后面的单词或是中文句</td></tr><tr><td align="left">Ctrl + BackSpace</td><td align="left">删除光标前面的单词或是中文句</td></tr><tr><td align="left">Ctrl + 1,2,3…9</td><td align="left">定位到对应数值的书签位置</td></tr><tr><td align="left">Ctrl + 左键单击</td><td align="left">在打开的文件标题上，弹出该文件路径</td></tr><tr><td align="left">Ctrl + 光标定位</td><td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td align="left">Ctrl + 左方向键</td><td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td align="left">Ctrl + 右方向键</td><td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td align="left">Ctrl + 前方向键</td><td align="left">等效于鼠标滚轮向前效果</td></tr><tr><td align="left">Ctrl + 后方向键</td><td align="left">等效于鼠标滚轮向后效果</td></tr></tbody></table><h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + `</td><td align="left">显示版本控制常用操作菜单弹出层</td></tr><tr><td align="left">Alt + Q</td><td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td align="left">Alt + F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left">Alt + F2</td><td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td align="left">Alt + F3</td><td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td align="left">Alt + F7</td><td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td align="left">Alt + F8</td><td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td align="left">Alt + Home</td><td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td></tr><tr><td align="left">Alt + Enter</td><td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td></tr><tr><td align="left">Alt + Insert</td><td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td align="left">Alt + 左方向键</td><td align="left">按左方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 右方向键</td><td align="left">按右方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 前方向键</td><td align="left">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td align="left">Alt + 后方向键</td><td align="left">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td align="left">Alt + 1,2,3…9</td><td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Shift + F1</td><td align="left">如果有外部文档可以连接外部文档</td></tr><tr><td align="left">Shift + F2</td><td align="left">跳转到上一个高亮错误 或 警告位置</td></tr><tr><td align="left">Shift + F3</td><td align="left">在查找模式下，查找匹配上一个</td></tr><tr><td align="left">Shift + F4</td><td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td align="left">Shift + F6</td><td align="left">对文件 / 文件夹 重命名</td></tr><tr><td align="left">Shift + F7</td><td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">Shift + F8</td><td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td></tr><tr><td align="left">Shift + F9</td><td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td></tr><tr><td align="left">Shift + F10</td><td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td></tr><tr><td align="left">Shift + F11</td><td align="left">弹出书签显示层</td></tr><tr><td align="left">Shift + Tab</td><td align="left">取消缩进</td></tr><tr><td align="left">Shift + ESC</td><td align="left">隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td align="left">Shift + End</td><td align="left">选中光标到当前行尾位置</td></tr><tr><td align="left">Shift + Home</td><td align="left">选中光标到当前行头位置</td></tr><tr><td align="left">Shift + Enter</td><td align="left">在当前行的下一行另起新行</td></tr><tr><td align="left">Shift+Alt+Enter</td><td align="left">在当前行的上一行另起新行</td></tr><tr><td align="left">Shift + 左键单击</td><td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr><tr><td align="left">Shift + 滚轮前后滚动</td><td align="left">当前文件的横向滚动轴滚动</td></tr></tbody></table><h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><strong><span style="color:red;">Ctrl + Alt + L</span></strong></td><td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + O</td><td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + I</td><td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td align="left">Ctrl + Alt + T</td><td align="left">对选中的代码弹出环绕选项弹出层</td></tr><tr><td align="left">Ctrl + Alt + J</td><td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td></tr><tr><td align="left">Ctrl + Alt + H</td><td align="left">调用层次</td></tr><tr><td align="left">Ctrl + Alt + B</td><td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td align="left">Ctrl + Alt + V</td><td align="left">快速引进变量</td></tr><tr><td align="left">Ctrl + Alt + Y</td><td align="left">同步、刷新</td></tr><tr><td align="left">Ctrl + Alt + S</td><td align="left">打开 IntelliJ IDEA 系统设置</td></tr><tr><td align="left">Ctrl + Alt + F7</td><td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td align="left">Ctrl + Alt + F11</td><td align="left">切换全屏模式</td></tr><tr><td align="left">Ctrl + Alt + Enter</td><td align="left">光标所在行上空出一行，光标定位到新行</td></tr><tr><td align="left">Ctrl + Alt + Home</td><td align="left">弹出跟当前文件有关联的文件弹出层</td></tr><tr><td align="left">Ctrl + Alt + Space</td><td align="left">类名自动完成</td></tr><tr><td align="left">Ctrl + Alt + 左方向键</td><td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 右方向键</td><td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 前方向键</td><td align="left">在查找模式下，跳到上个查找的文件</td></tr><tr><td align="left">Ctrl + Alt + 后方向键</td><td align="left">在查找模式下，跳到下个查找的文件</td></tr></tbody></table><h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + F</td><td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + R</td><td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + J</td><td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Z</td><td align="left">取消撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + W</td><td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + N</td><td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + U</td><td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + T</td><td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td align="left">Ctrl + Shift + C</td><td align="left">复制当前文件磁盘路径到剪贴板</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">显示最近修改的文件列表的弹出层</td></tr><tr><td align="left">Ctrl + Shift + H</td><td align="left">显示方法层次结构</td></tr><tr><td align="left">Ctrl + Shift + B</td><td align="left">跳转到类型声明处</td></tr><tr><td align="left">Ctrl + Shift + I</td><td align="left">快速查看光标所在的方法 或 类的定义</td></tr><tr><td align="left">Ctrl + Shift + A</td><td align="left">查找动作 / 设置</td></tr><tr><td align="left">Ctrl + Shift + /</td><td align="left">代码块注释 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + [</td><td align="left">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + ]</td><td align="left">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + +</td><td align="left">展开所有代码</td></tr><tr><td align="left">Ctrl + Shift + -</td><td align="left">折叠所有代码</td></tr><tr><td align="left">Ctrl + Shift + F7</td><td align="left">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td align="left">Ctrl + Shift + F8</td><td align="left">在 Debug 模式下，指定断点进入条件</td></tr><tr><td align="left">Ctrl + Shift + F9</td><td align="left">编译选中的文件 / 包 / Module</td></tr><tr><td align="left">Ctrl + Shift + F12</td><td align="left">编辑器最大化</td></tr><tr><td align="left">Ctrl + Shift + Space</td><td align="left">智能代码提示</td></tr><tr><td align="left">Ctrl + Shift + Enter</td><td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Backspace</td><td align="left">退回到上次修改的地方</td></tr><tr><td align="left">Ctrl + Shift + 1,2,3…9</td><td align="left">快速添加指定数值的书签</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 前方向键</td><td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td align="left">Ctrl + Shift + 后方向键</td><td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + Shift + N</td><td align="left">选择 / 添加 task</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">显示添加到收藏夹弹出层</td></tr><tr><td align="left">Alt + Shift + C</td><td align="left">查看最近操作项目的变化情况列表</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">添加到收藏夹</td></tr><tr><td align="left">Alt + Shift + I</td><td align="left">查看项目当前文件</td></tr><tr><td align="left">Alt + Shift + F7</td><td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td align="left">Alt + Shift + F9</td><td align="left">弹出 <code>Debug</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + F10</td><td align="left">弹出 <code>Run</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + 左键双击</td><td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td align="left">Alt + Shift + 前方向键</td><td align="left">移动光标所在行向上移动</td></tr><tr><td align="left">Alt + Shift + 后方向键</td><td align="left">移动光标所在行向下移动</td></tr></tbody></table><h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + Alt + V</td><td align="left">无格式黏贴</td></tr><tr><td align="left">Ctrl + Shift + Alt + N</td><td align="left">前往指定的变量 / 方法</td></tr><tr><td align="left">Ctrl + Shift + Alt + S</td><td align="left">打开当前项目设置</td></tr><tr><td align="left">Ctrl + Shift + Alt + C</td><td align="left">复制参考信息</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">F2</td><td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td></tr><tr><td align="left">F3</td><td align="left">在查找模式下，定位到下一个匹配处</td></tr><tr><td align="left">F4</td><td align="left">编辑源</td></tr><tr><td align="left">F7</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">F8</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">F9</td><td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">F11</td><td align="left">添加书签</td></tr><tr><td align="left">F12</td><td align="left">回到前一个工具窗口</td></tr><tr><td align="left">Tab</td><td align="left">缩进</td></tr><tr><td align="left">ESC</td><td align="left">从工具窗口进入代码文件窗口</td></tr><tr><td align="left">连按两次Shift</td><td align="left">弹出 <code>Search Everywhere</code> 弹出层</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以下绝大部分copy自：&lt;a href=&quot;https://blog.csdn.net/qq_38963960/article/details/89552704&quot;&gt;https://blog.csdn.net/qq_38963960/article/d</summary>
      
    
    
    
    <category term="IDEA" scheme="http://example.com/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="http://example.com/Tag/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA常用快捷键&amp;操作</title>
    <link href="http://example.com/2021/08/30/IDEA/idea%E5%B8%B8%E7%94%A8/"/>
    <id>http://example.com/2021/08/30/IDEA/idea%E5%B8%B8%E7%94%A8/</id>
    <published>2021-08-30T05:02:36.861Z</published>
    <updated>2021-08-30T05:02:53.389Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;</p><ul><li>ctrl+w：逐渐向外层选中</li><li>CTRL+shift+上下：当前行上下移</li><li>SHIFT+F10：运行main</li><li>CTRL+F2：停止运行</li><li>shift+esc：关闭下方窗口</li><li>CTRL+shift+左右：跳转至上/下一个方法（上/下一个历史光标位置）</li><li>CTRL+F12：弹出窗口形式查看当前类的所有方法</li><li>Alt+7：左边小窗口查看当前类所有方法</li><li>SHIFT + F2：定位到报错处（红线）</li><li>CTRL + R：替换指定文本。</li><li>SHIFT + F6：批量修改变量、方法名。</li><li>CTRL + ALT + V：抽取变量（<strong>已改为ALT + X</strong>）</li><li>CTRL + ALT + B/左键：方法具体实现</li><li>CTRL + ALT + M：将选中代码提取为方法</li><li>CTRL + ALT + P：抽取为方法参数，并修改方法被引用的地方</li><li>ALT + 1：打开Project 窗口。</li><li>CTRL + E：最近文件窗口。</li><li>CTRL + P：方法、构造器参数提示。</li><li>ALT + F7：查看指定方法/变量等被引用的次数和位置。</li></ul><p>&emsp;&emsp;</p><ul><li><p>debug时，下方的Frames窗口对应虚拟机栈，其中每个项就是一个栈帧（对应一个方法），右边的Variables对应该栈帧的局部变量表。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209202217531.png" alt="image-20210209202217531"></p></li><li><p>多个线程下调试时，右键断电，选择Thread</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212458998.png" alt="image-20210209212458998"></p><p>此时在此时选择线程：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212821981.png" alt="image-20210209212821981"></p></li><li><p>debug过程可以修改变量的值：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210222235056874.png" alt="image-20210222235056874"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ctrl+w：逐渐向外层选中&lt;/li&gt;
&lt;li&gt;CTRL+shift+上下：当前行上下移&lt;/li&gt;
&lt;li&gt;SHIFT+F10：运行main&lt;/li&gt;
&lt;li&gt;CTRL+F2：停止运行&lt;/li&gt;
&lt;li&gt;shift+esc</summary>
      
    
    
    
    <category term="IDEA" scheme="http://example.com/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="http://example.com/Tag/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>网络总结</title>
    <link href="http://example.com/2021/08/25/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/08/25/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</id>
    <published>2021-08-25T06:06:50.450Z</published>
    <updated>2021-08-30T05:00:30.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是“网络协议”？"><a href="#什么是“网络协议”？" class="headerlink" title="什么是“网络协议”？"></a>什么是“网络协议”？</h2><p>计算机网络中的数据交换<strong>必须遵守事先约定好的规则</strong>。<strong>这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）</strong>。<strong>网络协议</strong>（Network Protocol），简称为协议，<strong>是为进行网络中的数据交换而建立的规则、标准或约定</strong>。</p><p><strong>网络协议的三要素</strong> </p><ul><li><strong>语法</strong>  数据与控制信息的结构或格式</li><li><strong>语义</strong>  控制信息的意义，需要发出何种控制信息，完成何种动作以及做出何种响应。</li><li><strong>同步</strong>  事件实现顺序的详细说明。</li></ul><h2 id="分层网络模型"><a href="#分层网络模型" class="headerlink" title="分层网络模型"></a>分层网络模型</h2><h3 id="为什么分层？"><a href="#为什么分层？" class="headerlink" title="为什么分层？"></a>为什么分层？</h3><p><strong>分层的目的就是为了将困难的问题简单化</strong>，并且如果分层了，在使用的时候就<strong>可以仅仅关注需要关注的层次，而不用理会其他层</strong>。如果需要改动设计的时候，只需要把变动的层替换即可，并不用涉及到其他的层次。</p><h3 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h3><p>OSI的七层协议体系结构概念清楚，理论完整<strong>但复杂且不实用</strong>。<strong>TCP/IP是四层的体系结构：应用层、运输层网际层和网络接口层</strong>。<strong>但</strong>最下面的网络接口层并没有具体内容。因此往往采取折中的办法，即<strong>综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构</strong>。</p><p><strong>OSI、TCP/IP、五层协议结构的图示</strong>：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200405153045896.png" alt="image-20200405153045896"></p><p><strong>每一层向上一层提供服务，且对上层是透明的，同时每一层会使用其下一层的服务</strong>。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层决定了向用户提供应用服务时通信的活动</strong>。</p><p>应用层位于最上层，电脑或⼿机使用的应用软件都是在应用层实现。<strong>应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的</strong>，就类似于，我们寄快递的时候， 只需要把包裹交给快递员，由他负责运输快递，我们不需要关⼼快速是如何被运输的。<br>⽽且应用层是⼯作在操作系统中的用户态，传输层及以下则工作在内核态。</p><p>应用层的协议有 HTTP、SMTP、FTP、DNS 等。</p><p><strong>应用层交互的数据单元称为报文</strong>（message）。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>DNS，Domain Name System，即域名系统。</p><p><strong>其主要任务是将域名映射为对应的 IP 地址。DNS 协议运行在 UDP 之上</strong>，使用 <strong>53 号端口</strong> 。DNS 通常是<strong>被其他应用层协议所使用</strong>的，包括 HTTP 、 SMTP 和 FTP。</p><p>DNS 是：</p><p>①一个由分层的 DNS 服务器（DN server）实现的<strong>分布式数据库</strong> ; 分布式数据库是指，<strong>每个站点只保留它自己的那部分数据</strong>。</p><p>②一个使得主机能够查询分布式数据库的应用层协议。</p><blockquote><p>DNS 还包括其他功能。</p></blockquote><h4 id="DNS-服务器层级关系"><a href="#DNS-服务器层级关系" class="headerlink" title="DNS 服务器层级关系"></a>DNS 服务器层级关系</h4><p>域名具有层次结构，从上到下依次为：根域名（<code>.</code>）、顶级域名（<code>com/cn/edu/gov</code>）、二级域名（<code>google/baidu/att</code>）。</p><p>DNS 系统包含了大量的 DNS 服务器，它们以层次方式组织，对应着域名的层次可以分为：</p><ul><li><p><strong>根 DNS 服务器</strong>。根据域名的顶级域（com、cn 等）映射到对应的顶级域 DNS 服务器。</p></li><li><p><strong>顶级域（Top-Level Domain，TLD） DNS 服务器</strong>。这些服务器负责顶级域名如 com 、 org 、 net 、 edu 和 gov ，将域名映射到对应的权威 DNS 服务器。</p></li><li><p><strong>权威 DNS 服务器</strong>。这些服务器上真正<strong>保存了主机名到 IP 地址的映射</strong>。在因特网上具有公共可访问主机的每个组织机构需要有一个权威 DNS 服务器，<strong>服务器里保存了该组织内主机的 DNS 记录</strong>。</p><blockquote><p>或者支付费用，让这些记录存储在某个服务提供商的一个权威 DNS 服 务器中。</p></blockquote></li></ul><p>它们的层级关系如图：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210429122112026.png" alt="image-20210429122112026" style="zoom:80%;" /><p>还有一类重要的 DNS 服务器称为<strong>本地 DNS 服务器</strong>。它不在上述的层级体系中。</p><p>每个 ISP (如一 个大学、一个系、一个公司或一个居民区的 ISP) 都有一台本地 DNS 服务器(也叫默认名字服务器) 。本地 DNS 服务器<strong>通常“邻近”本主机</strong>，比如在同一个局域网、或距离（物理距离）近、或只需几次的路由跳转。<strong>当主机发出 DNS 请求时，该请求会被发往本地 DNS 服务器，它起着代理的作用，将该请求转发到 DNS 服务器层次结构中，并把结果返回给主机</strong>。</p><h4 id="DNS-工作过程"><a href="#DNS-工作过程" class="headerlink" title="DNS 工作过程"></a>DNS 工作过程</h4><p>假设请求主机想知道域名 <code>abc.cs.school.edu</code> 对应的 IP 地址，DNS 解析过程如下：</p><ul><li><p>主机向本地 DNS 服务器发送一个 DNS 查询报文。</p></li><li><p>本地 DNS 服务器收到请求后，会先<strong>检查是否有 <code>abc.cs.school.edu</code> 对应的缓存</strong>，有则返回；否则将发送查询报文至根 DNS 服务器。</p></li><li><p>根 DNS 服务器<strong>向本地 DNS 服务器返回</strong>对应的顶级域 DNS 服务器（<code>edu</code>）的 IP 地址。</p></li><li><p>本地 DNS 服务器继续发送查询报文至顶级域 DNS 服务器（<code>edu</code>）。</p></li><li><p>顶级域 DNS 服务器（<code>edu</code>）<strong>向本地 DNS 服务器返回对应权威 DNS 服务器（<code>school.edu</code>）的 IP 地址</strong>。</p></li><li><p>本地 DNS 服务器再次发送查询报文至权威 DNS 服务器（<code>school.edu</code>），权威 DNS 服务器向本地 DNS 服务器发送 <code>abc.cs.school.edu</code> 对应的 IP 地址。</p><blockquote><p>若二级域名 <code>school</code> 包含多个子域（比如大学里的每个系都有一个权威 DNS 服务器），那么权威 DNS 服务器（<code>school.edu</code>）还需要向本地 DNS 服务器发送对应的权威 DNS 服务器（<code>cs.school.edu</code>）的 IP 地址，然后本地 DNS 服务器需要再次向权威 DNS 服务器（<code>cs.school.edu</code>）发送查询，权威 DNS 服务器（<code>cs.school.edu</code>）最终才返回 <code>abc.cs.school.edu</code> 对应的 IP 地址。</p></blockquote></li><li><p>本地 DNS 服务器把 IP 地址响应回主机，并存在缓存中，结束。</p></li></ul><p>图示：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210429162429610.png" alt="image-20210429162429610" style="zoom:80%;" /><p>可以看到本地 DNS 服务器起着代理的作用，将该请求转发到 DNS 服务器层次结构中，最后把得到的结果返回给主机。</p><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><p>本地 DNS 服务器获取一个域名的 IP 地址后，会存入本地缓存，下次主机请求该域名时，直接返回缓存的 IP 地址即可。<strong>缓存在一段时间后会失效</strong>。</p><p>另外，本地 DNS 服务器<strong>还可以缓存顶级域 DNS 服务器的 IP 地址</strong>，所以允许本地 DNS 服务器绕过根 DNS 服务器。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>运输层的任务就是<strong>负责向两台主机中的<font color="red">进程之间</font>的通信提供通用的数据传输服务。应用层的进程利用该服务传送应用层报文</strong>。</p><p>运输层有<strong>复用和分用</strong>的功能：复用就是<strong>多个应用层进程可同时使用运输层的服务</strong>；分用和复用相反，是运输层<strong>把收到的信息分别交付上面应用层中的相应进程</strong>。</p><p>运输层主要使用以下两种协议：</p><ul><li><p><strong>传输控制协议 TCP</strong>（Transmission Control Protocol） 提供面向连接的、可靠的数据传输服务。应用层要传输的数据可能会比较大，如果直接传输会不好控制，所以当传输层的数据包大于 <strong>MSS（TCP 最大报文段长度）</strong>时，就要将数据包分段传输，<strong>这样即使中途有⼀个分块丢失或损坏了，只需要重新这⼀个分块，⽽不用重新发送整个数据包</strong>。每个分块就是一个<strong>报文段</strong>（segment）。</p><p>⼀台设备上可能会有很多应用在接收或者传输数据，因此需要用⼀个编号将应用区分开来，这个编号就是<strong>端⼝</strong>。接收方可以根据端口号识别出该报⽂是发送给哪个应用。</p></li><li><p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是<strong>用户数据报</strong>。</p></li></ul><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><h3 id="为什么需要运输层"><a href="#为什么需要运输层" class="headerlink" title="为什么需要运输层"></a>为什么需要运输层</h3><p><strong>IP层的IP地址只是标识了两台主机，只能实现两个主机间的通信，而真正进行通信的是两个主机中的实体（进程），运输层通过端口来标识主机中的进程，实现进程间的通信</strong>。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP，User Datagram Protocol，用户数据报协议。</p><p><strong>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能， 这就是复用分用的功能以及差错检测的功能</strong>。UDP的主要特点是：</p><ul><li><strong>无连接</strong>。即发送数据之前不用建立连接。</li><li>UDP使用<strong>尽最大努力交付</strong>。</li><li>UDP是<strong>面向报文</strong>的。即应用层交下来的报文，UDP既不合并，也不拆分，只加上UDP首部后直接发送；相应的，接收时去除首部后直接上交应用层。</li><li><strong>没有拥塞控制</strong>。即网络的拥塞不会使源主机发送速率降低。但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信）</li><li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li>首部开销小，8B。</li></ul><h3 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h3><p>TCP，Transmission Control Protocol，传输控制协议。</p><p>TCP的主要特点：</p><ul><li><strong>面向连接</strong>。即使用tcp之前（通信之前）需要建立可靠连接，通信完毕后释放连接。</li><li>每一个TCP连接<strong>只能有两个端点</strong>。<ul><li>TCP连接的端点叫做<strong>套接字（socket）</strong>，一个套接字<strong>由<code>IP地址:端口号</code>组成</strong>。<strong>一个TCP连接由两个套接字唯一确定</strong>。</li></ul></li><li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据， <strong>无差错、不丢失、不重复，并且按序到达</strong>。</li><li>TCP提供<strong>全双工通信</strong>。TCP允许<strong>通信双方的应用进程在任何时候都能发送数据</strong>。<ul><li><strong style="color:red">TCP连接的两端都设有发送缓存和接收缓存， 用来临时存放双向通信的数据</strong>。<strong>在发送时，应用程序在把数据传送给TCP的缓存后， 就可以做自己的事， 而TCP在合适的时候把数据发送出去。在接收时， TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</strong>。</li></ul></li><li><strong>面向字节流</strong>。<strong style="color:red">TCP中的“流”(stream) 指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块(<strong>大小不等</strong>) ， 但TCP把应用程序交下来的数据<strong>仅仅看成是一连串的无结构的字节流</strong>。TCP并不知道所传送的字节流的含义。TCP<strong>不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</strong>。<strong>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</strong>。</li></ul><h3 id="TCP可靠传输原理"><a href="#TCP可靠传输原理" class="headerlink" title="TCP可靠传输原理"></a>TCP可靠传输原理</h3><p>（来自JavaGuide）</p><p>概述：</p><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待协议的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组</strong>。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 简单</li><li><strong>缺点：</strong> 信道利用率低，等待时间长</li></ul><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就<strong>重传前面发送过的分组</strong>（认为刚才发送过的分组丢失了）。因此<strong>每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些</strong>。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。</p><p><strong>若收到重复分组，就丢弃该分组，但同时还要发送确认</strong>。<strong>连续 ARQ 协议</strong> 可提高信道利用率。</p><p><strong>3) 确认丢失和确认迟到</strong>                   </p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下<strong>两点措施</strong>：<strong>1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。</strong> </li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。<strong>处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1</strong>。</li></ul><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。<strong>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</strong>。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> <strong>不能向发送方反映出接收方已经正确收到的所有分组的信息</strong>。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul><h4 id="滑动窗口实现流量控制"><a href="#滑动窗口实现流量控制" class="headerlink" title="滑动窗口实现流量控制"></a>滑动窗口实现流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率</strong>。将窗口字段设置为 0，则发送方不能发送数据。</p><p>​    </p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫<strong>拥塞</strong>。<strong>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载</strong>。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><blockquote><p>cwnd指拥塞窗口长度</p></blockquote><ul><li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是<strong>先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。<strong>每当出现超时的时候重新开始发送时即使用慢开始</strong>。</p></li><li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是<strong>让拥塞窗口cwnd缓慢增大</strong>，即每经过一个往返时间RTT就把发送放的cwnd加1。</p></li><li><p><strong>快重传与快恢复（fast retransmit and recovery，FRR）</strong>：采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。<strong>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认（这里已收到的报文段是指失序段之前的报文段）</strong>。</p><p>如图（来自《计算机网络》所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3；但却收到了M4。本来接收方可以什么都不做。<strong>但按照快重传算法，接收方必须立即发送对M2的重复确认（注意是M2）</strong>，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送Ms和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M的确认，其中后3个都是重复确认。<strong>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞</strong>。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210307172719911.png" alt="image-20210307172719911"></p><p>相应的，<strong>发送方知道只是丢失个别报文段，重新发送数据时不会启动慢开始，而是执行快恢复算法，即适当调整cwnd大小</strong>（如除以2），并执行拥塞避免。</p></li></ul><h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308171503072.png" alt="image-20210308171503072"></p><p>其中部分字段含义：</p><ul><li>序号（seq）。TCP 是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。<strong>序号字段值指的是本报文段所发送的数据的第一个字节的序号</strong>。</li><li>确认号（ack）。<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为 N ，则标识序号 1 ~ N-1 的字节都已正确收到。</li><li>确认 ACK （控制位） 。<strong>仅当ACK=1时确认号字段才有效</strong>。当ACK=0时， 确认号无效。TCP规定，<strong>在连接建立后所有传送的报文段都必须把ACK置1</strong>。</li><li>同步 SYN （控制位）。<strong>在连接建立时用来同步序号</strong>。<strong>当SYN=1而ACK=0时，表明这是一个连接请求报文段</strong>。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此， <strong>SYN置为1就表示这是一个连接请求或连接接受报文</strong>。</li><li>终止 FIN （控制位）。用来释放一个连接。<strong>当FIN=1时， 表明此报文段的发送方的数据已发送完毕，并要求释放运输连接</strong>。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>《计算机网络 第7版》中称为“三报文握手”。</p><p>图片来自《计算机网络 第7版》</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308162534931.png" alt="image-20210308162534931"></p><p> A 为客户端，B 为服务器端。</p><blockquote><p>ack 指确认号字段，ACK 是6个控制位之一。</p></blockquote><ul><li><strong>首先 B 处于 LISTEN（监听）状态</strong>，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，（同步字段）SYN=1，（ACK=0），<strong>选择一个初始的序号 x</strong>，即 <code>SYN=1, seq=x</code> 。</li><li>B 收到连接请求报文，<strong>如果同意建立连接，则向 A 发送连接确认报文</strong>，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。即 <code>SYN=1, ACK=1, seq=y, ack=x+1</code> 。</li><li><strong>A 收到 B 的连接确认报文后，还要向 B 发出确认</strong>，确认号为 y+1，序号为 x+1。即 <code>ACK=1, ack=y+1, seq=x+1</code> 。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong style="color:red">为什么需要最后一次握手（确认）？</strong> </p><p><strong>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</strong>。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求若最后还是到达了服务器，<strong>如果不进行三次握手</strong>，那么服务器就会打开两个连接。<strong>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，服务器接不到确认也就不会打开连接</strong>。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308164017342.png" alt="image-20210308164017342"></p><ul><li>A 发送连接释放报文，FIN=1，并停止发送数据。 <code>FIN=1, seq=u</code> 。<strong>A进入“终止等待状态1”</strong>。</li><li>B 收到之后发出确认：<code>ACK=1, ack=u+1, seq=v</code> 。<strong>此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</strong>，即从 A -》B 这个方向的连接释放了。<strong>此时 B 进入“关闭等待”状态</strong></li><li>A收到确认后，<strong>进入“终止等待状态2”。等待B的连接释放报文段</strong>。</li><li><strong>B 发出确认后会发送还没发送完的数据</strong>，当 B 已经没有要向 A 发送的数据时，<strong>发送连接释放报文，FIN=1</strong>。 <code>FIN=1, ACK=1, seq=w, ack=u+1</code> 。<strong>B 进入“最后确认”状态</strong>。</li><li>A 收到后发出确认： <code>ACK=1, seq=u+1, ack=w+1</code> ，<strong>进入 TIME-WAIT （时间等待）状态，此时连接还没有释放，A 会等待 2 MSL（Maximum Segment Lifetime，最大报文存活时间）后释放连接</strong>。</li><li><strong>B 收到 A 的确认后释放连接</strong>。</li></ul><p>客户端接收到服务器端的 FIN 报文后还需要等待一个时间计时器设置的时间 2MSL。<strong>这么做有两个理由</strong>：</p><ul><li><strong>确保最后一个确认报文能够到达</strong>。如果 B 没收到 A 发送来的确认报文，会超时重传连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生，这时 A 会重新发送确认报文，<strong>并将计时重新设置为 2 MSL</strong>。</li><li>等待一段时间是为了<strong>让本连接持续时间内所产生的所有报文都从网络中消失使得下一个新的连接不会出现旧的连接请求报文，如已失效的连接请求报文段</strong>。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层负责<strong>为<font color="red">主机之间</font>提供通信服务</strong>。<strong>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送，即网络层的数据单元是分组或包</strong>。</p><p><strong>网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机</strong>。与对方计算机之间通过多台计算机或网络设备进行传输时，<strong>网络层所起的作用就是在众多的选项内选择一条传输路线</strong>。</p><p>网络层使用的主要协议是 IP 协议。</p><p>另外要注意的是，<strong>运输层并不负责将数据从一个设备传输到另一个设备</strong>，它只作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能由网络层负责。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>路由器在转发分组时，需要知道 IP 地址对应的具体设备，<strong>数据链路层专门用来标识网络中的设备</strong>，它主要为⽹络层提供链路级别传输的服务。</p><p>数据链路层常简称为链路层。在两个相邻结点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息</strong>（如同步信息、地址信息、差错控制等）。</p><p>在接收数据时，<strong>控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束</strong>。这样，<strong>数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层</strong>。</p><p><strong>控制信息还使接收端能够检测到所收到的帧中有无差错</strong>。如发现<strong>有差错</strong>，数据链路层就<strong>丢弃出了差错的帧</strong>，以免浪费网络资源。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>当数据准备要从设备发送到网络时，<strong>需要把数据包转换成电信号，让其可以在物理介质中传输</strong>，这⼀层就是物理层 ，它主要是为数据链路层提供⼆进制传输的服务。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html">运输层</a> </p><p>《计算机网络 第7版》</p><p>《小林coding-图解网络pdf》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是“网络协议”？&quot;&gt;&lt;a href=&quot;#什么是“网络协议”？&quot; class=&quot;headerlink&quot; title=&quot;什么是“网络协议”？&quot;&gt;&lt;/a&gt;什么是“网络协议”？&lt;/h2&gt;&lt;p&gt;计算机网络中的数据交换&lt;strong&gt;必须遵守事先约定好的规则&lt;/stron</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/Tag/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/08/25/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/08/25/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-08-25T06:06:50.430Z</published>
    <updated>2021-08-30T05:00:34.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP-概述"><a href="#1-HTTP-概述" class="headerlink" title="1. HTTP 概述"></a>1. HTTP 概述</h2><p><strong>HTTP，即 Hypertext Transfer Protocol ，超文本传输协议，是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong>。</p><p>HTTP 协议用于客户端和服务器端之间的通信，客户端、服务器端之间通过请求和响应的交换达成通信。</p><p><strong>HTTP 协议是基于 TCP 协议的</strong>。</p><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><p>URI，即<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符，<strong>用来唯一标识某一互联网资源名称的字符串</strong>。</p><p>URL，<strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符，是 URI 是子集，它<strong>可以用来标识和定位一个互联网资源，也可以理解为它是用位置来唯一标识一个资源</strong>。</p><p><strong>HTTP 通过 URL 来标识一个资源</strong>。</p><p>URL 的格式：（来自《图解HTTP》）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210426201533829.png" alt="image-20210426201533829"></p><p>其中，登录信息和片段标识符可选。</p><ul><li><a href="https://www.zhihu.com/question/21950864/answer/154309494">HTTP 协议中 URI 和 URL 有什么区别？-知乎</a> </li></ul><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p><strong>HTTP 是一种<font color="red">无状态协议</font>，HTTP 自身不对通信状态进行保存，也就是说<font color="red">协议对于发送过的请求或响应都不做持久化处理，无法根据之前的状态进行本次的请求处理</font></strong>。这是为了更快地处理大量事务，确保协议的可伸缩性。</p><h3 id="HTTP-1-1-特性"><a href="#HTTP-1-1-特性" class="headerlink" title="HTTP(1.1) 特性"></a>HTTP(1.1) 特性</h3><p>HTTP 最凸出的<strong>优点是「简单、灵活和易于扩展、应用广泛和跨平台」</strong>。</p><p><strong>1.简单</strong> </p><p>HTTP 报文的格式简单，易于理解，学习和使用门槛低。且 HTTP 是无状态的，所以不用使用额外的信息来记录状态。</p><p><strong>2.灵活和易于扩展</strong> </p><p>HTTP 协议的请求方法、状态码、首部字段等的<strong>组成和长度都没有固定要求，开发人员可以进行自定义和扩充</strong>。</p><p><strong>3.应用广泛和跨平台</strong> </p><p>PC 端、移动端的各类软件、APP 都广泛应用 HTTP，HTTP 协议具有天然的跨平台性。</p><p>HTTP 的<strong>缺点</strong>也很明显，就是<strong>无状态和不安全</strong>：</p><ul><li>无状态的特性让 HTTP 更简单的同时，也存在缺点。对于一些需要记录状态的场景，比如登录，购物车等，需要用其他方法来解决，如 Cookie、Session。这会带来额外的开销。</li><li>HTTP/1.1 是明文传输的，这可以为调试带来便利性，但却是毫无安全性的：<ul><li>对于一些账号<strong>密码</strong>，若是用明文传输，很容易就<strong>被窃取</strong>；</li><li>且 HTTP/1.1 不验证通信方的身份，可能遭遇<strong>伪装</strong>；</li><li>无法保证报文的完整性，可能被<strong>篡改</strong>。</li></ul></li></ul><p>另外，HTTP/1.1 <strong>允许同时创建多个 TCP 连接</strong>实现并发和缩短延迟。</p><h2 id="2-代理、网关、隧道"><a href="#2-代理、网关、隧道" class="headerlink" title="2. 代理、网关、隧道"></a>2. 代理、网关、隧道</h2><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>代理是一种有转发功能的应用程序，它扮演了<strong>位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端</strong>。</p><p>代理服务器不会改变请求的 URI ，它会直接把请求发送给源服务器。在 HTTP 通信过程中，可级联多台代理服务器，每经过一台代理服务器，都需要通过 Via 首部字段记录。</p><p>代理服务器的作用：</p><ul><li>缓存。</li><li>访问控制等。</li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作机制跟代理服务器类似，是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。</p><p><strong>网关可以将 HTTP 请求转换为其他协议的通信</strong>。可以在客户端与网关之间的通信线路上加密以确保连接的安全。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行<strong>安全的通信</strong>。</p><h2 id="3-HTTP-报文"><a href="#3-HTTP-报文" class="headerlink" title="3. HTTP 报文"></a>3. HTTP 报文</h2><p>HTTP 报文分为<strong>请求报文和响应报文</strong>。它们的结构如图：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210427003605931.png" alt="image-20210427003605931" style="zoom:80%;" /><ul><li>请求报文和响应报文的起始行不同。</li><li><strong>首部字段有 4 种类型：请求首部字段、响应首部字段、通用首部字段、实体首部字段</strong>。</li><li><strong>报文主体可以为空</strong>。</li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210426235929111.png" alt="image-20210426235929111"></p><p>其中，<strong>请求行的结构是</strong>：<code>请求方法+空格+URL+空格+HTTP版本</code>。</p><p>一个报文示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.example.com/?param1=1&amp;param2=2 HTTP/1.1</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 xxx</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210427000221955.png" alt="image-20210427000221955"></p><p>其中，状态行的结构是：<code>HTTP版本+空格+状态码+状态码描述</code>。</p><p>一个响应报文示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Age: 529651</span><br><span class="line">Cache-Control: max-age=604800</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 648</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class="line">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line">Keep-Alive: timeout=4</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc/16DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class="line">// 省略... </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="4-HTTP-方法"><a href="#4-HTTP-方法" class="headerlink" title="4. HTTP 方法"></a>4. HTTP 方法</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>获取资源。</p><p>GET 方法的请求若带有参数，则是以 <code>@k1=v1&amp;k2=v2...</code> 的方式出现在 URL 中。如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span> /test/demo_form.asp?name<span class="number">1</span>=value<span class="number">1</span>&amp;name<span class="number">2</span>=value<span class="number">2</span> HTTP/<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>传输实体的主体。</p><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p>POST 请求的参数是在实体主体中。如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test/demo_form.asp</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br><span class="line"></span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p>更多 POST 和 GET 的区别：<a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E5%8F%82%E6%95%B0">POST 和 GET 比较</a> </p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p><strong>上传文件</strong>，要求在请求报文的主体中包含文件内容，然后保存到请求 URL 指定的位置。</p><blockquote><p>也可以理解为修改文件，但修改是完全替代原文件的。</p></blockquote><p>HTTP/1.1 的 PUT 方法不带验证机制，任何人都可以上传文件，存在<strong>安全性问题</strong>，所以一般不用该方法。</p><p>若是 Web 应用采用 REST（REpresentational State Transfer，表征状态转移） 架构，则可能开放 PUT 方法。</p><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>对资源进行<strong>部分修改</strong>。</p><p>PUT 也可以用于修改资源，但只能完全替代原始资源，PATCH 允许部分修改。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>获得报文首部。</p><p>HEAD 方法和 GET 方法一样，只是<strong>不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等</strong>。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除文件。DELETE 方法<strong>按请求 URI 删除指定的资源</strong>。</p><p>HTTP/1.1 的 DELETE 一样<strong>不带验证机制</strong>，一般不使用。当配合 Web 应用程序的验证机制，或遵守 REST 标准时有可能开放。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>询问支持的方法。用来询问 <strong>URI 指定的资源支持的方法</strong>。</p><p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p><strong>追踪路径</strong>。服务器会将通信路径返回给客户端。</p><p>发送请求时，在 <strong>Max-Forwards 首部字段中填入数值</strong>，每经过一个服务器就会减 1，当数值<strong>为 0 时就停止传输</strong>，最后接收到请求的服务器端则返回状态码 200 OK 的响应。</p><p>通常不会使用 TRACE，并且它<strong>容易受到 XST 攻击</strong>（Cross-Site Tracing，跨站追踪）。</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p><strong>要求用隧道协议连接代理服务器</strong>。CONNECT 方法<strong>要求在与代理服务器通信时建立隧道</strong>，实现<strong>用隧道协议进行 TCP 通信</strong>。</p><p>主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p>CONNECT 方法的格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONEECT 代理服务器名:port HTTP版本</span><br></pre></td></tr></table></figure><p>一个示例：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210427105409153.png" alt="image-20210427105409153"></p><h2 id="5-HTTP-状态码"><a href="#5-HTTP-状态码" class="headerlink" title="5. HTTP 状态码"></a>5. HTTP 状态码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>状态码告知从服务器端返回的请求结果。借助状态码，客户端可以知道服务器端是正常处理了请求，还是出现了错误。</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><p>以下是一些常见状态码。</p><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200 OK</strong>：最常见的状态码，<strong>表示资源正常处理完成</strong>。</li><li><strong>204 No Content</strong>：请求处理成功，但<strong>没有资源可返回，即返回的响应报文不包含实体的主体部分</strong>。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong>：表示客户端使用 Content-Range 进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p><blockquote><p>永久性重定向表示原 URL 不应再被使用，而应该优先选用新的 URL。</p></blockquote></li><li><p><strong>302 Found</strong> ：临时性重定向</p><blockquote><p>有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问。在这种情况下可以使用临时重定向。</p></blockquote></li><li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p><blockquote><p>虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p></blockquote></li><li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p><blockquote><p><strong>304 虽然被划分在 3XX 类别中，但是和重定向没有关系</strong>。</p></blockquote></li><li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p></li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p></li><li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p><blockquote><p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。</p></blockquote></li><li><p><strong>403 Forbidden</strong> ：请求被拒绝。如没有访问权限等情况。</p></li><li><p><strong>404 Not Found</strong>：资源未找到。</p></li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>5XX 的响应结果表明服务器本身发生错误。</p><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。如抛出异常。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><hr><blockquote><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。 比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种 情况也经常遇到。</p></blockquote><h2 id="6-HTTP-首部字段"><a href="#6-HTTP-首部字段" class="headerlink" title="6. HTTP 首部字段"></a>6. HTTP 首部字段</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>HTTP 首部字段可以<strong>为客户端和服务器的通信提供额外的重要信息</strong>。</p><p>其结构为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名：字段值</span><br></pre></td></tr></table></figure><p>字段值可以一个或多个，且可以是 <code>key=value</code> 的形式。</p><p>示例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Keep-Alive: timeout&#x3D;15, max&#x3D;100</span><br></pre></td></tr></table></figure><p>HTTP 首部字段分为以下 4 种类型。 </p><ul><li><strong>通用首部字段</strong>（General Header Fields）：请求报文和响应报文两方都会使用的首部。 </li><li><strong>请求首部字段</strong>（Request Header Fields）：请求报文中使用的首部字段。</li><li><strong>响应首部字段</strong>（Response Header Fields）：响应报文中使用的首部字段。</li><li><strong>实体首部字段</strong>（Entity Header Fields）：<strong>针对</strong>请求报文和响应报文的<strong>实体部分使用的首部</strong>。</li></ul><p><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E5%9B%9B%E3%80%81http-%E9%A6%96%E9%83%A8">HTTP首部字段总览</a> </p><p>一些常见字段：</p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>Cache-Control</strong></td><td align="center">控制缓存的行为</td></tr><tr><td align="center"><strong>Connection</strong></td><td align="center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="center"><strong>Date</strong></td><td align="center">创建报文的日期时间</td></tr><tr><td align="center"><strong>Via</strong></td><td align="center">代理服务器的相关信息</td></tr></tbody></table><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><ul><li><p><strong>Accept</strong>：通知服务器用户代理<strong>能够处理的媒体类型及媒体类型的相对优先级</strong>。可使用 type/subtype 这种形式，一次指定多种媒体类型。优先级使用 <code>q=N</code> 表示，N 是 0-1 的小数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml;q=<span class="number">0</span>.<span class="number">5</span>,application/xml;q=<span class="number">0</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Accept-Charset</strong>：通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>-Charset: iso-<span class="number">8859</span>-<span class="number">5</span>, unicode-<span class="number">1</span>-<span class="number">1</span>;q=<span class="number">0</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Accept-Encoding</strong>：告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。</p></li><li><p><strong>Accept-Language</strong>：告知服务器用户代理能够处理的自然语言集（指中文或英文等）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>-Language: zh-cn,zh;q=<span class="number">0</span>.<span class="number">7</span>,en-us,en;q=<span class="number">0</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Referer</strong>：告知服务器发起该请求的 URI 。即可以<strong>知道请求是从哪个 Web 页面发起的</strong>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Referer:</span> <span class="attr">http:</span><span class="comment">//www.hackr.jp/index.htm</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Range</strong>：只获取指定资源的指定部分。如下表示请求获取从第 5001 字节至第 10000 字节的资源：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=<span class="number">5001</span><span class="number">-10000</span></span><br></pre></td></tr></table></figure><p>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 <code>206 Partial Content</code> 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及<strong>全部资源</strong>。</p></li><li><p><strong>Max-Forwards</strong>：通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段<strong>指定可经过的服务器最大数目</strong>。每经过一个服务器值减 1 。为 0 时不再进行转发直接返回响应。</p></li><li><p><strong>Host</strong>：请求资源所在服务器。</p></li></ul><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><ul><li><p><strong>Accept-Ranges</strong>：服务器告知客户端自己能否处理范围请求。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes <span class="regexp">//</span> 可以处理</span><br><span class="line">Accept-Ranges: none <span class="regexp">//</span> 不可以处理</span><br></pre></td></tr></table></figure></li><li><p><strong>ETag</strong>：唯一标识一个资源的字符串。</p><p>仅凭 URI 指定缓存的资源不具备唯一性，比如同一个 URI 有中文和英文两个版本。资源被缓存时，就会被分配唯一性标识，以区分资源的不同版本。</p></li><li><p><strong>Location</strong>：令客户端重定向至指定 URI 。基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI 。</p></li><li><p><strong>Server</strong>：告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/<span class="number">2</span>.<span class="number">2</span>.<span class="number">17</span> (Unix)</span><br></pre></td></tr></table></figure></li><li><p><strong>Vary</strong>：该字段可对缓存进行控制，由源服务器发送给缓存服务器。</p><p>代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，比如 <code>Vary: Accept-Language</code>，<strong>若请求指定的 Accept-Language 与缓存一致，则返回该缓存</strong>；否则需要从源服务器获取资源。</p></li></ul><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><ul><li><p><strong>Allow</strong>：资源可支持的 HTTP 方法。</p></li><li><p><strong>Content-Encoding</strong>：实体主体适用的编码方式。</p></li><li><p><strong>Content-Language</strong>：实体主体的自然语言。</p></li><li><p><strong>Content-Length</strong>：实体主体的大小</p></li><li><p><strong>Content-Location</strong>：给出与报文主体部分相对应的 URI 。如访问 <code>http://www.hackr.jp/</code> 返回的对象却是 <code>http://www.hackr.jp/index-ja.html</code> 等情况。</p></li><li><p><strong>Content-Range</strong>：返回响应时使用的首部字段，表示当前发送部分及整个实体大小。</p><p>如下表示资源总大小是 10000 字节，当前发送的是第 5001-10000 个字节。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes <span class="number">5001</span><span class="number">-10000</span>/<span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Content-Type</strong>：实体主体的媒体类型。</p></li><li><p><strong>Expires</strong>：告知资源失效时间。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">04</span> Jul <span class="number">2012</span> <span class="number">08</span>:<span class="number">26</span>:<span class="number">05</span> GMT</span><br></pre></td></tr></table></figure></li><li><p><strong>Last-Modified</strong>：资源的最后修改日期时间。</p></li></ul><h2 id="7-HTTP-的应用"><a href="#7-HTTP-的应用" class="headerlink" title="7. HTTP 的应用"></a>7. HTTP 的应用</h2><p><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#%E4%BA%94%E3%80%81%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8">链接</a> </p><h2 id="8-HTTP-和-HTTPS"><a href="#8-HTTP-和-HTTPS" class="headerlink" title="8. HTTP 和 HTTPS"></a>8. HTTP 和 HTTPS</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>HTTP/1.1 及之前是采用明文传输的，<strong>存在信息被窃取、篡改跟伪造的风险</strong>。</p><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议。如图：（图片来自小林coding）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210428105419529.png" alt="image-20210428105419529" style="zoom:80%;" /><blockquote><p>SSL，Secure Socket Layer，安全套接层协议</p><p>TLS，Transport Layer Secure，传输层安全协议</p></blockquote><p>SSL/TLS 协议提供了以下机制：</p><ul><li><strong>信息加密</strong>：通过混合加密的方式（<strong>对称加密</strong>和<strong>非对称加密</strong>结合）对信息加密。</li><li><strong>校验机制</strong>：防止内容被篡改而无法发现。</li><li><strong>身份证书</strong>：证明自己的身份，<strong>防止身份伪造</strong>。</li></ul><p>这些机制解决了 HTTP/1.0 的安全问题。</p><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ol><li>HTTP 是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 <strong>HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输</strong>。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li><strong>HTTPS 协议需要向 CA（证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。是需要花钱的。</li></ol><h2 id="9-HTTP-的演变"><a href="#9-HTTP-的演变" class="headerlink" title="9. HTTP 的演变"></a>9. HTTP 的演变</h2><h3 id="HTTP-1-0-gt-gt-HTTP-1-1"><a href="#HTTP-1-0-gt-gt-HTTP-1-1" class="headerlink" title="HTTP/1.0 &gt;&gt; HTTP/1.1"></a>HTTP/1.0 &gt;&gt; HTTP/1.1</h3><p>HTTP 初始版本是短连接的，每进行一次通信（一次请求+一次响应）就断开连接。</p><p>HTTP/1.1 使用了长连接和管道传输进行优化。</p><p>但 HTTP/1.1 还是有<strong>性能瓶颈</strong>：</p><ul><li><p>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</p></li><li><p>发送冗长的首部。</p></li><li><p><strong>对于管道传输，客户端可以不用等待响应连续发出多个请求，但服务器需要按请求的顺序返回响应，所以如果前面的请求阻塞住了，那么服务器就不会响应后面的请求，这就是队头阻塞</strong>；</p><p>如果要实现多个请求并发，只能通过创建多个 TCP 连接的方式。这是以<strong>牺牲性能为代价的，且导致 TCP 连接的利用率低下</strong>。</p></li><li><p>没有请求优先级控制；</p></li><li><p><strong>请求只能从客户端开始，服务器只能被动响应</strong>。</p></li></ul><h3 id="HTTP-1-1-gt-gt-HTTP-2"><a href="#HTTP-1-1-gt-gt-HTTP-2" class="headerlink" title="HTTP/1.1 &gt;&gt; HTTP/2"></a>HTTP/1.1 &gt;&gt; HTTP/2</h3><p><strong>HTTP/2 协议是基于 HTTPS 的</strong>，所以 HTTP/2 的安全性也是有保障的。</p><p>HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ol><li><p><strong>头部压缩</strong>。如果同时发出的多个请求的头部字段是一样的或是相似的，那么，协议会<strong>消除重复的字段</strong>。</p><blockquote><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p></blockquote></li><li><p>HTTP/2 的报文<strong>采用二进制的形式</strong>。头信息和数据体都是二进制，并且<strong>统称为帧（frame）：头信息帧和数据帧</strong>。如图：（图片来自小林coding）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210428112049440.png" alt="image-20210428112049440" style="zoom:80%;" /><p><strong>使用二进制对计算机友好</strong>，计算机收到报文后可以直接处理，无需进行解析。</p><p>帧是最小的通信单位，一个请求或响应的所有帧称为一个<strong>数据流</strong>。每个帧需要做标记，指明它属于哪个数据流。</p></li><li><p>在通信过程中，<strong>只会有一个 TCP 连接存在，在这个连接上并发处理多个 HTTP 请求或响应。每个请求或响应对应一个数据流（Stream），来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装</strong>。</p><p>这种方式可以不按顺序处理请求，<strong>避免了队头阻塞的情况</strong>。</p><p>另外，<strong>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</strong>。</p></li><li><p><strong>服务器推送</strong>。HTTP/2 在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送（Server Push，也叫 Cache Push）。</p></li></ol><p>HTTP/2 的缺点：</p><ul><li>HTTP/2 中，多个 HTTP 请求/响应是基于一个 TCP 连接的，所以<strong>当有某个包丢失时，会触发 TCP 的重传机制，这样之后的 TCP 报文段都会被阻塞住，即未处理完的 HTTP 请求/响应阻塞至丢失的包重传完成</strong>。</li><li>客户端和服务端之间<strong>建立连接需要 6 次交互</strong>：TCP 3 次握手 + TLS/1.3 的 3 次握手。</li></ul><h3 id="HTTP-2-gt-gt-HTTP-3"><a href="#HTTP-2-gt-gt-HTTP-3" class="headerlink" title="HTTP/2 &gt;&gt; HTTP/3"></a>HTTP/2 &gt;&gt; HTTP/3</h3><p>HTTP/2 多个请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。这是基于 TCP 的问题，<strong>HTTP/3 把 HTTP 下层 TCP 协议改成了基于 UDP 的 QUIC 协议</strong>，解决了 HTTP/2 丢包阻塞的问题。</p><p>HTTP/1 &gt;&gt; HTTP/3 的演变：（图片来自小林coding）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210428150235411.png" alt="image-20210428150235411" style="zoom:80%;" />\</p><p>UDP 是不可靠传输的，没有 TCP 的重传等机制，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输：</p><ul><li>当某个流发生丢包时，<strong>只会阻塞这个流，其他流不会受到影响</strong>。</li><li>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li><li>QUIC 把 HTTP/2 的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html">CS-Note - CyC2018</a> </li><li>《图解HTTP》</li><li>《小林coding - 图解网络pdf》</li><li><a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">30 张图解 HTTP 常见的面试题 - 小林coding</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-HTTP-概述&quot;&gt;&lt;a href=&quot;#1-HTTP-概述&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP 概述&quot;&gt;&lt;/a&gt;1. HTTP 概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;HTTP，即 Hypertext Transfer Protoc</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/Tag/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-08-25T06:06:50.404Z</published>
    <updated>2021-08-30T04:59:54.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>定义：<strong>在当前进程中，通过单例模式创建的类有且只有一个实例</strong>。</p><p>单例有如下几个特点：</p><ul><li>在Java应用中，单例模式<strong>需要保证在一个JVM中，该对象只有一个实例存在</strong>。</li><li><strong>构造器必须是私有的</strong>，外部类无法通过调用构造器方法创建该实例。</li><li><strong>没有公开的set方法</strong>，外部类无法调用set方法创建该实例。</li><li>提供一个公开的get方法获取唯一的这个实例。</li></ul><p>单例模式的好处：</p><ul><li>某些类创建比较频繁，<strong>对于一些大型的对象，节省很大的系统开销</strong>。</li><li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li><li>系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个，会造成系统混乱。</li><li>避免了对资源的重复占用</li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在<strong>程序启动或单例模式类被首次主动使用的时候</strong>，单例模式实例被创建。<strong>总之，饿汉式体现的是想提前把对象创建好</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式没有线程安全问题，instance是在Singleton类初始化时创建的，JVM可以保证线程安全。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式单例在第一次调用getInstance才创建实例。</p><h3 id="线程不安全实现"><a href="#线程不安全实现" class="headerlink" title="线程不安全实现"></a>线程不安全实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Singleton2.getInstance());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行多次，可以看到获取对象不是同一个。</p><p><strong>应用场景</strong>：如果这个数据是经常访问的热点数据，那我就可以在系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了；反之，数据使用频率较低，则使用懒汉式，避免资源浪费。</p><h3 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h3><p>getInstance加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样能保证线程安全，但是<strong>效率过低，实例被创建后调用getInstance依然需要加锁</strong>。</p><p>通过双检锁（double-checked）做两次判断优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意INSTANCE需要加上<code>volatile</code>关键字，避免指令重排序问题</strong>。<code>INSTANCE = new Singleton();</code>并不是原子操作，JVM可能会先执行赋值操作再执行初始化操作，</p><p>没加volatile时线程不安全的情况：</p><ul><li>A、B同时进入第一个if。</li><li>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</li><li>由于JVM内部的优化机制，JVM可能会<strong style="color:red">先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块</strong>。</li><li>随后B进入synchronized块，由于instance此时不是null，<strong>因此它马上离开了synchronized块并将结果返回给调用该方法的程序</strong>。</li><li>此时若B线程马上使用Singleton实例，<strong>却发现它没有被初始化，于是错误发生了</strong>。</li></ul><p>缺点：<strong>由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高</strong>。</p><p>可以使用静态内部类实现。</p><h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>使用内部类来维护单例的实现，<strong>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的</strong>。</p><h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举来实现单实例控制会更加<strong>简洁，而且JVM从根本上提供保障，绝对防止多次实例化</strong>，是更简洁、高效、安全的实现单例的方式。</p><h2 id="为什么不用静态方法而用单例模式？"><a href="#为什么不用静态方法而用单例模式？" class="headerlink" title="为什么不用静态方法而用单例模式？"></a>为什么不用静态方法而用单例模式？</h2><p>（来自参考连接）</p><p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，<strong>面向对象的代码提供一个更好的编程思想</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>原文：<a href="https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ">设计模式系列 - 单例模式</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;定义：&lt;strong&gt;在当前进程中，通过单例模式创建的类有且只有一个实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;单例有如下几个特点：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>七大基本原则</title>
    <link href="http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2021-08-25T06:06:50.402Z</published>
    <updated>2021-08-30T04:59:56.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式的七大原则如下：</p><ul><li>单一职责原则 (Single Responsibility Principle)</li><li>接口隔离原则 (Interface Segregation Principle)</li><li>开放-关闭原则 (Open-Closed Principle)</li><li>里氏替换原则 (Liskov Substitution Principle)</li><li>依赖倒转原则 (Dependence Inversion Principle)</li><li>迪米特法则（Law Of Demeter）</li><li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li></ul><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>通俗地说，单一职责原则即<strong>一个类只负责一项职责（不是只有一个方法）</strong>。</p><p>假设某个类 P 负责两个不同的职责：职责 P1 和 职责 P2，那么当职责 P1 需求发生改变而需要修改类 P，有可能会导致原来运行正常的职责 P2 功能发生故障。</p><p>在实际编程中比较难严格的遵守该原则，可以作一些折中处理，比如若是一个类中方法个数比较少，可以在方法级别上遵守该原则（此时在类级别上可能不遵守）。<strong>只有逻辑足够简单，才可以在代码级别上违背单一职责原则</strong>。</p><p>单一职责原则的作用和细节：</p><ul><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ul><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>接口隔离原则指：<strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</strong>：</p><p>被依赖的类实现一个接口，就需要实现接口的所有方法，但这个类在被使用时可能只用到其中部分方法。也就是只要接口中出现的方法，不管依赖于它的类是否需要该方法，实现类都必须去实现这些方法，这就不符合接口隔离原则。可以对接口进行拆分，让实现类只实现需要的接口。</p><p>示例（见来自<a href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89%EF%BC%9A">https://zhuanlan.zhihu.com/p/24614363）：</a></p><img src="https://pic4.zhimg.com/80/v2-ec9b282b367e9c148a7963b5b23c60e7_720w.png" style="zoom:80%;" /><p>类 A 依赖于 接口 I 中的方法 1，2，3 ，类 B 是对类 A 的具体实现。类 C 依赖接口 I 中的方法 1，4，5，类 D 是对类 C 的具体实现。对于类B和类D来说，<strong>虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。</strong> </p><p>用代码表示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line"> <span class="comment">// 类 B 只需要实现方法 1，2, 3，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line"><span class="comment">// 类 D 只需要实现方法 1，4，5，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        A a = <span class="keyword">new</span> A();  </span><br><span class="line">        a.depend1(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());  </span><br><span class="line">          </span><br><span class="line">        C c = <span class="keyword">new</span> C();  </span><br><span class="line">        c.depend1(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend2(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend3(<span class="keyword">new</span> D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对接口根据下图进行拆分：</p><img src="https://pic3.zhimg.com/80/v2-7611098e41bcfbf5113d978b47fc8466_720w.png" style="zoom:80%;" /><p>代码可修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><strong>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</strong>。</li><li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li></ol><h2 id="依赖倒转原则（DIP）"><a href="#依赖倒转原则（DIP）" class="headerlink" title="依赖倒转原则（DIP）"></a>依赖倒转原则（DIP）</h2><p>定义：<strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象</strong>。进一步说，<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。<strong>依赖倒转原则的核心思想就是面向接口编程</strong>。</p><p>依赖倒转原则是基于这样的设计理念：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给实现类去完成。</p><p>示例：（来自<a href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89">https://zhuanlan.zhihu.com/p/24614363）</a></p><p>一个场景：母亲给孩子讲故事，只要给她一本书，她就可照着书给孩子讲故事了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Book book)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(book.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>假如有一天，给的是一份报纸，而不是一本书，让这个母亲讲下报纸上的故事，报纸的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>显然这个母亲完成不了这个任务。只有将Mother类中的Book换成Newspaper才能完成</strong>。但若是以后换成杂志等其他读物，又得进行修改。原因是 Mother 和 Book之间的耦合度太高了。<strong>可以引入一个抽象接口 IReader表示读物，让书和报纸去实现这个接口，那么无论提供什么样的读物，该母亲都能读</strong>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(IReader reader)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(reader.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Mother类代表高层模块，读物相关的类则代表低层模块，在修改示例之前，是高层依赖于低层代码，Mother类要按着Book类来；修改后则符合依赖倒转原则，低层的读物依着高层的Mother来。</p><p><strong>实际情况中，代表高层模块的 Mother 类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒转原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险</strong>。</p><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p><strong>面向对象中继承性的问题</strong>：有一功能 P1, 由类 A 完成，现需要将功能 P1 进行扩展，扩展后的功能为 P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则<strong>子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障</strong>。</p><p>里氏替换原则：</p><ul><li><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li><li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法</strong>。</li><li><strong>子类中尽量不要重写父类的方法</strong>。</li></ul><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而<strong>里氏替换原则就是表达了这一层含义</strong>。</p><p>根据该原则，对于上述的继承性问题：当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能 P2，尽量不要修改父类方法预期的行为。</p><h2 id="开放-关闭原则（OCP）"><a href="#开放-关闭原则（OCP）" class="headerlink" title="开放-关闭原则（OCP）"></a>开放-关闭原则（OCP）</h2><p>**开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改。(Open for extension, close for modification，对扩展开放，对修改关闭)**。</p><p>一个软件满足 OCP 原则后的两项优点：</p><ol><li><strong>能够扩展已存在的系统</strong>，能够提供新的功能满足新的需求，因此该软件有着很强的适应性和灵活性。</li><li>已存在的模块，特别是那些重要的抽象模块，不需要被修改，那么该软件就有很强的稳定性和持久性。</li></ol><p>示例：</p><p>有个生产电脑的公司，根据输入的类型，生产出不同的电脑，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Computer c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;macbook&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Macbook();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;surface&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Surface();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然上面的代码违背了开放 - 关闭原则，<strong>如果需要添加新的电脑产品，需要修改 produceComputer 原本已有的方法</strong>，正确的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Macbook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MSFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Surface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方式应该是将 Factory 抽象成接口，让具体的工厂(如苹果工厂，微软工厂)去实现它，生产它们公司相应的产品，这样写有利于扩展，如果这是需要新增加戴尔工厂生产戴尔电脑，我们仅仅需要创建新的电脑类和新的工厂类，而不需要去修改已经写好的代码。</p><p>总结：</p><ol><li><strong>OCP 可以具有良好的可扩展性，可维护性</strong>。</li><li><strong>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它</strong>。</li></ol><h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><p>迪米特法则又称为<strong>最少知道原则</strong>，它表示<strong>一个对象应该对其它对象保持最少的了解</strong>。**<font color="red">通俗来说就是，只与直接的朋友通信</font>**。</p><p><strong>什么是直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，<strong>称出现在成员变量、方法参数、方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类则不是直接的朋友</strong>。根据迪米特法则，**<font color="red">陌生的类最好不要作为局部变量的形式出现在类的内部</font>**。</p><p><strong>对于被依赖的类来说，无论逻辑多么复杂，都尽量的将逻辑封装在类的内部，对外提供 public 方法，不对泄漏任何信息</strong>。</p><p>示例：</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个 SchoolManager 对象 </span></span><br><span class="line">    SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager(); </span><br><span class="line">    <span class="comment">//输出学院员工id和学校员工id</span></span><br><span class="line">    schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学校员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工管理类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回学院的所有员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;CollegeEmployee&gt; list = newArrayList&lt;CollegeEmployee&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="comment">//这里我们增加了 10 个员工到 </span></span><br><span class="line">            list CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回所有学校员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;Employee&gt; list = newArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">            list Employee emp = <span class="keyword">new</span> Employee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">&#125; </span><br><span class="line">        <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到SchoolManager的printAllEmployee方法中，<strong>CollegeEmployee并不是SchoolManager的直接朋友，不符合迪米特法则</strong>。</p><p>可以将打印CollegeEmployee部分的代码封装进CollegeManager中：</p><p>CollegeManager中添加新的public方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">    List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而可以在SchoolManager中通过CollegeManager调用该方法来打印所有学院员工id，SchoolManager.printAllEmployee方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">sub.printEmployee();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">    List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-聚合复用原则（CRP）"><a href="#组合-聚合复用原则（CRP）" class="headerlink" title="组合/聚合复用原则（CRP）"></a>组合/聚合复用原则（CRP）</h2><p>组合/聚合复用原则指的是<strong>在实际开发设计中，尽量使用组合/聚合，不要使用类继承</strong>。</p><p>在面向对象的设计中，<strong>如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类，如果基类的实现发生了改变，则子类的实现也不得不改变</strong>。</p><ul><li><p>总体说来，组合或者聚合好过于继承。</p></li><li><p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24614363">https://zhuanlan.zhihu.com/p/24614363</a></p><p><a href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;设计模式的七大原则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则 (Single Responsibility Principle)&lt;/li</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML类图六种关系</title>
    <link href="http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/"/>
    <id>http://example.com/2021/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/</id>
    <published>2021-08-25T06:06:50.400Z</published>
    <updated>2021-08-30T04:59:58.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UML类图用于<strong>描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</strong>。 </p><p>类之间的关系有：<strong>泛化（继承）、实现、关联、聚合、组合、依赖</strong>。</p><p>六种关系的耦合度大小是：<strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong>。</p><h2 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h2><p>泛化就是指继承关系。</p><p>代码体现：子类继承父类。</p><p>UML符号：<strong>实线+空心箭头，箭头指向父类</strong> </p><p>如图：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022222623274.png" alt="image-20201022222623274"></p><h2 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h2><p>实现关系即实现类实现接口。</p><p>代码体现：A类实现B接口。</p><p>UML符号：<strong>一条虚线+空心箭头</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022224009475.png" alt="image-20201022224009475" style="zoom:67%;" /><h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>关联关系指<strong>类和类之间的联系，如一对一、一对多、多对多。其中有单向关联，双向关联。</strong> </p><p>代码体现：成员变量</p><p>UML符号：<strong>双向关联，一条实线或一条实线+两个箭头；单向关联，一条实线+一个箭头</strong> </p><p>一对一</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225341448.png" alt="image-20201022225341448" style="zoom:67%;" /><p>其他：（图片来自<a href="https://www.zhihu.com/question/419192424/answer/1471808645%EF%BC%89">https://www.zhihu.com/question/419192424/answer/1471808645）</a></p><p><img src="https://pic2.zhimg.com/80/v2-b880e61921fcc252b58a2a8da1baf368_720w.jpg?source=1940ef5c"></p><h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>聚合关系（Aggregation）表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开，即部分能脱离整体而独立存在</strong>。</p><p>代码体现：成员变量</p><p>UML符号：<strong>一条实线+空心菱形</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225828143.png" alt="image-20201022225828143" style="zoom:67%;" /><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>组合也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开，部分不能脱离整体而独立存在</strong>。</p><p>代码体现：成员变量</p><p>UML符号：<strong>一条实线+实心菱形</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230156462.png" alt="image-20201022230156462" style="zoom:67%;" /><h2 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h2><p>是一种使用关系，一个类的实现需要另一个类的协助。即在一个类中使用了另外一个类。<strong>尽量不要使用双向依赖。以上关系都是依赖关系的特例</strong>。</p><p>代码体现：局部变量、方法的参数或者对静态方法的调用。</p><p>UML符号：<strong>一条虚线+箭头</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230737289.png" alt="image-20201022230737289" style="zoom:67%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/vic_/p/8057851.html">https://www.cnblogs.com/vic_/p/8057851.html</a></p><p><a href="https://www.zhihu.com/question/419192424/answer/1471808645">https://www.zhihu.com/question/419192424/answer/1471808645</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;UML类图用于&lt;strong&gt;描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;类之间的关</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SSM整合</title>
    <link href="http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88/"/>
    <id>http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88/</id>
    <published>2021-08-25T06:06:50.393Z</published>
    <updated>2021-08-30T04:59:40.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>本文只介绍项目中的配置文件</strong>，完整项目：<a href="https://github.com/bxxiao/SSMDemo" target="_blank">github</a>。</p><p>项目中使用了两张表（员工表、部门表，一个员工对应一个部门）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table dept</span><br><span class="line">(</span><br><span class="line">    dept_id   int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    dept_name varchar(255) null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table employees</span><br><span class="line">(</span><br><span class="line">    emp_id   int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    emp_name varchar(30)  null,</span><br><span class="line">    gender   char         null,</span><br><span class="line">    email    varchar(255) null,</span><br><span class="line">    d_id     int          null,</span><br><span class="line">    constraint emp_fk_dept</span><br><span class="line">        foreign key (d_id) references dept (dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>该项目是idea的maven项目，总的目录结构：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201016232015440.png" alt="image-20201016232015440" style="zoom:80%;" /><p>&emsp;  </p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>pom.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSMIntegration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SSMIntegration Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- spring以及springMVC相关依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 事务相关配置所需依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis整合spring的jar包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池以及数据库驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis逆向工程依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis分页插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 处理json数据的jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- JSR303校验所需依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- servlet-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>SSMIntegration<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- mybatis逆向工程所需插件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>若在关闭tomcat服务器时会报错，见： <a href="https://www.cnblogs.com/bxiaoo/p/13828772.html">https://www.cnblogs.com/bxiaoo/p/13828772.html</a></p></blockquote><p>&emsp;  </p><h2 id="SpringMVC配置文件"><a href="#SpringMVC配置文件" class="headerlink" title="SpringMVC配置文件"></a>SpringMVC配置文件</h2><p>spring-mvc.xml（位于resources/ssm下）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在该配置文件中只配置web组件相关的bean --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 扫描controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.controller&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 两个常用配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让springmvc处理不了的请求交给tomcat，如静态资源等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支持一些springmvc高级功能，如jsr303校验、快捷的Ajax、映射动态请求等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><h2 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h2><p>spring配置文件中配置了service、dao等bean，也<strong>包括跟mybatis的整合配置</strong>。</p><h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p>Spring整合Mybatis通过类<code>SqlSessionFactoryBean</code>，<strong>在该bean中可以进行与Mybatis主配置文件一样的配置，即可以省略Mybatis主配置文件</strong>。也可以通过<code>configLocation</code>属性来指定主配置文件的路径。</p><p>spring-mybatis.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接池，这里使用德鲁伊 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接池数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最小连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接超时时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQueryTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==========================spring和MyBatis完美整合=========================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis的主配置文件中的所有配置，都可以在SqlSessionFactoryBean中进行配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定别名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ssm.bean&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置分页插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SqlSessionTemplate是线程安全的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;executorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描dao接口，将dao接口的实现类添加到ioc容器（Root WebApplicationContext）中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ssm.dao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ========================================================================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jdbc.properties：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=com.mysql.cj.jdbc.Driver</span><br><span class="line"><span class="attr">url</span>=jdbc:mysql://locaohost:<span class="number">3306</span>/ssm?serverTimezone=UTC</span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">password</span>=admin</span><br></pre></td></tr></table></figure><blockquote><p>关于SqlSessionTemplate：<a href="https://www.jianshu.com/p/7cb4777a539e" target="_blank">对于SqlSessionTemplate的理解</a> </p></blockquote><h3 id="整合spring事务管理"><a href="#整合spring事务管理" class="headerlink" title="整合spring事务管理"></a>整合spring事务管理</h3><p>关于spring中基于xml的声明式事务要注意的一个点：</p><p><strong><font color="red">在基于XML的声明式事务中，事务属性的tx: method是必须配置的，如果某个方法没有对应的tx: method配置，那么事务对这个方法就不生效，即不会使用默认值</font></strong> 。</p><p>spring-service.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置service层：扫描 service 包；配置事务管理 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- =========配置事务管理========= --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定控制的数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 也可以配置基于注解的声明式事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用 xml 配置事务管理 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务属性，即配置事务的传播行为，隔离级别等 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- advice默认指定id为transactionManager的事务管理器，所以若是配置的事务管理器id不是该值，则需显示指定</span></span><br><span class="line"><span class="comment">            事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name属性指定当前method标签配置的事务属性要应用到哪些方法</span></span><br><span class="line"><span class="comment">                如第二个method标签指定对所有get开头的方法应用只读属性（只能查询）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPoint&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.ssm.service..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPoint&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ===================================================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><h3 id="spring配置文件"><a href="#spring配置文件" class="headerlink" title="spring配置文件"></a>spring配置文件</h3><p>将 mybatis、service 整合进 spring Root ApplicationContext。</p><p>rootApplicationContext.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入整合mybatis的相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:ssm/spring-mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入 service 相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:ssm/spring-service.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><h2 id="日志配置文件"><a href="#日志配置文件" class="headerlink" title="日志配置文件"></a>日志配置文件</h2><p>log4j2的配置文件（log4j2.xml），该配置主要打印sql语句执行日志：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;PATTERN&quot;</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t-%L] %-5level</span><br><span class="line">            %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;consolePrint&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.ssm.dao&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consolePrint&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置日志的根节点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consolePrint&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><h2 id="web-xml配置文件"><a href="#web-xml配置文件" class="headerlink" title="web.xml配置文件"></a>web.xml配置文件</h2><p>web.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring配置文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:ssm/rootApplicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log4j配置文件的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfiguration<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:log4j2.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 防止Spring内存溢出监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.IntrospectorCleanupListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过配置ContextLoaderListener，让其创建Spring的应用上下文（Root ApplicationContext）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 服务器关闭时关闭驱动的监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.ssm.listener.DriverMangerListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:ssm/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 字符编码过滤器，该过滤器一般位于所有过滤器之前 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter用于将post请求转换为指定请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当客户端发送PUT、DELETE、PATCH请求时，该过滤器会将其中的参数信息进行处理，以</span></span><br><span class="line"><span class="comment">        便可以通过HttpRequest对象的getParameter方法获取到参数数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.FormContentFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;  </p><blockquote><p>web.xml中的FormContentFilter：</p><p>在前端，可以通过Ajax直接发送DELETE、PUT等post、get之外的请求，但tomcat对于post之外的请求，并不会将其中的参数数据封装进request对象，从而不能通过request的getParameter方法可以获取到这些参数。而springMVC是使用getParameter方法来获取数据封装进控制器方法的JavaBean形参，所以导致了封装不了JavaBean的信息。</p><p>FormContentFilter可以对DELETE、PUT请求中的参数数据进行处理，让springMVC可以正常封装JavaBean形参。</p><p>关于IntrospectorCleanupListener：<a href="https://www.cnblogs.com/qiankun-site/p/5886673.html" target="_blank">IntrospectorCleanupListener作用</a> </p></blockquote><p>&emsp; </p><h2 id="Mybatis-Generator"><a href="#Mybatis-Generator" class="headerlink" title="Mybatis-Generator"></a>Mybatis-Generator</h2><p>使用mybatis逆向工程身材mapper及其配置文件。</p><p>配置文件（generator/generatorConfig.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;mysql驱动包绝对路径&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;simple&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置生成的类不带注释 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/ssm?serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定生成的JavaBean的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ssm.bean&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定映射文件的生成位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定dao接口生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ssm.dao&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定每个表的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Employee&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Department&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/DoubleEggs/p/6243216.html" target="_blank">【SSM】Eclipse使用Maven创建Web项目+整合SSM框架</a> </p><p><a href="https://www.cnblogs.com/zyw-205520/p/4771253.html" target="_blank">SSM框架——详细整合教程（Spring+SpringMVC+MyBatis）</a> </p><p><a href="https://blog.csdn.net/z69183787/article/details/52925567" target="_blank">使用Log4j2打印Mybatis SQL语句以及结果集</a> </p><p><a href="https://blog.csdn.net/qq598535550/article/details/51703190">手把手教你整合最优雅SSM框架</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文只介绍项目中的配置文件&lt;/strong&gt;，完整项目：&lt;a href=&quot;https://github.com/bxxiao</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
    <category term="框架" scheme="http://example.com/Tag/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis逆向工程</title>
    <link href="http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</id>
    <published>2021-08-25T06:06:50.391Z</published>
    <updated>2021-08-30T04:59:26.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Mybatis逆向工程（Mybatis Generator）用于根据配置文件自动生成数据表对应的JavaBean，以及dao接口和映射文件。</p><p>该示例以Maven的插件形式运行Mybatis逆向工程。（Maven项目）</p><h2 id="pom-xml中添加插件"><a href="#pom-xml中添加插件" class="headerlink" title="pom.xml中添加插件"></a>pom.xml中添加插件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><h2 id="数据表示例"><a href="#数据表示例" class="headerlink" title="数据表示例"></a>数据表示例</h2><p>以dept表（部门）和employees表（员工）为例。员工的d_id指向dept的主键。</p><p>dept：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927200546234.png" alt="image-20200927200546234"></p><p>employees：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927200613315.png" alt="image-20200927200613315"></p><p>&emsp;  </p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>创建连接数据库相关信息的<code>jdbc.properties</code>文件以及逆向工程的配置文件<code>generatorConfig.xml</code>。放在resource目录下。并将MySQL jdbc驱动包放在resource下（这里使用的是mysql-connector-java-5.1.47.jar）。</p><blockquote><p>PS：<strong>mybatis-generator插件默认在resource目录下查找<code>generatorConfig.xml</code>配置文件，所以这里的<code>generatorConfig.xml</code>配置文件要注意位置与命名</strong>。</p></blockquote><p>jdbc.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/ssm?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">admin</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><p><code>generatorConfig.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入properties配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;驱动包的绝对路径&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置生成的类不带注释（建议，因为生成的注释没啥用） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--jdbc的数据库连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定生成的JavaBean的包位置,</span></span><br><span class="line"><span class="comment">                用来生成含有主键key的类，记录类 以及查询Example类</span></span><br><span class="line"><span class="comment">                不用事先创建好包结构，mybatis-generator会根据配置自动创建，sqlMapGenerator同</span></span><br><span class="line"><span class="comment">            targetPackage     指定生成的JavaBean生成所在的包名</span></span><br><span class="line"><span class="comment">            targetProject     指定在该项目下所在的路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.generator.bean&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对model添加 构造函数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;constructorBased&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;immutable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定dao接口（mapper）的位置</span></span><br><span class="line"><span class="comment">                type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象</span></span><br><span class="line"><span class="comment">                type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象</span></span><br><span class="line"><span class="comment">                type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.generator.dao&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定每个表的生成策略</span></span><br><span class="line"><span class="comment">                配置数据表与JavaBean的名称映射，以及是否创建根据条件查询的sql语句等 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName指定表名，domainObjectName指定表对应的JavaBean名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Department&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Employee&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><h2 id="插件相关配置"><a href="#插件相关配置" class="headerlink" title="插件相关配置"></a>插件相关配置</h2><p>在maven窗口配置一个插件运行。</p><ol><li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927200743717.png" alt="image-20200927200743717" style="zoom:80%;" /></li><li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201004256.png" alt="image-20200927201004256" style="zoom:80%;" /></li><li><p>分别填入项目的目录以及命令<code>mybatis-generator:generate -e</code>：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201321279.png" alt="image-20200927201321279" style="zoom:80%;" /></li><li><p>OK。</p></li></ol><p>&emsp;  </p><h2 id="运行Generator"><a href="#运行Generator" class="headerlink" title="运行Generator"></a>运行Generator</h2><p>打开maven窗口可看到：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201451117.png" alt="image-20200927201451117"></p><p>&emsp;  </p><p>双击即可运行generator。</p><p>运行后的项目目录，可看到创建了JavaBean、dao以及映射文件：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201609898.png" alt="image-20200927201609898" style="zoom:80%;" /><p>&emsp; </p><h2 id="XxxExample的使用"><a href="#XxxExample的使用" class="headerlink" title="XxxExample的使用"></a>XxxExample的使用</h2><p>通过逆向工程生成的JavaBean中可以看到有XxxExample的类，这些类的作用是用于设置查询条件。</p><p>简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmployeeExample</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSession session = getSqlSession();<span class="comment">//获取SqlSession（方法具体实现省略）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个example类</span></span><br><span class="line">    EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">    <span class="comment">//查询employees表中did为1的记录</span></span><br><span class="line">    example.or().andDIdEqualTo(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">    List&lt;Employee&gt; employees = mapper.selectByExample(example);</span><br><span class="line">    <span class="keyword">for</span>(Employee e : employees)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>又如：通过模糊查询，查询EmpName包含“三”的记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">example.or().andEmpNameLike(<span class="string">&quot;%三%&quot;</span>);</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>其他的添加查询条件的方法：（来自<a href="https://blog.csdn.net/biandous/article/details/65630783%EF%BC%89">https://blog.csdn.net/biandous/article/details/65630783）</a></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>example.setOrderByClause(“字段名 ASC”);</td><td>添加升序排列条件，DESC为降序</td></tr><tr><td>example.setDistinct(false)</td><td>去除重复，boolean型，true为选择不重复的记录。</td></tr><tr><td>criteria.andXxxIsNull</td><td>添加字段xxx为null的条件</td></tr><tr><td>criteria.andXxxIsNotNull</td><td>添加字段xxx不为null的条件</td></tr><tr><td>criteria.andXxxEqualTo(value)</td><td>添加xxx字段等于value条件</td></tr><tr><td>criteria.andXxxNotEqualTo(value)</td><td>添加xxx字段不等于value条件</td></tr><tr><td>criteria.andXxxGreaterThan(value)</td><td>添加xxx字段大于value条件</td></tr><tr><td>criteria.andXxxGreaterThanOrEqualTo(value)</td><td>添加xxx字段大于等于value条件</td></tr><tr><td>criteria.andXxxLessThan(value)</td><td>添加xxx字段小于value条件</td></tr><tr><td>criteria.andXxxLessThanOrEqualTo(value)</td><td>添加xxx字段小于等于value条件</td></tr><tr><td>criteria.andXxxIn(List&lt;？&gt;)</td><td>添加xxx字段值在List&lt;？&gt;条件</td></tr><tr><td>criteria.andXxxNotIn(List&lt;？&gt;)</td><td>添加xxx字段值不在List&lt;？&gt;条件</td></tr><tr><td>criteria.andXxxLike(“%”+value+”%”)</td><td>添加xxx字段值为value的模糊查询条件</td></tr><tr><td>criteria.andXxxNotLike(“%”+value+”%”)</td><td>添加xxx字段值不为value的模糊查询条件</td></tr><tr><td>criteria.andXxxBetween(value1,value2)</td><td>添加xxx字段值在value1和value2之间条件</td></tr><tr><td>criteria.andXxxNotBetween(value1,value2)</td><td>添加xxx字段值不在value1和value2之间条件</td></tr></tbody></table><p>&emsp;  </p><p><strong>以上方法都可以通过example类的<code>or()</code>方法调用（如示例），推荐使用这种方式</strong>。</p><p>使用<code>or()</code>方法添加多个条件时要注意：</p><ul><li><p><strong>若是要添加多个AND条件，应是这种方式：</strong> **<code>example.or().andXxx1(xx).andXxx2(xx).addXxx3(xx);</code>**。</p></li><li><p>若是使用以下方式，添加的多个条件将是OR条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example.or().andXxx1(xx);</span><br><span class="line">example.or().andXxx2(xx);</span><br><span class="line">example.or().andXxx3(xx);</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.csdn.net/for_my_life/article/details/51228098">https://blog.csdn.net/for_my_life/article/details/51228098</a></p><p><a href="https://blog.csdn.net/biandous/article/details/65630783">https://blog.csdn.net/biandous/article/details/65630783</a></p></blockquote><p>&emsp;  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Mybatis逆向工程（Mybatis Generator）用于根据配置文件自动生成数据表对应的JavaBean，以及dao接口和映射文件。</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Mybatis" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/Mybatis/"/>
    
    
    <category term="框架" scheme="http://example.com/Tag/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring中处理json数据的总结</title>
    <link href="http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/Spring%E4%B8%AD%E5%A4%84%E7%90%86json%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/Spring%E4%B8%AD%E5%A4%84%E7%90%86json%E6%95%B0%E6%8D%AE/</id>
    <published>2021-08-25T06:06:50.391Z</published>
    <updated>2021-08-30T04:59:35.335Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下Spring中一些解析json数据的技巧。</p><h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h2><p><code>@RequestBody</code>注解常用来处理<code>content-type</code>不是默认的<code>application/x-www-form-urlcoded</code>编码的内容，比如<code>application/json</code>或者是<code>application/xml</code>等。<strong>一般情况下来说常用其来处理<code>application/json</code>类型</strong>。</p><p><code>@RequestBody</code>的修饰对象的控制器方法形参，一般用于修饰JavaBean形参，其<strong>可以将请求体中的JSON字符串绑定到修饰的bean上</strong>。也可以修饰字符串，会将请求体的参数以<code>key1=value1&amp;key2=value2&amp;...</code>的格式复制给String控制器参数。</p><p>&emsp;  </p><p><strong>修饰JavaBean时，json字符串要与JavaBean的属性对应</strong>，<strong><font color="red">且可以修饰List集合类型的形参，这时前端要以json数组的形式发送数据，且要指定<code>content-type</code>为<code>application/json</code>类型</font></strong>。</p><h3 id="接收json对象字符串示例"><a href="#接收json对象字符串示例" class="headerlink" title="接收json对象字符串示例"></a>接收json对象字符串示例</h3><p>JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line"> <span class="comment">//getter、setter、toString</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"><span class="comment">//getter、setter、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataResolveController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/doJsonObject&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">resolveJsonObject</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span></span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>在前端发送Ajax：</p><ul><li>**注意发送ajax请求时，contentType要指定为<code>application/json</code>**。</li><li>person对象的属性与Person类一一对应，<strong>其中roles的属性值是一个json对象数组</strong>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Test @RequestBody<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;send&quot;</span>&gt;</span>send ajax<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#send&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> person = &#123;</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;name&quot;</span>:<span class="string">&quot;白小纯&quot;</span>, </span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;age&quot;</span>:<span class="string">&quot;20&quot;</span>, </span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;roles&quot;</span>:[</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;医生&quot;</span>&#125;, </span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;2&quot;</span>,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;老师&quot;</span>&#125;</span></span><br><span class="line">                ]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                type: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="javascript">                url: <span class="string">&quot;doJsonObject&quot;</span>,</span></span><br><span class="line"><span class="javascript">                contentType: <span class="string">&quot;application/json; charset=utf-8&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data: <span class="built_in">JSON</span>.stringify(person),</span></span><br><span class="line"><span class="javascript">                dataType: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>点击按钮，后台输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;<span class="attribute">name</span>=<span class="string">&#x27;白小纯&#x27;</span>, <span class="attribute">age</span>=20, roles=[Role&#123;<span class="attribute">id</span>=1, <span class="attribute">roleName</span>=<span class="string">&#x27;医生&#x27;</span>&#125;, Role&#123;<span class="attribute">id</span>=2, <span class="attribute">roleName</span>=<span class="string">&#x27;老师&#x27;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="接收json数组示例"><a href="#接收json数组示例" class="headerlink" title="接收json数组示例"></a>接收json数组示例</h3><p>控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/sendarray&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testReceiveArray</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Integer&gt; array)</span></span>&#123;</span><br><span class="line">    System.out.println(array);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>Ajax代码（jQuery）：</p><ul><li>这里发送json数组可以直接使用字符串形式，如下。也可以先创建一个变量<code>var array = [1,2,3,5]</code>，再通过<code>JSON.stringify(array)</code>转换为json数据。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//var array = [1,2,3,5];</span></span><br><span class="line">        <span class="comment">//JSON.stringify(array)</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">&quot;sendarray&quot;</span>,</span><br><span class="line">            type: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">            data: <span class="string">&quot;[1,2,3]&quot;</span>,</span><br><span class="line">            dataType: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            contentType: <span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; </span><br><span class="line">                alert(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>服务端输出：<code>[1, 2, 3]</code>。</p><p><strong><font color="red">List的元素也可以是其他的JavaBean</font></strong>。</p><p>&emsp;  </p><h2 id="使用Jackson处理json"><a href="#使用Jackson处理json" class="headerlink" title="使用Jackson处理json"></a>使用Jackson处理json</h2><h3 id="Jackson简介"><a href="#Jackson简介" class="headerlink" title="Jackson简介"></a>Jackson简介</h3><blockquote><p>来自参考连接</p></blockquote><p>Jackson 是当前用的比较广泛的，用来序列化和反序列化 json 的 Java 的开源框架。Jackson 社区相对比较活跃，更新速度也比较快， 从 Github 中的统计来看，Jackson 是最流行的 json 解析器之一 。 Spring MVC 的默认 json 解析器便是 Jackson。 Jackson 优点很多。 Jackson 所依赖的 jar 包较少 ，简单易用。与其他 Java 的 json 的框架 Gson 等相比， Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。</p><p>Jackson 的 1.x 版本的包名是 org.codehaus.jackson ，当升级到 2.x 版本时，包名变为 com.fasterxml.jackson。</p><p>Jackson 的核心模块由三部分组成。</p><ul><li>jackson-core，核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。 Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</li><li>jackson-annotations，注解包，提供标准注解功能；</li><li>jackson-databind ，数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API （JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>对于SpringMVC项目，需要导入依赖（maven）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于SpringBoot项目，依赖<code>spring-boot-starter-web</code>中就包括了Jackson的依赖。所以无需导入。</p><p>&emsp;  </p><h3 id="JSON字符串-》对象"><a href="#JSON字符串-》对象" class="headerlink" title="JSON字符串-》对象"></a>JSON字符串-》对象</h3><p>Jackson的一个主要类就是<code>ObjectMapper</code>，通过该类的<code>readValue()</code>方法可以将json字符串解析为指定对象。</p><p>&emsp;  </p><p>示例：</p><p>JavaBean使用上述的Person和Role。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testJackson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    String personJson = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;白小纯\&quot;, \&quot;age\&quot;:\&quot;20\&quot;, \&quot;roles\&quot;:[&#123;\&quot;id\&quot;:\&quot;1\&quot;,\&quot;roleName\&quot;:\&quot;医生\&quot;&#125;, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;2\&quot;,\&quot;roleName\&quot;:\&quot;老师\&quot;&#125;]&#125;&quot;</span>;</span><br><span class="line">    Person person = mapper.readValue(personJson, Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;<span class="attribute">name</span>=<span class="string">&#x27;白小纯&#x27;</span>, <span class="attribute">age</span>=20, roles=[Role&#123;<span class="attribute">id</span>=1, <span class="attribute">roleName</span>=<span class="string">&#x27;医生&#x27;</span>&#125;, Role&#123;<span class="attribute">id</span>=2, <span class="attribute">roleName</span>=<span class="string">&#x27;老师&#x27;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>&emsp;  </p><h3 id="对象-》json字符串"><a href="#对象-》json字符串" class="headerlink" title="对象-》json字符串"></a>对象-》json字符串</h3><p>通过<code>ObjectMapper</code>对象的<code>writeValueAsString()</code>方法实现。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectToJson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    </span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    List&lt;Role&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Role role1 = <span class="keyword">new</span> Role();</span><br><span class="line">    Role role2 = <span class="keyword">new</span> Role();</span><br><span class="line"></span><br><span class="line">    role1.setId(<span class="number">1</span>);</span><br><span class="line">    role1.setRoleName(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    role2.setId(<span class="number">2</span>);</span><br><span class="line">    role2.setRoleName(<span class="string">&quot;班长&quot;</span>);</span><br><span class="line">    roles.add(role1);</span><br><span class="line">    roles.add(role2);</span><br><span class="line"></span><br><span class="line">    person.setAge(<span class="number">20</span>);</span><br><span class="line">    person.setName(<span class="string">&quot;王大锤&quot;</span>);</span><br><span class="line">    person.setRoles(roles);</span><br><span class="line"></span><br><span class="line">    String personStr = mapper.writeValueAsString(person);</span><br><span class="line">    System.out.println(personStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;王大锤&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">20</span>,<span class="attr">&quot;roles&quot;</span>:[&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;roleName&quot;</span>:<span class="string">&quot;学生&quot;</span>&#125;,&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;roleName&quot;</span>:<span class="string">&quot;班长&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>&emsp;  </p><h3 id="JSON数组《-》Lsit"><a href="#JSON数组《-》Lsit" class="headerlink" title="JSON数组《-》Lsit"></a>JSON数组《-》Lsit</h3><p><strong><code>readValue()</code>方法可以解析JSON对象数组字符串为List集合，同样的，<code>writeValueAsString()</code>方法可以将List集合中的多个对象解析为Json对象数组字符串</strong>。</p><p>示例：</p><p>注意<code>readValue()</code>方法的第二个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonTOList</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    String rolesStr = <span class="string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;roleName\&quot;:\&quot;快递员\&quot;&#125;,&#123;\&quot;id\&quot;:2,\&quot;roleName\&quot;:\&quot;程序员\&quot;&#125;]&quot;</span>;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    List&lt;Role&gt; roles = mapper.readValue(rolesStr, <span class="keyword">new</span> TypeReference&lt;List&lt;Role&gt;&gt;() &#123;&#125;);</span><br><span class="line">    System.out.println(roles);</span><br><span class="line"></span><br><span class="line">    String jsonArray = mapper.writeValueAsString(roles);</span><br><span class="line">    System.out.println(jsonArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Role&#123;<span class="attribute">id</span>=1, <span class="attribute">roleName</span>=<span class="string">&#x27;快递员&#x27;</span>&#125;, Role&#123;<span class="attribute">id</span>=2, <span class="attribute">roleName</span>=<span class="string">&#x27;程序员&#x27;</span>&#125;]</span><br><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;快递员&quot;</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:2,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;程序员&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><p>&emsp;  </p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><p><a href="https://juejin.im/post/6844904166809157639" target="_blank">Jackson使用详解–掘金 三分恶</a>（想要深入了解Jackson可以看这篇博客，巨详细）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一下Spring中一些解析json数据的技巧。&lt;/p&gt;
&lt;h2 id=&quot;RequestBody注解&quot;&gt;&lt;a href=&quot;#RequestBody注解&quot; class=&quot;headerlink&quot; title=&quot;@RequestBody注解&quot;&gt;&lt;/a&gt;@RequestBody注</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
    <category term="框架" scheme="http://example.com/Tag/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis的使用</title>
    <link href="http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/Mybatis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/08/25/%E6%A1%86%E6%9E%B6/Mybatis%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-25T06:06:50.389Z</published>
    <updated>2021-08-30T04:59:10.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>中文文档： <a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a> </p><p>MyBatis 是支持<strong>定制化 SQL</strong>，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJO映射成数据库中的记录。它<strong>内部封装了 jdbc</strong>，<strong><font color="red">使开发者能更专注于 SQL 代码</font></strong>， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</p><h1 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h1><p>该示例基于IDEA的Maven项目。</p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>主要是导入mybatis和mysql jdbc驱动包依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两个必须导入的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 使用lombok可以通过使用<code>@Data</code>注解修饰entity类，从而使Lombok为该类自动生成getter、setter、constructor以及toString。</p><p>使用前需在idea中安装Lombok插件：【Settings】-》【Plugins】，搜索Lombok，安装即可。</p><p>若不使用Lombok则后述的User类注意添加getter、setter等。</p></blockquote><h2 id="创建实体类、数据表以及dao接口（Mapper）"><a href="#创建实体类、数据表以及dao接口（Mapper）" class="headerlink" title="创建实体类、数据表以及dao接口（Mapper）"></a>创建实体类、数据表以及dao接口（Mapper）</h2><p>包结构：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914213616915.png" alt="image-20200914213616915" style="zoom: 80%;" /><p>user表：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200913232633655.png" alt="image-20200913232633655"></p><p>User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Mybatis中，把dao接口称为Mapper（映射器）。</p></blockquote><h2 id="创建映射文件"><a href="#创建映射文件" class="headerlink" title="创建映射文件"></a>创建映射文件</h2><p><strong>在resource目录下创建Mapper对应的xml配置文件，<span style="color:red">Mapper对应的xml文件在resource中的目录结构要与Mapper的包结构保持一致</span></strong>，如图：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914213717783.png" alt="image-20200914213717783"></p><blockquote><p>PS：IDEA的Maven项目中，在resource目录下不能创建package，只能创建redirect，且创建目录时，需一层一层创建，这样在磁盘中才会有对应的目录结构，若在创建时使用 com.entity的命名方式，则在磁盘中只会创建一个名为com.entity的目录</p></blockquote><p>UserMapper.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #&#123;id&#125;将会接收UserMapper.selectById方法中的id参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.entity.User&quot;</span> &gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建主配置文件"><a href="#创建主配置文件" class="headerlink" title="创建主配置文件"></a>创建主配置文件</h2><p>主配置文件用于<strong>用于配置数据源，事务管理器，映射文件位置等其他全局设置</strong>。一般命名为<strong>SqlMapConfig.xml</strong>，放在resource目录下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- default属性指定配置的environment中某一个的id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置连接数据库的相关信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 事务管理器 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定映射配置文件的路径，注意分隔符是 / 而不是 . --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="获取SqlSession，进行数据库操作"><a href="#获取SqlSession，进行数据库操作" class="headerlink" title="获取SqlSession，进行数据库操作"></a>获取SqlSession，进行数据库操作</h2><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取主配置文件的输入流</span></span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SqlSessionFactoryBuilder</span></span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过SqlSessionFactoryBuilder加载输入流，创建工厂</span></span><br><span class="line">    SqlSessionFactory factory = builder.build(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过工厂创建SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = factory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过SqlSession对象获取Dao的代理对象</span></span><br><span class="line">    UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行数据库操作</span></span><br><span class="line">    User user = userDao.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭sqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行test方法，输出：<code>user = User(id=1, username=张三, password= 123456)</code> </p><p>over.</p><h2 id="获取SqlSession步骤"><a href="#获取SqlSession步骤" class="headerlink" title="获取SqlSession步骤"></a>获取SqlSession步骤</h2><p>步骤如下：</p><ol><li><p><strong>读取配置文件</strong>。通过<strong>org.apache.ibatis.io.Resources</strong>类的<code>getResourceAsStream()</code><strong>静态方法</strong>获取主配置文件的输入流：</p><p><code>InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</code></p></li><li><p><strong>创建SqlSessionFactory工厂</strong>。SqlSessionFactory不能直接通过构造器创建，需先创建一个<strong>SqlSessionFactoryBuilder</strong>，再通过builder加载上述创建的输入流，创建工厂对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">SqlSessionFactory factory = builder.builde(in);<span class="comment">//传入主配置文件的输入流</span></span><br></pre></td></tr></table></figure></li><li><p><strong>通过工厂创建SqlSession对象</strong>。</p><p><code>SqlSession session = factory.openSession();</code> </p></li><li><p><strong>通过session获取dao接口的代理对象</strong>（<strong>也可以不使用代理对象，直接使用session对象的方法实现数据库操作，如selectAll()等</strong>）</p><p><code>XxxDao dao = session.getMapper(XxxDao.class);</code></p></li><li><p>使用该dao代理对象执行方法，进行数据库操作。</p></li></ol><h1 id="SqlSession简介"><a href="#SqlSession简介" class="headerlink" title="SqlSession简介"></a>SqlSession简介</h1><p>SqlSession对象是Mybatis中的一个主要接口，可以通过这个接口来执行命令，获取映射器示例和管理事务。</p><p>SqlSession提供了之间操作数据库的方法，如：<code>session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101)</code>。但一般不使用这些方法，而是通过配置Mapper（即dao接口）的映射文件，再通过SqlSession获取Mapper的代理对象。</p><p>SqlSession由SqlSessionFactory创建，SqlSessionFactory的<code>openSession</code>方法有一个重载形式：<code>openSession(boolean autoCommit)</code>，autoCommit指定是否自动提交（即是否开启事务），默认是false，即开启事务。所以默认情况下执行update、delte和insert语句时需要提交事务，即执行SqlSession的<code>commit()</code>方法，否则将造成事务回滚。也可以通过<code>openSession(true)</code>来获取关闭事务的SqlSession。</p><p>另外，SqlSession 对象不是线程安全的，所以每个线程都应该有它自己的 SqlSession 对象，且每次执行完数据库操作后，应关闭SqlSession：<code>session.close()</code>。</p><blockquote><p>最佳作用域</p><p><strong>SqlSessionFactoryBuilder</strong></p><p>创建了SqlSessionFactory后，就不再需要SqlSessionFactoryBuilder，所以其最佳作用域是方法作用域，即声明为局部变量。</p><p><strong>SqlSessionFactory</strong></p><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在。因为SqlSession需要每次使用完都执行关闭操作，因此每一次进行数据库操作需通过SqlSessionFactory 获取SqlSession。</p><p><strong>因此 SqlSessionFactory 的最佳作用域是应用作用域</strong>。 最简单的就是使用单例模式或者静态单例模式。</p><p><strong>SqlSession</strong></p><p>SqlSession 对象不是线程安全的，每个线程都应该有它自己的 SqlSession 对象。所以SqlSession的最佳作用域是请求或方法作用域。</p><p>不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。如果使用一种 Web 框架，可以将 SqlSession 放在一个和 HTTP 请求相似的作用域中。</p><p><strong>且每次使用完SqlSession，都应该执行关闭操作</strong>。</p></blockquote><h1 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>主配置文件结构：（详细说明见官方文档：<a href="https://mybatis.org/mybatis-3/zh/configuration.html%EF%BC%89">https://mybatis.org/mybatis-3/zh/configuration.html）</a></p><p>configuration（配置）</p><ul><li><p>properties（属性)</p></li><li><p>settings（设置）</p></li><li><p>typeAliases（类型别名）</p></li><li><p>typeHandlers（类型处理器)</p></li><li><p>objectFactory（对象工厂）</p></li><li><p>plugins（插件）</p></li><li><p>environments（环境配置）</p><ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><p>databaseIdProvider（数据库厂商标识）</p></li><li><p>mappers（映射器）</p></li></ul><p>以下介绍几个常用标签。其他标签的具体使用见官方文档。</p><h2 id="lt-properties-gt"><a href="#lt-properties-gt" class="headerlink" title="&lt;properties&gt;"></a><code>&lt;properties&gt;</code></h2><p>该标签的作用是配置连接数据库的相关参数信息。<strong>可以通过<code>&lt;property&gt;</code>子标签配置，也可以使用<code>resource</code>属性引用外部配置文件</strong>，两种方式<strong>可以混合使用</strong>。在配置<code>&lt;dataSource&gt;</code>时，<strong>通过<code>$&#123;paramName&#125;</code>的方式获取到配置的值</strong>。</p><p>如快速入门中主配置文件可改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//...省略</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//...省略</span><br></pre></td></tr></table></figure><p>jdbc.properties：（<strong>该文件放在resource目录下</strong>）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">admin</span></span><br></pre></td></tr></table></figure><p><strong>一般把属性信息都配置在properties文件中，不使用property标签配置</strong>。</p><h2 id="lt-settings-gt"><a href="#lt-settings-gt" class="headerlink" title="&lt;settings&gt;"></a><code>&lt;settings&gt;</code></h2><p><code>&lt;settings&gt;</code> 用来配置mybatis的一些全局变量，以开启延迟加载为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis有很多全局变量，其他变量的详细介绍见：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">https://mybatis.org/mybatis-3/zh/configuration.html#settings</a></p><h2 id="lt-typeAliases-gt"><a href="#lt-typeAliases-gt" class="headerlink" title="&lt;typeAliases&gt;"></a><code>&lt;typeAliases&gt;</code></h2><p>该标签的作用是为Java类指定一个缩写别名，就不用每次指定类时都使用其全限定名。</p><p>如：</p><p><strong>type属性指定类的全限定名；alias属性指定别名</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通过该配置，在任何使用 <code>domain.blog.Autho</code> 的地方，都可以用author代替</strong>，且不区分大小写。</p><p>也可以在<code>&lt;typeAliases&gt;</code> 标签中使用<code>&lt;package&gt;</code>标签指定一个包名，<strong>对该包下的所有类会使用 Bean 的首字母小写的非限定类名来作为它的别名</strong>。如<code>domain.blog.Blog</code>的别名为blog。<strong>这种方法更被推荐使用</strong>。</p><p>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="lt-environments-gt"><a href="#lt-environments-gt" class="headerlink" title="&lt;environments&gt;"></a><code>&lt;environments&gt;</code></h2><p><code>&lt;environments&gt;</code>用于配置环境。<strong>可以配置多个数据库环境，但只能选择一种环境，通过default指定要使用的<code>&lt;environment&gt;</code> 的id</strong>。<strong>每个 SqlSessionFactory 实例只能对应一种环境</strong>，如想要连接两个数据库，则需要两个SqlSessionFactory 。</p><p>在<code>&lt;environments&gt;</code>通过<code>&lt;transactionManager&gt;</code> 来配置事务管理器。</p><p>以下来自官网：</p><p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：</p><ul><li><p>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</p></li><li><p>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为</p></li><li><p><strong>如果使用的是Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置</strong>。</p></li></ul><p><code>&lt;dataSource&gt;</code> 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。在<code>&lt;dataSource&gt;</code>通过type属性指定数据源类型，Mybatis提供了3种数据源类型：</p><ul><li><strong>UNPOOLED</strong>：每次请求数据库连接时打开一个连接，使用完时关闭连接。没有使用连接池的概念。适用那些对数据库连接可用性要求不高的简单应用程序。</li><li><strong>POOLED</strong>：使用了连接池，避免了创建新的连接实例时所必需的初始化和认证时间。</li><li><strong>JNDI</strong>：放置一个 JNDI 上下文的数据源引用。</li></ul><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="lt-mappers-gt"><a href="#lt-mappers-gt" class="headerlink" title="&lt;mappers&gt;"></a><code>&lt;mappers&gt;</code></h2><p>该标签用于<strong>指定映射文件的位置，即告诉Mybatis要到哪里去找Mapper对应的映射文件</strong>。</p><p>有多种配置方式：</p><ul><li>使用第一种方式时，是在resource目录下（类路径下）寻找映射文件。映射文件的目录结构要与其对应的Mapper的包结构一致，如<code>org/mybatis/builder/UserMapper.xml</code>对应<code>org.mybatis.builder.UserMapper</code>。**且要注意分隔符是 / 而不是 . ** </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="基本CRUD以及参数映射"><a href="#基本CRUD以及参数映射" class="headerlink" title="基本CRUD以及参数映射"></a>基本CRUD以及参数映射</h1><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><p>默认情况下，使用 <code>#&#123;&#125;</code> 时，MyBatis 会创建 <code>PreparedStatement</code> 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。</p><p>但<code>PreparedStatement</code> 的占位符不能用于一些元数据字段，如表名、列名。这时可以使用<code>$&#123;&#125;</code>，mybatis会直接插入一个不转义的字符串。</p><p>如要查询某个字段名为指定值的记录，不用在mapper中定义多个查询方法，如：<code>findById()</code>、<code>findByUsername()</code>。可以直接用一个方法：其中columnName指字段名，value指字段值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">selectByColumn</span><span class="params">(<span class="meta">@Param(&quot;columnName&quot;)</span> String columnName, <span class="meta">@Param(&quot;value&quot;)</span> String value)</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件中的sql语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByColumn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user where $&#123;columnName&#125;=#&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其中columnName将直接替换<code>$&#123;columnName&#125;</code>。</li></ul><p><strong>一般优先使用<code>#&#123;&#125;</code>，其使用的是PreparedStatement会更加安全。而<code>$&#123;&#125;</code>可能会引起SQL注入</strong>。</p><h2 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h2><ul><li><p><strong>对于方法形参到sql语句的参数映射</strong>：</p><ul><li><strong>当Mapper方法只有一个参数时，<code>#&#123;&#125;</code>内的值无需与方法形参名对应，可以任意指定</strong>。若是有多个形参：<ul><li>以param加上形参在参数列表中的位置来命名（从1开始），比如：<code>#&#123;param1&#125;、#&#123;param2&#125;</code>。</li><li>使用<code>@Param</code>注解修饰形参，通过其value属性自定义命名，并在<code>#&#123;&#125;</code>内使用对应命名。</li></ul></li><li>当传入的参数的一个JavaBean，要获取其属性，通过<code>#&#123;属性名&#125;</code>即可。（<strong>若是bean中含bean，则使用<code>#&#123;innerBean.paramName&#125;</code>的形式</strong>）</li><li>parameterType属性可以指定传入的参数类型。该属性是可选的，一般情况下mybatis都可以推断出具体传入语句的参数类型。</li></ul></li><li><p><strong>对于sql语句到返回值的参数映射</strong>：</p><ul><li><p><strong>通过resultType属性可以指定返回值类型。且当返回值是集合时，返回类型不是设置为集合，而是应指定其集合元素的类型</strong>。resultType适用于表的字段名与JavaBean的成员变量名一一对应的情况，MyBatis 会<strong>获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）</strong>。若是不对应将会抛出异常。这种情况可以使用<code>&lt;resultMap&gt;</code>标签。</p><blockquote><p>PS：当使用<code>#&#123;&#125;</code>从传入的对象中获取其属性值时是区分大小写的，如User对象有一个userName属性，若使用<code>#&#123;username&#125;</code>，Mybatis将会找不到userName属性，抛出异常。</p></blockquote></li><li><p><code>&lt;resultMap&gt;</code>标签可以对表字段与JavaBean属性不对应的情况进行手动映射。<strong>且手动映射与自动映射会相互配合</strong>。<strong>即在<code>&lt;resultMapL&gt;</code>中可以只手动映射不对应的字段，那些对应的字段可以省略，Mybatis会进行自动映射处理</strong>。<code>&lt;resultMap&gt;</code>配置完毕后，在<code>&lt;select&gt;</code> 等标签中通过resultMap属性引用。</p></li><li><p><strong>返回类型的配置不能省略</strong>。</p></li></ul></li></ul><p><code>&lt;resultMap&gt;</code>示例：</p><p>Book类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String bookAuthor;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="comment">//getter、setter、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>book表：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200915215129913.png" alt="image-20200915215129913"></p><p>可看到Book类的bookName、bookAuthor属性与book表的book_name，author不对应。</p><p>映射文件的配置：</p><ul><li><code>&lt;resultMap&gt;</code>的id属性<strong>唯一标识该映射</strong>。</li><li>type属性指定要映射的JavaBean类；<strong>id标签用于映射主键，result标签用于映射普通字段。property属性指定JavaBean的属性名，column属性指定表的字段名</strong>。</li><li>在select标签中使用<code>resultMap=&quot;bookMap&quot;</code>引用配置的映射。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;bookMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;bookName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;book_name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bookAuthor&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;bookMap&quot;</span>&gt;</span></span><br><span class="line">    select * from book where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    InputStream stream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    SqlSessionFactory factory = builder.build(stream);</span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line"></span><br><span class="line">    BookMapper mapper = session.getMapper(BookMapper.class);</span><br><span class="line">    Book book = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Book(id=1, bookName=Java疯狂讲义, bookAuthor=李刚, price=100)</span></span><br></pre></td></tr></table></figure><h2 id="lt-select-gt-★"><a href="#lt-select-gt-★" class="headerlink" title="&lt;select&gt; ★"></a><code>&lt;select&gt;</code> ★</h2><p>下文例子中的user表：其中，id是自增主键</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200915181249271.png" alt="image-20200915181249271"></p><p>User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//...set、getter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>----------------</code> </p><p>直接上例子：</p><p>UserMapper中查询相关方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id查询</span></span><br><span class="line"><span class="function">User <span class="title">selectById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询全部，返回类型是集合</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模糊查询。查询username中带有keyword的用户</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectByFuzzy</span><span class="params">(String keyword)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定字段和其字段值查询</span></span><br><span class="line"><span class="function">User <span class="title">selectByColumn</span><span class="params">(String columnName, String value)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">    select * from user where username = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByFuzzy&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user where username like #&#123;keyword&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByColumn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user where $&#123;param1&#125;=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>要注意的点</strong>：</p><ul><li>select标签中的<strong>id属性指定的是Mapper中的方法名</strong>。（对后文的<code>&lt;insert&gt;</code>等标签一样）</li><li>resultType属性指定返回值类型。例子中的user指User类，已使用别名。</li><li>注意selectAll方法的返回值的List集合，而对应select标签的resultType属性是List的元素User。</li><li>selectByColumn是根据字段名跟字段值进行查询。与上文例子相同。该mapper方法有两个参数，<strong>在sql语句中使用param+形参位置的形式映射参数</strong>。</li><li>在测试方法中，调用mapper的selectByFuzzy方法时，传入的参数是<code>%小%</code>。<strong>即进行模糊查询时，要注意传参时先拼接好通配符</strong>。</li></ul><p>测试方法：</p><p>测试类中使用了Junit的@Before初始化了SqlSessionFactory，并作为测试类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSessionFactory factory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    factory = builder.build(in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession();)&#123;</span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = mapper.selectById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id为2的User: &quot;</span> + user);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users = mapper.selectAll();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有User: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User u : users)&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询用户名中带有‘小’的用户</span></span><br><span class="line">        List&lt;User&gt; users2 = mapper.selectByFuzzy(<span class="string">&quot;%小%&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名中带有 小 的用户：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(User u : users2)&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user1 = mapper.selectByColumn(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查询username字段为张三的记录：&quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">id为2的User: User(id=2, username=李四, password=5896596)</span></span><br><span class="line"><span class="comment">所有User: </span></span><br><span class="line"><span class="comment">User(id=1, username=张三, password=123456)</span></span><br><span class="line"><span class="comment">User(id=2, username=李四, password=5896596)</span></span><br><span class="line"><span class="comment">User(id=3, username=王小强, password=666666)</span></span><br><span class="line"><span class="comment">User(id=4, username=许小红, password=777777)</span></span><br><span class="line"><span class="comment">用户名中带有 小 的用户：</span></span><br><span class="line"><span class="comment">User(id=3, username=王小强, password=666666)</span></span><br><span class="line"><span class="comment">User(id=4, username=许小红, password=777777)</span></span><br><span class="line"><span class="comment">查询username字段为张三的记录：User(id=1, username=张三, password=123456)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="lt-insert-gt-★"><a href="#lt-insert-gt-★" class="headerlink" title="&lt;insert&gt; ★"></a><code>&lt;insert&gt;</code> ★</h2><p>同上，直接看例子。</p><p>Mapper方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的映射文件配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into user values(null, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession=factory.openSession())&#123;</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">&quot;蜘蛛侠&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;555969&quot;</span>);</span><br><span class="line">        mapper.insert(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行插入后，获取user的id值：&quot;</span> + user.getId());</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：执行插入后，获取user的id值：11</span></span><br></pre></td></tr></table></figure><p><strong>要注意的点</strong>：</p><ul><li><p>注意到sql语句并没有插入id值（id是自增主键），<strong>可以通过<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code>的配置，获取执行插入操作后新记录的主键值，获取的主键值会返回给传入的JavaBean；keyProperty指定的是表的字段名</strong>，，如例子中执行插入操作后，把插入记录的id值赋值给user对象。</p><ul><li><p>也可以通过<code>&lt;selectKey&gt;</code>标签实现：（order属性值表示插入后或插入前获取主键）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select LAST_INSERT_ID();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user values(null, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在测试方法的最后，有一句<code>sqlSession.commit();</code>，<strong>mybatis默认开启事务，即autoCommit属性为false，所以执行插入操作后需要提交事务。也可以在获取sqlSession时指定autoCommit属性为true，如下：</strong></p><p>**<code>SqlSession sqlSession=factory.openSession(true)</code>**（更新、删除操作也一样）</p><p>否则操作将会回滚。</p></li></ul><h2 id="lt-delete-gt-amp-lt-update-gt"><a href="#lt-delete-gt-amp-lt-update-gt" class="headerlink" title="&lt;delete&gt; &amp; &lt;update&gt;"></a><code>&lt;delete&gt;</code> &amp; <code>&lt;update&gt;</code></h2><p>这两个元素与insert大同小异。看个简单示例即可。</p><p>Mapper方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update user set username=#&#123;username&#125;, password=#&#123;password&#125; where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession(<span class="keyword">true</span>))&#123;</span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">3</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;王宝强&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;666888&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mapper.update(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改了id为3的user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession(<span class="keyword">true</span>))&#123;</span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">        mapper.deleteById(<span class="number">14</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了id为14的user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽取可复用sql语句"><a href="#抽取可复用sql语句" class="headerlink" title="抽取可复用sql语句"></a>抽取可复用sql语句</h2><p>通过<code>&lt;sql&gt;</code>标签定义可重用的sql语句片段，通过<code>&lt;include&gt;</code>标签引用。</p><p>官方文档的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t1&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>Mybatis的动态sql可以<strong>使用简单的配置来实现根据条件拼接sql语句</strong>。让开发者可以不用过多关注于语法方面的问题。</p><p>下文例子中的数据表（employee）：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200916131813006.png" alt="image-20200916131813006" style="zoom:80%;" /><p>对应的JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String department;</span><br><span class="line">    <span class="keyword">private</span> Integer salary;</span><br><span class="line">    <span class="comment">//...set getter toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lt-if-gt"><a href="#lt-if-gt" class="headerlink" title="&lt;if&gt;"></a><code>&lt;if&gt;</code></h2><p>EmployeeMapper中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">selectByConditionIf</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from employee where gender=#&#123;gender&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>and name like #&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary != null&quot;</span>&gt;</span>and salary&gt;#&#123;salary&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>test属性设置了条件</strong>。当employee的相关属性不为空时，将会在where中添加对应条件。test属性中要使用传入参数的属性时，直接使用属性名即可。</p></li><li><p><strong>where关键字后必须带有一个条件，否则当所有if条件不满足时，sql语句将会出现语法错误：<code>select * from employee where</code>。</strong> </p></li><li><p>若是test中的条件要用到与或非，不能使用<code>&amp;&amp; ||</code>等符号，应使用<code>and not or</code>。如<code>author != null and author.name != null</code>。</p></li><li><p><strong>当所有条件都不满足，就只有<code>gender=#&#123;gender&#125;</code>一个条件</strong>。</p></li></ul><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession())&#123;</span><br><span class="line">        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line"></span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        employee.setName(<span class="string">&quot;%小%&quot;</span>);</span><br><span class="line">        employee.setSalary(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = mapper.selectByConditionIf(employee);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Employee e : employees)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Employee(id=1, name=小明, gender=男, department=保安部, salary=5000)</span></span><br><span class="line"><span class="comment">//Employee(id=3, name=小强, gender=男, department=保安部, salary=5000)</span></span><br></pre></td></tr></table></figure><h2 id="lt-choose-gt"><a href="#lt-choose-gt" class="headerlink" title="&lt;choose&gt;"></a><code>&lt;choose&gt;</code></h2><p><code>&lt;choose&gt;</code> 类似于Java的switch，即<strong>按顺序判断条件，若满足则拼接对应的语句，之后的条件不再判断。所有条件都不满时，则拼接<code>&lt;otherwise&gt;</code>中的语句</strong>。</p><p>示例：</p><p>EmployeeMapper中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">selectByConditionChoose</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from employee where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>and name like #&#123;name&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;salary != null&quot;</span>&gt;</span>and salary&gt;#&#123;salary&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and gender=#&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="lt-where-gt"><a href="#lt-where-gt" class="headerlink" title="&lt;where&gt;"></a><code>&lt;where&gt;</code></h2><p>相比于使用if，使用<code>&lt;where&gt;</code>标签在sql语句中不用出现where关键字。<strong>where元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句</strong>。<strong>若子句的开头为 “AND” 或 “OR”，where元素也会将它们去除</strong>。</p><p>示例：</p><p>Mapper方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">selectByConditionWhere</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionWhere&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from employee</span><br><span class="line">     <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span>and  gender=#&#123;gender&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>and name like #&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary != null&quot;</span>&gt;</span>and salary&gt;#&#123;salary&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当有条件满足时，mybatis会插入对应where子句。若没有条件满足，则会查询所有记录。</p><h2 id="lt-set-gt"><a href="#lt-set-gt" class="headerlink" title="&lt;set&gt;"></a><code>&lt;set&gt;</code></h2><p>与<code>&lt;where&gt;</code>类似，可通过<code>&lt;set&gt;</code> 实现动态更新语句。</p><p>示例：</p><p>Mapper方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateByCondition</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByCondition&quot;</span>&gt;</span></span><br><span class="line">    update employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span>gender = #&#123;gender&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;department != null&quot;</span>&gt;</span>department = #&#123;department&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary != null&quot;</span>&gt;</span>salary = #&#123;salary&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateByCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意以开启事务的方式获取SqlSession</span></span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession(<span class="keyword">true</span>))&#123;</span><br><span class="line">        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line"></span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setId(<span class="number">1</span>);</span><br><span class="line">        employee.setDepartment(<span class="string">&quot;程序员&quot;</span>);</span><br><span class="line">        employee.setSalary(<span class="number">15000</span>);</span><br><span class="line"></span><br><span class="line">        mapper.updateByCondition(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试方法，id为1的记录的department字段和salary字段被更新。</p><ul><li><strong>注意if元素里的sql语句尾部的逗号不可少（最后一个if可省略逗号）</strong>，否则会发送语法错误。</li><li><strong>当所有的if都不满足条件会发生语法错误</strong>。</li></ul><h2 id="lt-foreach-gt"><a href="#lt-foreach-gt" class="headerlink" title="&lt;foreach&gt;"></a><code>&lt;foreach&gt;</code></h2><p><code>&lt;foreach&gt;</code> 可以通过循环的方式获取集合中的值。尤其适合<code>IN</code>语句。</p><p>根据id集合查询的示例：</p><p>Mapper方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Employee&gt; <span class="title">selectByIdsWithForeach</span><span class="params">(List&lt;Integer&gt; ids)</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIdsWithForeach&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from employee</span><br><span class="line">    where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;collection&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByIdsWithForeach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession())&#123;</span><br><span class="line">        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取id为1、2、3的记录</span></span><br><span class="line">        ids.add(<span class="number">1</span>);</span><br><span class="line">        ids.add(<span class="number">2</span>);</span><br><span class="line">        ids.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = mapper.selectByIdsWithForeach(ids);</span><br><span class="line">        <span class="keyword">for</span>(Employee e : employees)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**<code>&lt;foreach&gt;</code> 的collection属性的属性值只能为<code>list</code>和<code>collection</code>**，使用别的命名比如ids会抛出以下异常：</p><blockquote><p>Cause: org.apache.ibatis.binding.BindingException: Parameter ‘ids’ not found. Available parameters are [collection, list]</p><p>从异常来看应该是只能使用这两种命名….</p></blockquote><p><strong>且Mapper方法的集合形参的参数名不用跟collection属性值相对应</strong>。</p><h1 id="Mybatis多表查询"><a href="#Mybatis多表查询" class="headerlink" title="Mybatis多表查询"></a>Mybatis多表查询</h1><h2 id="一对一-lt-association-gt"><a href="#一对一-lt-association-gt" class="headerlink" title="一对一(&lt;association&gt;)"></a>一对一(<code>&lt;association&gt;</code>)</h2><p>以学生（Student）和身份证（Card）为例，即一个学生对应一个身份证。</p><p>数据表如下：（表中的字段除了3个id字段，其他都是varchar类型，card_id是指向card的id字段的外键）</p><p>card：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200916223746339.png" alt="image-20200916223746339" style="zoom:80%;" /><p>student：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200916223847902.png" alt="image-20200916223847902" style="zoom:80%;" /><p>（省略了setter等）</p><p>Card类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String idNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写StudentMapper方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件（<strong>查询全部，并Student对应的Card封装进Student</strong>）：</p><ul><li><p>sql语句使用的是等值连接查询。</p></li><li><p><strong>cardMap和studentMap的id标签中的column属性值，分别是cid和sid，对应查询语句结果集的字段名，这里为s.id和c.id设置了别名</strong>。</p><blockquote><p>此处column属性值不能使用s.id和c.id，mybatis将无法解析。所以可通过为字段指定别名，将column值指定为对应别名。</p></blockquote></li><li><p>studentMap中<strong>使用了<code>&lt;association&gt;</code>标签</strong>来封装Student中的Card对象。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;cardMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;idNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id_number&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;student_name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;card&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;cardMap&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid,student_name,c.id cid,id_number</span><br><span class="line">    from student s</span><br><span class="line">    inner join card c</span><br><span class="line">    on s.card_id=c.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectALl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession())&#123;</span><br><span class="line">        StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">        List&lt;Student&gt; students = mapper.selectAll();</span><br><span class="line">        <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student(<span class="attribute">id</span>=2, <span class="attribute">studentName</span>=小明, <span class="attribute">card</span>=Card(id=1, <span class="attribute">idNumber</span>=111111))</span><br><span class="line">Student(<span class="attribute">id</span>=1, <span class="attribute">studentName</span>=张三, <span class="attribute">card</span>=Card(id=2, <span class="attribute">idNumber</span>=222222))</span><br><span class="line">Student(<span class="attribute">id</span>=3, <span class="attribute">studentName</span>=王大锤, <span class="attribute">card</span>=Card(id=3, <span class="attribute">idNumber</span>=333333))</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>&emsp;  </p><hr><h2 id="一对多-lt-collection-gt"><a href="#一对多-lt-collection-gt" class="headerlink" title="一对多(&lt;collection&gt;)"></a>一对多(<code>&lt;collection&gt;</code>)</h2><p>以班级（grade）和老师（Teacher）为例，一个班级对应多个老师</p><p>grade表：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200916233040044.png" alt="image-20200916233040044" style="zoom:80%;" /><p>teacher表：（grade_id为指向grade的外键）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200916233100274.png" alt="image-20200916233100274" style="zoom:80%;" /><p>对应的JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String gradeName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Teacher&gt; teachers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String teacherName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略了setter、getter、toString</span></span><br></pre></td></tr></table></figure><p>定义Mapper方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Grade&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>映射文件：</p><ul><li>先使用<code>&lt;resultMap&gt;</code>分别对两个表跟JavaBean进行映射。</li><li>gradeMap中<strong>使用了<code>&lt;collection&gt;</code>封装Grade中的Teacher</strong>，通过<code>resultMap</code>属性指定集合类型。property属性指定集合对应的JavaBean属性。</li><li>与一对一中一样，注意别名问题。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;teacherName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;teacher_name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;gradeMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;grade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;gid&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;gradeName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;grade_name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;teachers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;teacherMap&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;gradeMap&quot;</span>&gt;</span></span><br><span class="line">    select g.id gid, g.grade_name, t.id tid,t.teacher_name</span><br><span class="line">    from grade g</span><br><span class="line">    inner join teacher t</span><br><span class="line">    on t.grade_id=g.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession())&#123;</span><br><span class="line">        GradeMapper mapper = session.getMapper(GradeMapper.class);</span><br><span class="line">        List&lt;Grade&gt; grades = mapper.selectAll();</span><br><span class="line">        <span class="keyword">for</span>(Grade grade : grades)&#123;</span><br><span class="line">            System.out.println(grade);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：可看到与实际表数据对应。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Grade(<span class="attribute">id</span>=2, <span class="attribute">gradeName</span>=软件工程, teachers=[Teacher(<span class="attribute">id</span>=1, <span class="attribute">teacherName</span>=黄老师), Teacher(<span class="attribute">id</span>=2, <span class="attribute">teacherName</span>=徐老师), Teacher(<span class="attribute">id</span>=3, <span class="attribute">teacherName</span>=张老师)])</span><br><span class="line">Grade(<span class="attribute">id</span>=1, <span class="attribute">gradeName</span>=计算机科学与技术, teachers=[Teacher(<span class="attribute">id</span>=4, <span class="attribute">teacherName</span>=李老师)])</span><br><span class="line">Grade(<span class="attribute">id</span>=3, <span class="attribute">gradeName</span>=信息安全, teachers=[Teacher(<span class="attribute">id</span>=5, <span class="attribute">teacherName</span>=王老师), Teacher(<span class="attribute">id</span>=6, <span class="attribute">teacherName</span>=马老师)])</span><br></pre></td></tr></table></figure><p>&emsp;  </p><p>&emsp;  </p><hr><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>多对多其实本质就是一对多，相关的配置与一对多一样。</p><p>&emsp;  </p><p>&emsp;  </p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在上述示例的映射文件中，都是先使用<code>&lt;/resultMap&gt;</code>封装好表与JavaBean之间的映射，再在<code>&lt;association&gt;</code>和<code>&lt;collection&gt;</code>中使用resultMap属性指定即可。这样配置代码更加整洁。</p><p>也可以在<code>&lt;association&gt;</code>和<code>&lt;collection&gt;</code>中配置映射关系，如一对一中的studentMap可改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;student_name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;association property=&quot;card&quot; resultMap=&quot;cardMap&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;card&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;idNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id_number&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>其中，替代resultMap属性，通过javaType指定封装的类型</strong>，对于<code>&lt;collection&gt;</code>，则是使用ofType属性。</p><h1 id="Mybatis延迟加载"><a href="#Mybatis延迟加载" class="headerlink" title="Mybatis延迟加载"></a>Mybatis延迟加载</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>在多表查询的一对多中，在查询“一”时，有时并不需要将“多”也全部查询出来，<span style="color:red">什么时候需要用到，什么时候再查询</span>才更符合实际要求，不用造成不必要的系统开销</strong>。</p><p>在四种表关系中：<strong>一对<span style="color:red">多</span>、多对<span style="color:red">多</span>，通常情况下都是采用延迟加载</strong>；而<strong>一对<span style="color:red">一</span>（跟多对<span style="color:red">一</span>），通常情况下“一”都不可省略，所以一般都是采用立即加载</strong>（也有使用延迟加载的情况）。</p><p>Mybatis中可通过<strong>修改配置信息</strong>实现延迟加载。</p><p>&emsp;  </p><p>&emsp;  </p><hr><h2 id="实现延迟加载"><a href="#实现延迟加载" class="headerlink" title="实现延迟加载"></a>实现延迟加载</h2><p>实现延迟加载需要先设置mybatis的全局变量<code>lazyLoadingEnabled</code>为true（该值默认为false） ，表示开启延迟加载。</p><blockquote><p>若是3.4.1 及之前的版本，还需设置<code>aggressiveLazyLoading    </code>变量为false，其默认值是true。</p><p>该变量的官方解释：</p><p>开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载</p></blockquote><p>以上配置在主配置文件的settings标签中进行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过示例验证：</p><p>以学生（Student）和身份证（Card）为例，即一个学生对应一个身份证。</p><p>数据表如下：</p><p>card：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200916223746339.png" alt="image-20200916223746339" style="zoom:80%;" /><p>student：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200916223847902.png" alt="image-20200916223847902" style="zoom:80%;" /><p>Card类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String idNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Card</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被创建时输出内容。用于验证延迟加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;创建了一个Card对象...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个JavaBean对应的Mapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CardMapper</span> </span>&#123; <span class="function">Card <span class="title">selectById</span><span class="params">(Integer id)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;  <span class="function">List&lt;Student&gt; <span class="title">selectAll</span><span class="params">()</span></span>; &#125;</span><br></pre></td></tr></table></figure><p>映射文件：</p><p>CardMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mapper.CardMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;cardMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;idNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id_number&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;cardMap&quot;</span>&gt;</span></span><br><span class="line">        select * from card</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>StudentMapper.xml：</p><ul><li><strong>selectAll中的sql语句不用使用连接查询语句</strong>。</li><li>在association标签中，<strong>select指定了查询Student中的Card时使用的查询方法</strong>，<strong>属性值是Mapper方法的全限定名</strong>。column属性指定了用于查询card所需的id，<strong>即<code>select * from student</code>的查询结果集中的<code>card_id</code>字段</strong>。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;student_name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;card&quot;</span> <span class="attr">column</span>=<span class="string">&quot;card_id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.mapper.CardMapper.selectById&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLazyLoad</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession())&#123;</span><br><span class="line">        StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">        List&lt;Student&gt; students = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">        Student student = students.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出student的name：&quot;</span> + student.getStudentName());</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出student的card：&quot;</span> + student.getCard());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出是</strong>：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出student的name：张三</span><br><span class="line">---------------------</span><br><span class="line">创建了一个Card对象...</span><br><span class="line">输出student的card：Card(id=2, idNumber=222222)</span><br></pre></td></tr></table></figure><p>Card对象被创建时，会输出<code>创建了一个Card对象...</code>（见其类定义的构造器），<strong>通过输出可看出<code>mapper.selectAll()</code>执行时并没有创建Card对象。当调用了student的<code>getCard()</code>方法时才查询所需的Card对象</strong>。</p><blockquote><p>通过idea的debug不能看出延迟加载的效果。debug过程中查看students变量可发现所有的card都被创建完成。。。</p></blockquote><h1 id="Mybatis-的缓存机制"><a href="#Mybatis-的缓存机制" class="headerlink" title="Mybatis 的缓存机制"></a>Mybatis 的缓存机制</h1><p>Mybatis 使用到了两种缓存：<strong>本地缓存（一级缓存）和二级缓存</strong>。</p><h2 id="本地（一级）缓存"><a href="#本地（一级）缓存" class="headerlink" title="本地（一级）缓存"></a>本地（一级）缓存</h2><p><strong>每当一个新 session 被创建，MyBatis 就会创建一个与之相关联的本地缓存</strong>。<strong>任何在 session 执行过的查询结果都会被保存在本地缓存中，当再次执行参数相同的相同查询时，会返回缓存中的内容，而不用访问数据库</strong>。本地缓存将会在<strong>做出修改、事务提交或回滚，以及关闭 session 时清空，调用SqlSession的<code>void clearCache()</code>方法也可以情空缓存</strong>。</p><p>默认情况下，本地缓存数据的生命周期等同于整个 session 的周期。</p><p>简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession session = factory.openSession())&#123;</span><br><span class="line">        CardMapper mapper = session.getMapper(CardMapper.class);</span><br><span class="line">        Card card1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        Card card2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(card1==card2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出true，第二次查询获取的是缓存在SqlSession中的card对象。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/weixin_36380516/article/details/73194758">链接</a> </p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483937&idx=5&sn=4a049d7461b67c4135183db09ec97bcb&chksm=ebd74320dca0ca3691081597ac9db2447d51250d7aa819009231760977dd932b43a116fe44ba&scene=21#wechat_redirect">3y</a> </p></blockquote><p><strong>二级缓存是mapper级别的缓存，二级缓存是跨SqlSession的，对于mapper级别的缓存不同的sqlsession是可以共享的</strong>。</p><p>每个Mapper有一个二级缓存区域（<strong>按namespace分</strong>），两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。</p><p>如图：（图片来自第二个参考链接）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210422142625918.png" alt="image-20210422142625918"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;中文文档： &lt;a href=&quot;https://mybatis.org/mybatis-3/zh/index.html&quot;&gt;https://my</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Mybatis" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/Mybatis/"/>
    
    
    <category term="框架" scheme="http://example.com/Tag/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL概述</title>
    <link href="http://example.com/2021/08/25/MySQL/MySQL%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/08/25/MySQL/MySQL%E6%A6%82%E8%BF%B0/</id>
    <published>2021-08-25T06:06:50.385Z</published>
    <updated>2021-08-30T05:06:23.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        MySQL很牛逼。</p><p><strong><span style="color:red">MySQL是属于C/S架构的软件</span></strong>。</p><p>MySQL的优点：可将数据持久化到本地；可用sql语言进行查询，便于管理。</p><hr><h2 id="登录MySQL及环境变量"><a href="#登录MySQL及环境变量" class="headerlink" title="登录MySQL及环境变量"></a>登录MySQL及环境变量</h2><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><p>​        可通过MySQL自带的命令行（只能登录root用户）。</p><p>​        也可通过命令行：</p><p>​        <code>mysql -h localhost -P 3306 -u root -p </code> </p><p>​        <code>mysql -h localhost -P 3306 -u root -padmin</code> （<strong>用于连接远程</strong>）</p><p>​        <code>mysql -u root -pPassword</code> （<strong>连接本地MySQL</strong>）</p><h3 id="MySQL环境变量"><a href="#MySQL环境变量" class="headerlink" title="MySQL环境变量"></a>MySQL环境变量</h3><p>​        若以上命令不可用，可能原因是没有配置环境变量（<strong>若是使用msi安装包安装则MySQL会自动配置</strong>）。</p><p>​        手动配置过程：在<code>Path</code>环境变量中添加MySQL的安装目录中的bin目录路径即可。</p><hr><h2 id="MySQL语法规范及常用命令"><a href="#MySQL语法规范及常用命令" class="headerlink" title="MySQL语法规范及常用命令"></a>MySQL语法规范及常用命令</h2><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ul><li>MySQL中的<strong>命令以<code>;</code>或<code>\g</code>结束</strong>。</li><li>MySQL命令不区分大小写。</li><li>注释<ul><li>单行注释：<code>#注释</code>或<code>-- 注释</code>(空格必需)</li><li>多行注释：<code>/* 注释 */</code> </li></ul></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>进入MySQL后，可使用以下相关命令：</p><p>显示所有数据库：<strong><code>show databases;</code></strong> </p><p><code>----------------------------------</code> </p><p>使用指定数据库：<strong><code>use dababaseName;</code> </strong></p><p><code>----------------------------------</code>   </p><p>显示当前数据库中的所有表：<strong><code>show tables;</code> </strong></p><p><code>----------------------------------</code> </p><p>显示指定数据库的所有表（<strong>使用该命令后，当前数据库位置不变</strong>）：<strong><code>show tables from databaseName</code> </strong></p><p><code>----------------------------------</code> </p><p>查看表结构：<strong><code>desc tableName</code> </strong> </p><p><code>----------------------------------</code> </p><p>查看MySQL版本：</p><p>在MySQL中：<strong><code>select version();</code> </strong> </p><p>在MySQL外：<strong><code>mysql --version</code>或<code>mysql -V</code> </strong> </p><p><code>----------------------------------</code> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        MySQL很牛逼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;MySQL是属于C/S架</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="http://example.com/2021/08/25/MySQL/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/08/25/MySQL/MySQL%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-25T06:06:50.383Z</published>
    <updated>2021-08-30T05:01:24.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><blockquote><p>该笔记的实例代码中的数据库是<code>myemploees</code>。</p></blockquote><p>SQL语言的分类：</p><ul><li>DQL（Data Query Language）：数据查询语言。</li><li>DML（Data Management Language）：数据操作语言，修改表的语言，如插入、修改、删除语句。</li><li>DDL（Data Definition Language）：数据定义语言，如创建表、创建库。</li><li>TCL（Translation Control Language）：事物控制语言。</li></ul><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p><strong>tips：字符型、日期型的值用单引号括起来。</strong> </p><p>查询表中字段：<code>select queryList from tableName;</code> </p><p>查询所有字段：<code>select * from tableName;</code> </p><p>查询常量：<code>select 100;</code>或  <code>select &#39;string&#39;;</code> </p><p>查询表达式：<code>select 100*90;</code> </p><p>查询函数：<code>select version();</code> </p><p><code>-----------------------------------------------</code> </p><p>起别名（别名可用于字段名重复的情况）：</p><p><code>SELECT first_name AS 姓,last_name AS 名 FROM employees</code> </p><p>或</p><p><code>SELECT first_name 姓,last_name 名 FROM employees;</code> </p><p><code>SELECT salary AS &#39;out put&#39; FROM employees;</code></p><p><code>-----------------------------------------------</code> </p><p>去重：<code>SELECT DISTINCT job_id FROM employees</code> </p><p><code>-----------------------------------------------</code> </p><p>SQL中的+号：</p><p><strong>两个运算数都是数值型，作加法运算</strong>：<code>select 100+10;</code> </p><p><strong>有一个是字符串，则试图转化字符串为数字，若是转化失败则化为0</strong>：</p><p><code>select &#39;123&#39;+10;</code>  //133</p><p><code>select &#39;string&#39;+10;</code>  //0 + 10 = 10</p><p><code>SELECT 10 + &#39;10sdfef3s&#39; + 10;</code>若字符串的前端有数字，会进行转换，此处查询结果为10+10+10=30</p><p><strong>若有运算数为null，则结果为null</strong>：<code>select null+10;</code>  </p><p><strong>SQL中的+号没有字符串拼接功能，要拼接字符使用<code>concat()</code>函数</strong>：</p><p><code>SELECT CONCAT(last_name,first_name) AS 姓名 FROM employees</code> </p><p><code>-----------------------------------------------</code> </p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p><strong>条件查询语句</strong>：<strong><code>select 查询列表 from tableName where condition;</code></strong> </p><p>其中，<strong><span style="color:red;">筛选条件顺序为：tableName -&gt; condition -&gt; 查询列表</span></strong>。</p><h4 id="按条件表达式筛选"><a href="#按条件表达式筛选" class="headerlink" title="按条件表达式筛选"></a>按条件表达式筛选</h4><p>包含这些运算符的表达式：<strong><code>&gt;  &lt;  =  !=  &lt;&gt;(建议)  &gt;=  &lt;=</code></strong>  </p><p>eg：</p><p><code>SELECT * FROM employees WHERE salary&gt;12000;</code> </p><p><code>SELECT last_name, first_name FROM employees WHERE department_id&lt;&gt;20;</code> </p><h4 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h4><p><strong><code>and or not</code>（建议）或<code>&amp;&amp;  || !</code></strong>  （<strong>连接条件表达式</strong>）</p><ul><li><p><code>SELECT last_name, salary, commission_pct </code> </p><p><code>FROM employees </code> </p><p><code>WHERE salary&gt;=10000 AND salary&lt;=20000;</code> </p></li><li><p><code>SELECT * FROM employees</code><br><code>WHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;</code> </p></li></ul><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p><span style="font-size:20px;"><code>like</code></span>    </p><p><code>like</code>一般与通配符配合使用，如下：</p><ul><li><code>%</code>：表示任意多个字符，包括空字符。</li><li><code>_</code>：表示一个字符。</li></ul><p>eg：</p><p><code>SELECT * FROM employees WHERE last_name LIKE &#39;%a%&#39;;</code> </p><p><code>SELECT last_name,salary FROM employees WHERE last_name LIKE &#39;__t_b%&#39;;</code> </p><p>当需要查询包含通配符的字段，需要使用转义字符<code>\</code>，<strong>也可通过<code>escape</code>自定义转移字符</strong>。</p><p>eg：</p><p>查询last_name中第二个字符是_的字段：<strong><code>SELECT last_name FROM employees WHERE last_name LIKE &#39;_\_%&#39;;</code></strong> </p><p>或：<strong><code>SELECT last_name FROM employees WHERE last_name LIKE &#39;_$_%&#39; ESCAPE &#39;#39;;</code></strong>  </p><p><strong><span style="color:red;">like也可用于筛选int类型值</span></strong>，eg：</p><p><code>SELECT * FROM employees WHERE department_id LIKE &#39;1__&#39;;</code> </p><p><code>-------------------------------------------------------------------------------------</code> </p><p><span style="font-size:20px;"><strong><code>（not） between and</code></strong></span> （<strong>左右为闭区间</strong>） </p><p>代替<code>where value1&gt;= 100 and value1&lt;=120;</code>，<strong>代码更整洁</strong>。</p><p>eg：</p><p><code>SELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120;</code> </p><p><code>-------------------------------------------------------------------------------------</code> </p><p><span style="font-size:20px;"><code>in </code></span>   </p><p>若字段的值等于in列表内的任一值即满足条件。其中，<strong><span style="color:red">in列表中的值必须为同一类型或可兼容</span></strong>（如’123’可等于123），<strong>且不支持通配符</strong>。</p><p>eg：</p><p><code>SELECT last_name,job_id FROM employees WHERE job_id IN(&#39;IT_PROG&#39;,&#39;AD_VP&#39;);</code> </p><p><code>-------------------------------------------------------------------------------------</code> </p><p><span style="font-size:20px;"><code> is （not） null</code> </span></p><p><strong>MySQL中的=，&lt;&gt;不能比较字段值跟null，只能用<code>is null</code>或<code>is not null</code></strong>。eg：</p><p><code>SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NOT NULL;</code> </p><p><strong>MySQL中，有安全等与符号：<code>&lt;=&gt;</code> ，可用于普通值间的比较跟null值的比较</strong>。</p><p>eg：</p><p><code>SELECT last_name,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;</code> </p><p><code>-------------------------------------------------------------------------------------</code> </p><p><span style="font-size:20px;"><code>REGEXP</code></span> </p><p>使用正则表达式匹配。操作符见 <a href="https://www.runoob.com/mysql/mysql-regexp.html">菜鸟教程</a> 。</p><p>eg：<code>SELECT * FROM admin WHERE username REGEXP &#39;^谢&#39;</code>;</p><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><strong>排序查询语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> queryList</span><br><span class="line"><span class="keyword">from</span> tableName</span><br><span class="line"><span class="keyword">where</span> condition</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序列表名 <span class="keyword">asc</span>|<span class="keyword">desc</span>;  <span class="comment"># asc 升序；desc 降序，默认为asc</span></span><br></pre></td></tr></table></figure><p><strong>order by的排序列表可用别名、单个字段、多个字段、函数及表达式</strong>。</p><p>eg：</p><p>工资降序：</p><p><code>SELECT * FROM employees ORDER BY salary DESC;</code> </p><p>全部信息，年薪降序：</p><p><code>SELECT *,salary*12*(1+IFNULL(commission_pct,0)) yearSalary FROM employees ORDER BY yearSalary DESC;</code></p><p><strong>按多个字段排序</strong>：其中，<strong><span style="color:red">先将salary升序排序，再在每个salary相同的区间内，对这些记录的employee_id进行降序排序</span></strong>。</p><p><code>SELECT * FROM employees ORDER BY salary ASC,employee_id DESC;</code></p><hr><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p><strong>分组查询使用<code>group by</code>关键字，配合分组函数</strong>，<strong><span style="color:red">根据条件将记录分为若干组</span></strong>。语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有出现在group by后的列才能位于查询列表；下列的数字为语句执行顺序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">colum</span>,groupFunction(<span class="keyword">colum</span>)   <span class="comment">#5</span></span><br><span class="line"><span class="keyword">FROM</span> tableName  <span class="comment">#1（把整个表拿出来）</span></span><br><span class="line">[<span class="keyword">WHERE</span> condition]  <span class="comment">#2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> expr  <span class="comment">#3</span></span><br><span class="line">[<span class="keyword">HAVING</span> condition2]  <span class="comment">#4</span></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">colum</span>]  <span class="comment">#6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        其中，<strong>若有where字句，则必须放在from后；且<span style="color:red">只有出现在group by后的列（字段）才能位于查询列表</span>，<span style="color:red">其中，数字为底层执行顺序</span></strong>。<strong>分组函数将根据<code>GROUP BY</code>的分组情况分别作用于每一组</strong>。</p><p>​        一般不在having子句使用别名，原因是Oracle等数据库不支持，不使用别名从而有更好的通用性。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每个工种的最高工资</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="keyword">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">#每个位置上的部门个数</span></span><br><span class="line"><span class="keyword">SELECT</span> location_id,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> departments <span class="keyword">GROUP</span> <span class="keyword">BY</span> location_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加分组前的筛选</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为分组查询添加筛选条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询邮箱中带有a的，每个部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="keyword">AVG</span>(salary) 平均工资 </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure><h4 id="分组后筛选-having子句"><a href="#分组后筛选-having子句" class="headerlink" title="分组后筛选(having子句)"></a>分组后筛选(<code>having</code>子句)</h4><p>​        上述的有筛选条件的分组查询都是<strong>分组前的筛选</strong>，即在原始表上进行筛选。</p><p>​        有时需要对分组的后的结果再添加筛选条件（<strong>分组后的筛选</strong>），<strong>即对分组查询的结果集再添加筛选条件</strong>，这时<strong>where子句不能满足</strong>需求，<strong>需使用<code>having</code>子句，放在<code>group by</code>后面</strong>。</p><p>如下：</p><ul><li>例1中，先按部门id分组，查询出部门id和每个部门的员工个数，再在该查询基础上，使用having子句添加员工个数&gt;2的筛选条件。</li><li>例2分析见注释。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加分组后的筛选</span></span><br><span class="line"><span class="comment">#1.查询员工个数大于2的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查询每个工种有奖金的员工的最高工资&gt;12000的 的工种编号和最高工资</span></span><br><span class="line"><span class="comment">#对题目解析：</span></span><br><span class="line"><span class="comment">#查询每个工种(group by)有奖金(comm.. is not null，分组前，即可在原始表上进行筛选)的员工的</span></span><br><span class="line"><span class="comment">#最高工资(max salary)&gt;12000(having,即分组后）的 的工种编号和最高工资</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt;<span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.查询领导编号大于102的领导手下员工的最低工资&gt;5000 的领导编号和最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="keyword">MIN</span>(salary) <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id&gt;<span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MIN</span>(salary)&gt;<span class="number">5000</span>;</span><br><span class="line">                        </span><br></pre></td></tr></table></figure><p>分组条件也可以是函数或其他表达式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#按表达式或函数分组</span></span><br><span class="line"><span class="comment">#1.按员工姓名的长度分组，查询每一组的员工个数，并筛选出员工个数长度大于5的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(last_name) name_len,<span class="keyword">COUNT</span>(*) c <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> name_len</span><br><span class="line"><span class="keyword">HAVING</span> c&gt;<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><strong>按多个字段分组</strong>：<strong><span style="color:red;">按多个字段分组的最终结果其实就是：各分组字段值都一样的若干记录为一组</span>，分组函数再根据分组情况作用于每一组。若把分组的字段顺序改变，其结果将一样</strong>。。</p><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查询每个部门中，每个工种的员工平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,job_id,<span class="keyword">AVG</span>(salary) <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id,job_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.按平均工资降序排序</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id,department_id,<span class="keyword">AVG</span>(salary) <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id,department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>​        综上，分组查询的筛选条件分为分组前筛选跟分组后筛选，如下表</p><table><thead><tr><th align="center"></th><th align="center">数据源</th><th align="center">位置</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">分组前筛选</td><td align="center">原始表</td><td align="center">group by子句前</td><td align="center">where</td></tr><tr><td align="center">分组后筛选</td><td align="center">分组后的结果集</td><td align="center">group by子句后</td><td align="center">having</td></tr></tbody></table><p>其中，对分组函数做条件必须放在having子句中；能用分组前筛选则优先使用分组前筛选。</p><hr><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>（sql99标准）</p><p>​        当查询对象来自多个表时，需要用到连接查询。当<strong>连接查询没有添加任何限制时，将会发送笛卡尔积现象</strong>，即若表1有12行，表2有4行，查询结果将会有12*4=48行。</p><p>​        <strong><span style="color:red;">多表查询的结果可按以下思路：先查询出笛卡尔积结果，再根据where子句的条件进行筛选</span></strong>。</p><p>​        <strong>连接查询按功能可分为</strong>：</p><ul><li>内连接 <strong>inner</strong>（连接类型关键字可省略） <ul><li>等值连接 </li><li>非等值连接</li><li>自连接</li></ul></li><li>外连接<ul><li>左外连接 <strong>left [outer]</strong> </li><li>右外连接 <strong>right [outer]</strong> </li><li>全外连接（MySQL不支持）</li></ul></li><li>交叉连接 <strong>cross</strong> </li></ul><p><strong>连接查询的语法</strong>：</p><p>其中，<strong>连接类型关键字见上面功能分类</strong>。<strong>连接条件与筛选条件分开，可读性更高</strong>。#num表示执行顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表 <span class="comment">#6</span></span><br><span class="line"><span class="keyword">from</span> table1 别名   <span class="comment">#1</span></span><br><span class="line">【连接类型关键字】<span class="keyword">join</span> table2 别名  <span class="comment">#2（笛卡尔积）</span></span><br><span class="line"><span class="keyword">on</span> 连接条件<span class="number">1</span></span><br><span class="line">【<span class="keyword">join</span> table3 别名 </span><br><span class="line"><span class="keyword">on</span> 连接条件<span class="number">2</span>】</span><br><span class="line">【<span class="keyword">where</span> 筛选条件】 <span class="comment">#3</span></span><br><span class="line">【<span class="keyword">group</span> <span class="keyword">by</span> 分组条件】 <span class="comment">#4</span></span><br><span class="line">【<span class="keyword">having</span> 分组后筛选】 <span class="comment">#5</span></span><br><span class="line">【<span class="keyword">order</span> <span class="keyword">by</span> ...】 <span class="comment">#7</span></span><br></pre></td></tr></table></figure><h4 id="内连接-等值连接"><a href="#内连接-等值连接" class="headerlink" title="内连接-等值连接"></a>内连接-等值连接</h4><p>其查询结果与sql92标准中的一致。inner关键字可以省略；<strong>多表（3以上）查询中，需保证前后两个表有连接条件</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查询员工名以及对应的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,d.department_id </span><br><span class="line"><span class="keyword">FROM</span> employees e </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.名字包含e的员工名和工种名</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`last_name`</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%e%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.部门员工个数大于3的部门名以及对应员工个数，按个数降序</span></span><br><span class="line"><span class="keyword">SELECT</span> department_name,<span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(*) <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.员工名，部门名，工种名，按部门名降序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_name;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="内连接-非等值连接"><a href="#内连接-非等值连接" class="headerlink" title="内连接-非等值连接"></a>内连接-非等值连接</h4><p><strong>非等值连接与等值连接的不同之处在于：where子句使用<code>=</code>以外的条件运算符</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查询员工的工资跟工资等级（employees表跟job_grades表）</span><br><span class="line">SELECT last_name,salary,grade_level</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON salary BETWEEN lowest_sal AND highest_sal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查询员工的工资等级及该等级的工资的员工个数</span><br><span class="line">SELECT grade_level,COUNT(*)</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON salary BETWEEN lowest_sal AND highest_sal</span><br><span class="line">GROUP BY grade_level;</span><br></pre></td></tr></table></figure><h4 id="内连接-自连接"><a href="#内连接-自连接" class="headerlink" title="内连接-自连接"></a>内连接-自连接</h4><p>自连接，顾名思义，即<strong>一个表连接它本身</strong>。适用的表的特点：<strong><span style="color:red;">表中有一个字段指向当前表的另一个字段</span></strong>。</p><p>查询员工名，对应的领导id跟领导名：（领导id指向员工名）</p><p><strong><span style="color:red;">此处为两个employees表起了两个别名</span></strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.<span class="string">`last_name`</span>,a.<span class="string">`manager_id`</span>,b.<span class="string">`last_name`</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span> employees a,employees b</span><br><span class="line"><span class="keyword">WHERE</span> a.<span class="string">`manager_id`</span>=b.<span class="string">`employee_id`</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.<span class="string">`last_name`</span>,a.<span class="string">`manager_id`</span>,b.<span class="string">`last_name`</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span> employees a</span><br><span class="line"><span class="keyword">JOIN</span> employees b</span><br><span class="line"><span class="keyword">ON</span> a.<span class="string">`manager_id`</span>=b.<span class="string">`employee_id`</span>;</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p><strong>左/右外连接查询的特点</strong>：（<strong>注意主表、从表的概念</strong>）</p><ul><li>查询结果<strong>保留主表的所有记录</strong>，对于从表，若有与主表匹配额的，显示匹配的值；<strong>若没用匹配的，显示null</strong>。</li><li><strong>区分主表从表</strong>：<strong>对于左外连接，左主右从；对于右连接，右主左从</strong>。</li><li><strong>可用于查询两表除了交集部分的剩余不匹配的记录</strong>。</li></ul><p>​        </p><p>eg，例子只用了左外连接，右外连接同理，此处省略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#1.查询所有女神，且若女神有男朋友，显示男朋友名</span><br><span class="line">SELECT b.&#96;id&#96;,b.name,bo.boyName</span><br><span class="line">FROM beauty b</span><br><span class="line">LEFT JOIN boys bo</span><br><span class="line">ON b.&#96;boyfriend_id&#96;&#x3D;bo.&#96;id&#96;;</span><br><span class="line"></span><br><span class="line">#2.查询莫得男朋友的女神</span><br><span class="line">#先查询出上面例子的中间表，再使用筛选条件筛出莫得男朋友的女神</span><br><span class="line">SELECT b.name </span><br><span class="line">FROM beauty b </span><br><span class="line">LEFT JOIN boys bo </span><br><span class="line">ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96; </span><br><span class="line">WHERE bo.&#96;id&#96; IS NULL;</span><br></pre></td></tr></table></figure><p><strong>上述例题2的实现可见如下图解</strong>：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200714170433903.png" alt="image-20200714170433903" style="zoom:67%;" /><p>​        对于全外连接，MySQL不支持，<strong>理论上全外连接的查询结果是：对两个表的左外连接与右外连接的查询结果的并集</strong>。</p><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><p>​        交叉连接其实就是笛卡尔乘积的sql99标准写法。。。</p><p>即以下两钟查询结果相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.name,bo.boyName</span><br><span class="line">FROM beauty b</span><br><span class="line">CROSS JOIN boys bo;</span><br><span class="line"></span><br><span class="line">SELECT b.name,bo.boyName</span><br><span class="line">FROM beauty b,boys bo;</span><br></pre></td></tr></table></figure><hr><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>​        <strong>出现在其他语句内部的select语句，成为子查询语句；相应的，内部嵌套其他select语句的查询成为外查询语句</strong>。子查询必须放在<code>()</code>内。</p><p>​        <strong>子查询按结果集的行列数不同可分为</strong>：</p><ul><li><strong>标量子查询</strong>（结果集只有一行一列，<strong>即一个单一值</strong>）</li><li><strong>列子查询</strong>（一列多行）</li><li><strong>行子查询</strong>（一行多列）</li><li><strong>表子查询</strong>（多行多列）</li></ul><p>​        <strong>子查询可出现的位置</strong>：</p><ul><li>select后：<strong>仅支持标量子查询</strong>。</li><li>from后：支持上述所有查询。</li><li>where或having后：支持标量子查询、列、行子查询。</li><li>exists后（相关子查询）：表子查询。</li></ul><p>以下按子查询出现位置展开。</p><h4 id="where-having后的子查询"><a href="#where-having后的子查询" class="headerlink" title="where/having后的子查询"></a><span style="font-size:20px;">where/having后的子查询</span></h4><p>​        where/having后的子查询支持标量、列、行子查询。其中</p><ul><li><p>若条件表达式是<code>&gt;  &lt;  =  &lt;=  &gt;= &lt;&gt;</code>，<strong>则必须使用标量子查询，因为这些运算符只能匹配一个操作数</strong>。</p></li><li><p>若<strong>使用列子查询，一般搭配<code>in</code>，<code>any/some</code>，<code>all</code>关键字</strong>。</p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>in/not in</td><td>等于（或不等于）列表中的任一个</td></tr><tr><td>any/some（两者意义相同）</td><td>与列表中的任意一个比较满足条件，可用min、max代替</td></tr><tr><td>all</td><td>与列表中的所有值比较都满足条件</td></tr></tbody></table></li><li><p><strong>子查询的执行优先度高于主查询</strong>，因为主查询需用到子查询作为判断条件。</p></li></ul><p>标量子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#1.工资比Abel高的员工</span><br><span class="line">SELECT last_name FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line">#标量子查询</span><br><span class="line">SELECT salary </span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name&#x3D;&#39;Abel&#39;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#2.返回job_id与141号员工相同,sa1a比143号员工多的员工姓名, job_id和工资</span><br><span class="line">SELECT last_name,job_id,salary </span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id&#x3D;(</span><br><span class="line">SELECT job_id FROM employees</span><br><span class="line">WHERE employee_id&#x3D;141</span><br><span class="line">)</span><br><span class="line">AND</span><br><span class="line">salary&gt;(</span><br><span class="line">SELECT salary FROM employees</span><br><span class="line">WHERE employee_id&#x3D;143</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#3.查询最低工资大于50号部门最低工资 的 部门id 和 其最低工资</span><br><span class="line"></span><br><span class="line">SELECT department_id,MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary)&gt;(</span><br><span class="line">SELECT MIN(salary) FROM employees</span><br><span class="line">WHERE department_id&#x3D;50</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>列子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#1.返回1ocation_id是1400或1700的部门中的所有员工姓名</span><br><span class="line">SELECT last_name FROM employees</span><br><span class="line">WHERE department_id IN(</span><br><span class="line">SELECT department_id FROM locations</span><br><span class="line">WHERE location_id IN (1400,1700)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#2.返回其它工种中比（job_id为IT_PROG工种任一工资 1）低的员工的（员工号、姓名、job_id以及sa1ary 2）</span><br><span class="line">SELECT employee_id,last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ANY(</span><br><span class="line">SELECT DISTINCT salary FROM employees</span><br><span class="line">WHERE job_id&#x3D;&#39;IT_PROG&#39;</span><br><span class="line">) AND  job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure><p><strong>行子查询（一行多列或多行多列）</strong>：<strong>当筛选条件个数&gt;=2，且使用的判断符都一样，可以使用行子查询对多个字段同时判断</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询员工编号最小，工资最高的员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE (employee_id,salary)&#x3D;(</span><br><span class="line">SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="select后的子查询"><a href="#select后的子查询" class="headerlink" title="select后的子查询"></a><span style="font-size:20px;">select后的子查询</span></h4><p>select后的子查询只支持标量子查询。<strong><font color="red">若子查询结果为空，则返回null值</font></strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#每个部门的员工个数</span><br><span class="line">SELECT d.department_name,(</span><br><span class="line">SELECT COUNT(*) </span><br><span class="line">FROM employees e</span><br><span class="line">WHERE d.&#96;department_id&#96; &#x3D;e.department_id</span><br><span class="line">) &#39;count&#39; FROM departments d;</span><br></pre></td></tr></table></figure><h4 id="from后的子查询"><a href="#from后的子查询" class="headerlink" title="from后的子查询"></a><span style="font-size:20px;">from后的子查询</span></h4><p>from后的子查询可支持任何类型的子查询。eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查询每个部门的平均工资的工资等级</span><br><span class="line">#先查询每个部门的平均工资，再与工资等级表进行内连接查询</span><br><span class="line">SELECT ag_dep.*,grade_level</span><br><span class="line">FROM (</span><br><span class="line">SELECT department_id,AVG(salary) ag</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line">INNER JOIN job_grades j</span><br><span class="line">ON ag_dep.ag BETWEEN j.&#96;lowest_sal&#96; AND j.&#96;highest_sal&#96;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exists后的子查询"><a href="#exists后的子查询" class="headerlink" title="exists后的子查询"></a><span style="font-size:20px;">exists后的子查询</span></h4><p>**exists函数语法：<code>exists(查询语句)</code>**。</p><p><strong>当查询语句的结果集不为空，则返回1，否则返回0</strong>。</p><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#有员工的部门名</span><br><span class="line">SELECT department_name </span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">SELECT * </span><br><span class="line">FROM employees e</span><br><span class="line">WHERE e.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 用列子查询</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.&#96;department_id&#96; </span><br><span class="line">IN(</span><br><span class="line">SELECT e.department_id</span><br><span class="line">FROM employees e</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="分页查询（Limit）"><a href="#分页查询（Limit）" class="headerlink" title="分页查询（Limit）"></a>分页查询（Limit）</h3><p>​        当要显示的查询结果过多，只需先显示部分记录时，可用<code>limit</code>进行分页查询。**<code>limit</code>语句要放在查询语句的最后**。</p><p>​        语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit size #显示从第一条记录开始的size条记录</span><br><span class="line"></span><br><span class="line">-- 显示从第pos（索引从0开始）条开始的size条记录</span><br><span class="line">limit pos,size </span><br><span class="line">-- 或</span><br><span class="line">limit pos offset size</span><br></pre></td></tr></table></figure><p><strong>对于web应用中的分页查询，假如要显示第page页，每页有size个记录，则查询语句为：</strong> </p><p><strong><code>select * from tableName limit (page-1)*size,size;</code></strong> </p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>&emsp;&emsp;<strong>联合查询的作用是将多条查询语句的结果集合并为一个结果集</strong>。当要查询的<strong>信息来自多个表</strong>，且要查询的信息对应的<strong>字段在这些表中的类型一致</strong>，但这些表又<strong>没有直接关联</strong>，这时可使用联合查询。<strong>联合查询使用<code>UNION</code>关键字</strong>。</p><p>联合查询的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>联合查询的特点：</p><ul><li><strong>多条查询语句的查询列数必须一致</strong>。</li><li>每一列的类型必须一致；为了查询结果的正确显示，字段顺序也要一致（<strong>不一致不会报错，但结果会错误显示</strong>）。</li><li><strong>union关键字默认去重（若是多个字段，则全部字段值相同才算相等），可使用<code>union all</code>显示重复项</strong>。</li><li><strong>查询结果集的字段名与第一条查询语句的查询字段对应</strong>。</li></ul><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,cname,csex <span class="keyword">from</span> t_ca <span class="keyword">where</span> csex=<span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_id,tName,tGender <span class="keyword">from</span> t_ua <span class="keyword">where</span> tGender=<span class="string">&#x27;male&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>&emsp;&emsp;DML（Data Manage Language），数据操作语言，用于<strong>对表进行插入（insert）、删除（delete）、更新（update）操作</strong>。</p><h3 id="插入（insert）"><a href="#插入（insert）" class="headerlink" title="插入（insert）"></a>插入（insert）</h3><p>&emsp;&emsp;插入语句的语法有两种，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name[(colum1, colum2, ...)]  <span class="comment">#该部分省略时默认所有字段</span></span><br><span class="line"><span class="keyword">VALUES</span>(value1, value2, ...)</span><br><span class="line">[, (value11, value22, ...)] ; <span class="comment">#可同时插入多个记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">SET</span> colum1=value1, colum2=value2, ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name[(colum1, colum2, ...)]</span><br><span class="line"><span class="keyword">SELECT</span> ...;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一种方式可以同时插入多个记录，<strong>字段列表可省略，省略时默认插入表对应的所有字段</strong>；当只是要插入一条记录，且插入少数字段，可使用第二种方式，更为简便，<strong>但不支持插入多条记录</strong>。<strong><span style="color:red;">还可以通过子查询语句插入记录，此时子查询语句的查询列表要与要插入的表的字段对应</span></strong>。</p><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="string">&#x27;女朋友&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;2000-02-26&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="literal">NULL</span>, <span class="number">2</span>); <span class="comment">#主键部分写null即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#插入多条记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">NAME</span>, sex, borndate, phone) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;女朋友&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;2000-02-26&#x27;</span>, <span class="string">&#x27;4546984&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;迪丽热巴&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;2020-02-26&#x27;</span>, <span class="string">&#x27;549884&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用第二种语法</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">&#x27;ggggg&#x27;</span>, borndate=<span class="string">&#x27;1998-02-25&#x27;</span>, phone=<span class="string">&#x27;8582321&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过子查询插入值。eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> beauty(<span class="keyword">id</span>,<span class="keyword">name</span>,phone)</span><br><span class="line"><span class="keyword">select</span> <span class="number">26</span>,<span class="string">&#x27;宋茜&#x27;</span>,<span class="string">&#x27;856132123&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="更新（update）"><a href="#更新（update）" class="headerlink" title="更新（update）"></a>更新（update）</h3><p>​        更新表的SQL语句语法：<strong>其中，更新多表记录就是先将多个表连接起来，再对连接后的结果集进行更改。更改操作将作用到原表</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新单表记录</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> colum1=new_value1, colum2=new_value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> condition; <span class="comment">#若不加筛选条件，会对字段对应的所有记录修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新多表记录(sql99标准)</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name1 [<span class="keyword">alias</span>]</span><br><span class="line">JOIN_TYPE <span class="keyword">JOIN</span> table_name2 [<span class="keyword">alias</span>]</span><br><span class="line"><span class="keyword">ON</span> join_condition</span><br><span class="line"><span class="keyword">SET</span> colum1=new_value1, colum2=new_value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> condition;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> boys </span><br><span class="line"><span class="keyword">SET</span> boyname=<span class="string">&#x27;张飞&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> boyname=<span class="string">&#x27;鹿晗&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#多表更新</span></span><br><span class="line"><span class="comment">#修改张无忌的女朋友的电话号码为114455。需要先将boys表跟beauty表进行内连接</span></span><br><span class="line"><span class="keyword">UPDATE</span> boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> bo.<span class="string">`id`</span>=be.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">SET</span> be.<span class="string">`phone`</span>=<span class="string">&#x27;114455&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">&#x27;张无忌&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="删除（delete）"><a href="#删除（delete）" class="headerlink" title="删除（delete）"></a>删除（delete）</h3><p>​        删除语句会删除满足条件的所有记录。且删除语句也支持单表跟多表的删除，其语法如下：其中：</p><ul><li>多表删除中，<strong>若只是想删除其中一个表的记录，DELETE后的只写要删除的表的表名即可</strong>。总之，delete后写上要删除的记录对应的表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单表</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition;  <span class="comment">#若不加筛选条件，该语句会删除整个表的记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多表</span></span><br><span class="line"><span class="keyword">DELETE</span> alias1,alias2</span><br><span class="line"><span class="keyword">FROM</span> table1_name alias1</span><br><span class="line">[join_type] <span class="keyword">join</span> table2_name alias2</span><br><span class="line"><span class="keyword">ON</span> join_condition</span><br><span class="line"><span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> beauty <span class="keyword">where</span> phone <span class="keyword">like</span> <span class="string">&#x27;%9&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#多表删除（该例子只删除beauty表）</span></span><br><span class="line"><span class="comment">#删除张无忌的女朋友的信息</span></span><br><span class="line"><span class="keyword">DELETE</span> be</span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty be</span><br><span class="line"><span class="keyword">ON</span> bo.<span class="string">`id`</span>=be.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">&#x27;张无忌&#x27;</span>;</span><br></pre></td></tr></table></figure><p>当要删除整个表的记录，可以使用<code>truncate</code>关键字，语法是<code>TRUNCATE [TABLE] table_name;</code>。</p><p>使用delete删除跟truncate删除的<strong>区别</strong>：</p><ul><li>truncate不能加<code>where</code>。</li><li>truncate的删除效率稍微高一点。</li><li>若表中有自增长列，<strong>使用delete删除后不会改变当前的自增长值</strong>；<strong>而使用truncate删除后自增长值变为1</strong>。</li><li><strong>truncate不能返回受影响的记录数，而delete可以</strong>。</li><li><strong style="color:red">在事务方面</strong>：<strong>delete是可以回滚的，而truncate不可回滚</strong>。</li></ul><blockquote><p>以下来自 <a href="https://www.yiibai.com/mysql/truncate-table.html">MySQL TRUNCATE TABLE语句简介</a> </p></blockquote><p>如果使用 InnoDB表，MySQL将在删除数据之前检查表中是否有可用的外键约束。 以下是一些情况：</p><ul><li>如果表具有任何外键约束，则<code>TRUNCATE TABLE</code>语句会逐个删除行。如果外键约束具有<code>DELETE CASCADE</code>动作，则子表中的相应行也将被删除。</li><li>如果外键约束没有指定 DELETE CASCADE 动作，<strong>则<code>TRUNCATE TABLE</code>将逐个删除行，并且遇到由子表中的行引用的行时（即其他表的外键指向该表的字段），它将停止并发出错误</strong>。</li><li>如果表没有任何外键约束，则<code>TRUNCATE TABLE</code>语句将删除该表并重新创建一个具有相同结构的新表，这比使用<code>DELETE</code>语句特别是对于大表更快更有效。</li></ul><p>如果使用其他存储引擎，则 <code>TRUNCATE TABLE</code> 语句将删除并重新创建一个新表。</p><p>此外，<code>TRUNCATE TABLE</code>语句不使用<code>DELETE</code>语句，因此与表关联的<a href="http://www.yiibai.com/mysql/triggers.html">DELETE触发器</a>将不被调用。</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>​        数据定义语言（Data Define Language， DDL）用于对数据库、表进行创建、修改、删除操作。</p><h3 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h3><p>库的相关语法如下：<strong>其中，对于创建、删除库，若是库已存在或不存在会报错，可使用<code>IF (NOT) EXISTS</code>进行判断，使语句正确执行</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] database_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改库</span></span><br><span class="line"><span class="comment">#修改库名（该语法似乎不用了）</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">DATABASE</span> database_name <span class="keyword">TO</span> new_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改字符集</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> database_name <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> character_name;</span><br></pre></td></tr></table></figure><h3 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h3><h4 id="1-表的创建"><a href="#1-表的创建" class="headerlink" title="1.表的创建"></a>1.表的创建</h4><p>创建表的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name(</span><br><span class="line">colum_name COLUM_TYPE [(<span class="keyword">length</span>) 约束],</span><br><span class="line">colum_name COLUM_TYPE [(<span class="keyword">length</span>) 约束],</span><br><span class="line">    ...</span><br><span class="line">    colum_name COLUM_TYPE [(<span class="keyword">length</span>) 约束],</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">bname <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">author <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-表的修改"><a href="#2-表的修改" class="headerlink" title="2.表的修改"></a>2.表的修改</h4><p>表的修改有修改列名、修改列的类型或约束、添加新列、删除列以及修改修改表名。对应的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表</span></span><br><span class="line">    <span class="comment">-- 修改表本身的选项</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 表的选项（具体选项可见 <span class="number">5.</span>-）</span><br><span class="line">        eg: <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ENGINE</span>=MYISAM;</span><br><span class="line">    <span class="comment">-- 对表进行重命名</span></span><br><span class="line">        <span class="keyword">RENAME</span> <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 新表名</span><br><span class="line">        <span class="keyword">RENAME</span> <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        <span class="comment">-- RENAME可以交换两个表名</span></span><br><span class="line">    <span class="comment">-- 修改表的字段机构</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 操作名</span><br><span class="line">        <span class="comment">-- 操作名</span></span><br><span class="line">            <span class="keyword">ADD</span>[ <span class="keyword">COLUMN</span>] 字段定义       <span class="comment">-- 增加字段</span></span><br><span class="line">                <span class="keyword">AFTER</span> 字段名          <span class="comment">-- 表示增加在该字段名后面</span></span><br><span class="line">                <span class="keyword">FIRST</span>               <span class="comment">-- 表示增加在第一个</span></span><br><span class="line">            <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(字段名)   <span class="comment">-- 创建主键</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [索引名] (字段名)<span class="comment">-- 创建唯一索引</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">INDEX</span> [索引名] (字段名) <span class="comment">-- 创建普通索引</span></span><br><span class="line">            <span class="keyword">DROP</span>[ <span class="keyword">COLUMN</span>] 字段名      <span class="comment">-- 删除字段</span></span><br><span class="line">            <span class="keyword">MODIFY</span>[ <span class="keyword">COLUMN</span>] 字段名 字段属性     <span class="comment">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span></span><br><span class="line">            <span class="keyword">CHANGE</span>[ <span class="keyword">COLUMN</span>] 原字段名 新字段名 字段属性      <span class="comment">-- 支持对字段名修改</span></span><br><span class="line">            <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>    <span class="comment">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名 <span class="comment">-- 删除索引</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键    <span class="comment">-- 删除外键</span></span><br><span class="line">        <span class="comment">-- 删除约束</span></span><br><span class="line">        <span class="comment"># 除了上面3个drop，删除一些列级约束可以通过modify</span></span><br><span class="line">        <span class="keyword">MODIFY</span> [<span class="keyword">COLUMN</span>] 字段名 字段类型 [新的约束];  <span class="comment">-- 通过这种方法重新让字段没有约束越换成新的约束</span></span><br></pre></td></tr></table></figure><p>TIPS：**表的修改中不支持<code>if (not) exists</code>**。</p><p>对于自增的主键字段，在删除若干记录再重新插入数据时，会出现id值“断层”，可以通过以下sql语句修改自增值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name AUTO_INCREMENT &#x3D; N;</span><br></pre></td></tr></table></figure><h4 id="3-表的删除"><a href="#3-表的删除" class="headerlink" title="3.表的删除"></a>3.表的删除</h4><p><code>DROP TABLE [IF EXISTS] table_name</code>.</p><p>在sql脚本文件中写表或库创建的语句时，可以先删除表或库再创建，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> database_name;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> database_name;</span><br></pre></td></tr></table></figure><h4 id="4-表的复制"><a href="#4-表的复制" class="headerlink" title="4.表的复制"></a>4.表的复制</h4><p>表的复制可分为：</p><ul><li><p><strong>通过<code>LIKE</code>关键字</strong>仅复制表的结构（<strong>复制全部字段，不包含数据</strong>）：<strong><code>CREATE TABLE copy_table_name LIKE exists_table;</code></strong> </p></li><li><p>复制表的结构（<strong>部分或全部字段</strong>）跟数据（<strong>部分或全部数据</strong>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy_table_name </span><br><span class="line"><span class="keyword">SELECT</span> 查询列表 <span class="keyword">FROM</span> exists_table</span><br><span class="line"><span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><ul><li><strong>通过查询列表来选择要复制的字段（使用<code>select *</code>即实现复制全部字段）</strong>。</li><li>通过<code>where</code>来筛选要复制的数据。<strong>可以通过<code>where 0</code>来过滤掉全部的数据，即只复制部分或全部字段</strong>；也可以直接去掉where来复制所选字段对应的全部数据。</li></ul></li></ul><h4 id="5-表的选项-查看表结构"><a href="#5-表的选项-查看表结构" class="headerlink" title="5.表的选项/查看表结构"></a>5.表的选项/查看表结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">表选项</span><br><span class="line">    <span class="comment">-- 字符集</span></span><br><span class="line">        CHARSET = charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    <span class="comment">-- 存储引擎</span></span><br><span class="line">        ENGINE = engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory/Heap BDB <span class="keyword">Merge</span> Example CSV MaxDB <span class="keyword">Archive</span></span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        <span class="keyword">InnoDB</span>表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">SHOW</span> <span class="keyword">ENGINES</span> <span class="comment">-- 显示存储引擎的状态信息</span></span><br><span class="line">        <span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> 引擎名 &#123;<span class="keyword">LOGS</span>|<span class="keyword">STATUS</span>&#125; <span class="comment">-- 显示存储引擎的日志或状态信息</span></span><br><span class="line">    <span class="comment">-- 自增起始数</span></span><br><span class="line">        AUTO_INCREMENT = 行数</span><br><span class="line">    <span class="comment">-- 数据文件目录</span></span><br><span class="line">        <span class="keyword">DATA</span> <span class="keyword">DIRECTORY</span> = <span class="string">&#x27;目录&#x27;</span></span><br><span class="line">    <span class="comment">-- 索引文件目录</span></span><br><span class="line">        <span class="keyword">INDEX</span> <span class="keyword">DIRECTORY</span> = <span class="string">&#x27;目录&#x27;</span></span><br><span class="line">    <span class="comment">-- 表注释</span></span><br><span class="line">        <span class="keyword">COMMENT</span> = <span class="string">&#x27;string&#x27;</span></span><br><span class="line">    <span class="comment">-- 分区选项</span></span><br><span class="line">        <span class="keyword">PARTITION</span> <span class="keyword">BY</span> ... (详细见手册)</span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 （信息更详细）</span><br><span class="line">    <span class="keyword">DESC</span> 表名 / <span class="keyword">DESCRIBE</span> 表名 / <span class="keyword">EXPLAIN</span> 表名 / <span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">LIKE</span> <span class="string">&#x27;PATTERN&#x27;</span>]</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> [<span class="keyword">FROM</span> db_name] [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]  </span><br></pre></td></tr></table></figure><hr><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><p>MySQL的数据类型有：</p><ul><li>数值型：<ul><li>整型</li><li>小数：定点、浮点</li></ul></li><li>字符型：<ul><li>短文本：char、varchar</li><li>长文本：text、blob(较长的二进制数据)</li></ul></li><li>日期型</li></ul><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>​        整形数据按字节大小可分为（括号内为字节数）：<strong>tinyint(1)、smallint(2)、mediumint(3)、int/integer(4)、bigint(8)</strong>。</p><p><strong>整形数据的特点</strong>：</p><ul><li><p>整形数据有有符号数和无符号数，默认是有符号数；要设置无符号数需在建表时添加 <strong><code>UNSIGNED</code>关键字</strong>。如：</p><p><code>create table test(t1 int, t2 int unsigned);</code>。</p></li><li><p>若插入的数值<strong>超出了类型值的范围</strong>，会报<code>out of range</code>异常，<strong>并停止插入操作</strong>。</p></li><li><p><strong><span style="color:red">整型值的长度指的是最多能显示出来有多少个数字</span></strong>。若无指定，每种类型的整型都有默认长度。建表时可以使用<code>ZEROFILL</code>关键字，当不足长度时用0进行左填充。eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testss(</span><br><span class="line">t1 <span class="built_in">INT</span>(<span class="number">7</span>) ZEROFILL</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testss <span class="keyword">VALUES</span>(<span class="number">55</span>);<span class="comment">#插入55，因为使用了zerofill关键字，会对55左填充0，即0000055.</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h3><p>小数类型有浮点型和定点型：</p><ul><li>浮点型<ul><li>float(M, D)</li><li>double(M, D)</li></ul></li><li>定点型（<strong>高精度</strong>）：dec/decimal(M, D)</li></ul><p>​        其中（M, D)的形式在建表时使用，<strong>M指整个数值的长度（意义同整型的长度），即整数部分长度+小数部分长度；D指小数部分的长度</strong>。也可省略，省略时dec默认是（10，0），而float跟double会自适应插入的数。</p><p>FLOAT 和 DOUBLE 为浮点类型，<strong>DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价</strong>。</p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符型的分类：</p><ul><li><p><strong>短文本</strong></p><ul><li>char：<strong>建表时最大字符数可以省略，默认为1。该类型是固定长度的字符，即<span style="color:red">不管存入的数据是多少个字符，占用的空间都是指定的最大字符数</span></strong>。</li><li>varchar：<strong>建表时最大字符数<span style="color:red">不可以省略</span>。该类型是可变长度的字符，即<span style="color:red">占用的空间根据存入的数据自适应，多大就存多少空间</span>（存入数据&lt;=指定的最大字符数时）</strong>。</li><li>VARCHAR 这种变长类型能够<strong>节省空间</strong>，因为只需要存储必要的内容。<strong>但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作</strong>。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</li><li>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格</li></ul></li><li><p><strong>长文本</strong></p><ul><li>text</li><li>blob（存放较大的二进制）</li></ul></li><li><p>其他</p><ul><li><p>binary、varbinary：类似char跟varchar。用于保存较短的二进制。</p></li><li><p>enum，用于保存枚举（只能保存一个数据），保存的值必须是枚举列表之一，枚举列表在建表时指定，eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> enumm(</span><br><span class="line">colum1 ENUM(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enumm <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enumm <span class="keyword">VALUES</span>(<span class="string">&#x27;A&#x27;</span>);<span class="comment">#mysql不区分大小写，插入a、A效果一样</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enumm <span class="keyword">VALUES</span>(<span class="string">&#x27;d&#x27;</span>);<span class="comment">#插入的值不是枚举列表之一，报错</span></span><br></pre></td></tr></table></figure></li><li><p>set，用于保存集合（可以保存多个数据），和enum类似，但可以保存多个值。eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sett(</span><br><span class="line">s1 <span class="keyword">SET</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sett <span class="keyword">VALUES</span>(<span class="string">&#x27;a,b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sett <span class="keyword">VALUES</span>(<span class="string">&#x27;a,b,e&#x27;</span>);<span class="comment">#报错</span></span><br></pre></td></tr></table></figure></li><li><p>enum、set值占用的存储空间随列表值个数的增加而增加。</p></li></ul></li></ul><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><p><strong>日期类型如下表</strong>：</p><table><thead><tr><th>类型</th><th>字节</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>DATE</td><td>4</td><td>1000-01-01（<strong>只有日期</strong>）</td><td>9999-12-31</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00（<strong>日期+时间</strong>）</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>19700101080001（<strong>日期+时间</strong>）</td><td>2038 年的某个时刻</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59（<strong>只有时间</strong>）</td><td>838:59:59</td></tr><tr><td>YEAR</td><td>1</td><td>1901（<strong>只有年</strong>）</td><td>2155</td></tr></tbody></table><h4 id="timestamp和datetime"><a href="#timestamp和datetime" class="headerlink" title="timestamp和datetime"></a><span style="color:red">timestamp和datetime</span></h4><ul><li><p><strong>时间范围不一样</strong>，<strong>TIMESTAMP 要小很多</strong> ，2038 年到期。timestamp 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，<strong>使用 4 个字节，只能表示从 1970 年到 2038 年</strong>。</p></li><li><p><strong>对于TIMESTAMP，它<span style="color:red">把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区（即根据系统变量<code>time_zone</code>的值）对应的时间进行返回</span>。而对于DATETIME，不做任何改变，原样输入和输出</strong>。</p></li><li><p>timestamp<strong>更能反应实际的日期</strong>。</p></li></ul><p>eg：（tips：<strong>中国位于东八时区</strong>，当前时间是2020-7-15 21:40分左右）</p><p>创建表并插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> timee(</span><br><span class="line">t1 DATETIME,</span><br><span class="line">t2 <span class="built_in">TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> timee <span class="keyword">VALUES</span>(<span class="keyword">NOW</span>(),<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure><p>使用<code>select * from timee;</code>查询表，如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210315154030410.png" alt="image-20210315154030410"></p><p>设置当前时区为东九区：<code>SET time_zone=&#39;+9:00&#39;;</code> ，查询：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210315154114696.png" alt="image-20210315154114696"></p><p>可见，两次查询t1的两个值都不变，插入时的时间是什么，查询出的是什么。</p><p><strong>而t2查询出的值是保存的UTC时间转化为当前时区的时间</strong>。<strong>比如第一行的t2值，插入数据时是在东八区，该时刻的东九区比东八区快一个小时</strong>。</p><hr><h2 id="MySQL约束"><a href="#MySQL约束" class="headerlink" title="MySQL约束"></a>MySQL约束</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​        约束就是一种限制，用于限制表中的数据，<strong>使数据有更好的准确和可靠性</strong>。</p><p>MySQL中的常见约束：</p><table><thead><tr><th>约束类型</th><th>主键</th><th>外键</th><th>唯一</th><th>非空</th><th>自增</th><th>默认值</th></tr></thead><tbody><tr><td>关键字</td><td>primary key</td><td>foreign key</td><td>unique</td><td>not null</td><td>auto_increment</td><td>default</td></tr><tr><td>含义</td><td>相当于unique+<br>not null，一般用于id</td><td>用于限制两个表的关系，<br/>即从表的某个字段指向主表的某一字段</td><td>唯一性、<br/><strong>可以为空</strong></td><td>不能为空</td><td>自增</td><td>指定字段的默认值</td></tr></tbody></table><p>​        添加约束可以在<strong>创建表时或修改表时</strong>。</p><p>​        <strong>约束又可分为列级约束和表级约束：除了外键，其他约束都支持列级约束；除了非空、默认以及自增，其他约束都支持表级约束</strong>。列级约束在创建表时<strong>在字段名+字段数据类型之后添加即可</strong>；表级约束在最底下声明，语法为：</p><p><code>[CONSTRAINT constraint_name] CONSTRAINT_TYPE(colum_name)</code> </p><p><strong>主键、唯一键可以使用列级跟表级两种语法进行声明</strong>。</p><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列级约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> major(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">major_name <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span> <span class="comment">#可以同时添加多个约束</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">stu_name <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">stu_number <span class="built_in">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">majorid <span class="built_in">INT</span> ,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span>(stu_number),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="PRIMARY-KEY和UNIQUE"><a href="#PRIMARY-KEY和UNIQUE" class="headerlink" title="PRIMARY KEY和UNIQUE"></a><code>PRIMARY KEY</code>和<code>UNIQUE</code></h3><ul><li>两者都保证了唯一性，但主键不能为空。</li><li>一个表中只能有一个主键，但可以有多个unique。</li><li><strong><span style="color:red">unique约束的字段，是可以插入多个null值的</span></strong>。</li><li><strong>可以多个字段组合成一个主键或unique</strong>。**<span style="color:red;">该方式不推荐</span>**。</li></ul><p>关于上述组合的解释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> ,</span><br><span class="line">sname <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line"><span class="built_in">number</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>, <span class="built_in">number</span>)  <span class="comment">#将id和number组合为一个主键</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;as&#x27;</span>,<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;as&#x27;</span>,<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;as&#x27;</span>,<span class="string">&#x27;mike&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;as&#x27;</span>,<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><p>前3条insert语句都能正确执行，第4条则报错。即对于组合的主键，**<span style="color:red">只有组合的几个字段的值都相等才算相同</span><strong>。</strong>组合unique同理**。</p><h3 id="关于外键"><a href="#关于外键" class="headerlink" title="关于外键"></a>关于外键</h3><p>外键的一些特点：</p><ul><li><p>外键是在从表设置的。</p></li><li><p><strong>从表的外键字段的数据类型与主表的关联列的类型要一致或可兼容</strong>。</p></li><li><p>主表的关联列必须是一个key，<strong>一般都是主键</strong>，也可以是unique键。eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> main_table;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> main_table(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNIQUE</span> <span class="comment">#unique键</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> forei_table;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> forei_table(</span><br><span class="line">mainid <span class="built_in">INT</span>,</span><br><span class="line">fname <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(mainid) <span class="keyword">REFERENCES</span> main_table(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>外键字段的值可以为null</strong>，但<strong>要插入值时，在主表的关联字段必须有对应的数据存在，否则不可插入</strong>。</p></li><li><p><strong><span style="color:red">默认情况下，主表被关联字段的数据的更改或更新操作被拒绝</span></strong>。有以下几个操作可选（<strong>在从表设置外键时在语句的最后添加<code>ON DELETE</code>加上以下字段</strong>）：</p><ul><li><code>cascade</code>，<strong>级联操作</strong>。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</li><li><code>set null</code>，<strong>置null</strong>。<strong>主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null</strong>。注意，要求该外键列没有not null属性约束。</li><li><code>restrict</code>，拒绝主表的外键关联字段的删除和更新。（<strong>默认</strong>）</li></ul><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> stu;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">stuname <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">major_id <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(major_id) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>外键只被InnoDB存储引擎所支持。其他引擎是不支持的</strong>。</p></li></ul><h3 id="关于auto-increment"><a href="#关于auto-increment" class="headerlink" title="关于auto_increment"></a>关于auto_increment</h3><ul><li>对有auto_increment约束的字段插入值，比如插入10，那么下一个序号将会是11。</li><li><strong>auto_increment必须和key搭配，如主键，唯一键</strong>。</li><li>一个表只能有一个auto_increment。</li><li>auto_increment只能用于数值型字段。</li><li>标识列可以通过<code>SET auto_increment_increment=3;</code>设置步长，也可以通过手动插入值设置起始值。</li></ul><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>（部分摘抄自<a href="https://shockerli.net/post/1000-line-mysql-note/%EF%BC%89">https://shockerli.net/post/1000-line-mysql-note/）</a></p><p>​        视图是一个虚拟表，其内容由查询定义。同真实的表一样，<strong>视图包含一系列带有名称的列和行数据</strong>。但是，<strong>视图并不在数据库中以存储的数据值集形式存在</strong>。行和列数据来自由定义视图的查询所引用的表，<strong>并且在引用视图时动态生成</strong>。    </p><p>​        <strong>视图具有表结构文件，但不存在数据文件</strong>。对其中所引用的基础表来说，视图的作用类似于筛选。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。视图是存储在数据库中的查询的sql语句，它主要出于两种原因：<strong>安全原因</strong>，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可<strong>使复杂的查询易于理解和使用</strong>。</p><p>​        可简单的这样理解：<strong>视图存储的是sq逻辑，即sql语句，当要使用视图时根据该语句动态生成结果集</strong>。</p><h3 id="视图的创建和使用"><a href="#视图的创建和使用" class="headerlink" title="视图的创建和使用"></a>视图的创建和使用</h3><p>创建视图的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句; <span class="comment">-- 一般是涉及多个表的复杂的查询语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name; <span class="comment">-- 显示视图结构</span></span><br></pre></td></tr></table></figure><p>创建视图后，使用视图类似于使用表。</p><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id=d.department_id</span><br><span class="line"><span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> j.job_id = e.job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myv1 <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="视图的修改"><a href="#视图的修改" class="headerlink" title="视图的修改"></a>视图的修改</h3><p>两种方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1(如果视图不存在会创建；视图存在就代替)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">查询语句;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,d.manager_id,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id=d.department_id</span><br><span class="line"><span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> j.job_id = e.job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id=d.department_id</span><br><span class="line"><span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> j.job_id = e.job_id;</span><br></pre></td></tr></table></figure><h3 id="视图的删除和查看"><a href="#视图的删除和查看" class="headerlink" title="视图的删除和查看"></a>视图的删除和查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view1_name,view2_name...;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看结构</span></span><br><span class="line">DESC view_name;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure><h3 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h3><p>​        <strong>视图的可更新性和视图中查询的定义有关系</strong>，<strong>以下类型的视图是不能更新的</strong></p><ul><li>包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者uunion all</li><li>常量视图</li><li>Select中包含子查询</li><li>Join</li><li>from一个不能更新的视图</li><li>where子句的子查询引用了from子句中的表</li></ul><p><strong>一般情况下视图都是不可更新的</strong>。</p><p>可更新视图的简单示例：tips：<strong>更新会作用到原表</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> last_name, phone_number</span><br><span class="line"><span class="keyword">FROM</span> employees ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#insert</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> myv3 <span class="keyword">VALUES</span>(<span class="string">&#x27;许褚&#x27;</span>,<span class="string">&#x27;888888&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#update</span></span><br><span class="line"><span class="keyword">UPDATE</span> myv3 <span class="keyword">SET</span> last_name=<span class="string">&#x27;典韦&#x27;</span> <span class="keyword">WHERE</span> last_name=<span class="string">&#x27;许褚&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> myv3 <span class="keyword">WHERE</span> last_name=<span class="string">&#x27;典韦&#x27;</span>;</span><br></pre></td></tr></table></figure><p>对视图进行修改需要有权限。</p><h3 id="视图与表"><a href="#视图与表" class="headerlink" title="视图与表"></a>视图与表</h3><ul><li>两者创建的语法不同。</li><li>从占用存储空间方面：<strong>视图只是保存了sql语句，只占用了很小的空间；而表保存了数据，占用空间较大</strong>。</li><li>视图一般都不允许增删改查；表允许。</li></ul><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>MySQL变量的分类：</p><ul><li>系统变量<ul><li>全局变量</li><li>会话变量</li></ul></li><li>自定义变量<ul><li>用户变量</li><li>局部变量</li></ul></li></ul><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>​        系统变量是由MySQL系统提供的，用于设置服务器的某些功能。<strong>分为全局（global）变量和会话（session）变量</strong>。两者主要区别是作用域不同，<strong>全局变量的作用域是所有会话（连接），<span style="color:red">但每次重启MySQL服务器都会重置</span>；而会话变量只针对当前会话有效</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（对于会话变量，session可省略）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看所有全局/会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span> <span class="keyword">VARIABLES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--添加筛选条件</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> condition;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看单个变量</span></span><br><span class="line"><span class="keyword">SELECT</span> @@<span class="keyword">global</span>|[<span class="keyword">session</span>].变量名</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span> 变量名=new_value;</span><br><span class="line"><span class="keyword">SET</span> @@<span class="keyword">global</span>|[<span class="keyword">session</span>].变量名=new_value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%tx_is%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @@global.autocommit;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%char%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p><strong>用户变量针对当前会话有效</strong>，即与会话变量作用域相同。<strong>用户变量可以应用在begin-end里面以及外面</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--声明(变量名使用@开头，避免与系统变量产生冲突)</span></span><br><span class="line"><span class="keyword">SET</span> @variable_name=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SET</span> @variable_name:=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @variable_name:=<span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改（与声明同）</span></span><br><span class="line"><span class="comment">--1</span></span><br><span class="line"><span class="keyword">SET</span> @variable_name=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SET</span> @variable_name:=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @variable_name:=<span class="keyword">value</span>;</span><br><span class="line"><span class="comment">--2</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(只能有一个字段) <span class="keyword">INTO</span> @variable_name</span><br><span class="line"><span class="keyword">FROM</span> table_name [<span class="keyword">where</span> ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">SELECT</span> @variable_name;</span><br></pre></td></tr></table></figure><p><strong>局部变量只在begin-end块中有效</strong>。在块的开头声明。一般不使用@。<strong>局部变量应用在存储过程、函数等</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--声明(可不加@)</span></span><br><span class="line"><span class="keyword">DECLARE</span> variable_name DATATYPE [<span class="keyword">DEFAULT</span> <span class="keyword">value</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改</span></span><br><span class="line"><span class="comment">--1(使用select加@)</span></span><br><span class="line"><span class="keyword">SET</span> variable_name=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SET</span> variable_name:=<span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @variable_name:=<span class="keyword">value</span>;</span><br><span class="line"><span class="comment">--2</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(只能有一个字段) <span class="keyword">INTO</span> variable_name</span><br><span class="line"><span class="keyword">FROM</span> table_name [<span class="keyword">where</span> ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">SELECT</span> variable_name;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--user variable</span><br><span class="line"><span class="builtin-name">SET</span> @<span class="attribute">m</span>=1;</span><br><span class="line"><span class="builtin-name">SET</span> @<span class="attribute">n</span>=2;</span><br><span class="line"><span class="builtin-name">SET</span> @<span class="attribute">sum</span>=@m+@n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"></span><br><span class="line">--局部变量</span><br><span class="line">。。</span><br></pre></td></tr></table></figure><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>​        存储过程是一段可执行性sql代码的集合。相比函数，更偏向于业务逻辑。实际上存储过程即类似于Java中的方法。</p><p>关于<code>DELIMITER</code>：<strong>该关键字用于指定命令结束符号，即告诉MySQL当遇见结束符时表示命令结束，可以执行</strong>。默认情况下是<code>;</code>。<strong>在某些情况下</strong>，不止要执行一条SQL语句，但又需要<code>;</code>作为各语句的结束，这时可使用该关键字指定其他的结束符。下面的存储过程创建即使用了这一点。</p><p><strong>创建存储过程前需要先使用<code>DELIMITER</code>关键字指定除<code>;</code>外的结束符</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--语法</span></span><br><span class="line"><span class="comment">--若过程体只有一句SQL语句，begin-end可以省略</span></span><br><span class="line"><span class="comment">--过程体的每条SQL语句必须以分号结尾</span></span><br><span class="line">DELIMITER $(可使用其他符号)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 过程名 (参数列表)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    过程体</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="comment">--参数列表的每个参数定义包含3个部分</span></span><br><span class="line"><span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT 参数名 数据类型</span><br><span class="line"><span class="comment">--其中</span></span><br><span class="line"><span class="keyword">IN</span>      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line"><span class="keyword">OUT</span>     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"><span class="keyword">CALL</span> 存储过程名(实参列表)</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> procedure_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看存储过程的结构</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> procedure_name;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_to_major()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> major <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;c&#x27;</span>),(<span class="number">7</span>,<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> insert_to_major();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--判断登录是否成功</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> login(<span class="keyword">IN</span> username <span class="built_in">VARCHAR</span>(<span class="number">10</span>),<span class="keyword">IN</span> <span class="keyword">password</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">admin</span> <span class="keyword">WHERE</span> admin.<span class="string">`username`</span>=username <span class="keyword">AND</span> admin.<span class="string">`password`</span>=<span class="keyword">password</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="keyword">result</span>&gt;<span class="number">0</span>,<span class="string">&#x27;登录成功&#x27;</span>,<span class="string">&#x27;登录失败&#x27;</span>) <span class="string">&#x27;登录情况&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> login(<span class="string">&#x27;吴彦祖&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--根据女神名获取男朋友名字（使用了in out）</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_boyfriend(<span class="keyword">IN</span> girl_name <span class="built_in">VARCHAR</span>(<span class="number">10</span>),<span class="keyword">OUT</span> boyfriend <span class="built_in">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> bo.boyName <span class="keyword">INTO</span> boyfriend</span><br><span class="line"><span class="keyword">FROM</span> boys bo </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty b <span class="keyword">ON</span> b.boyfriend_id=bo.id</span><br><span class="line"><span class="keyword">WHERE</span> b.name=girl_name;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @bname = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">CALL</span> get_boyfriend(<span class="string">&#x27;王语嫣&#x27;</span>,@bname);</span><br><span class="line"><span class="keyword">SELECT</span> @bname;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>MySQL的函数有系统自带（内置函数）的，<strong>也可以自定义函数</strong>。函数于存储体类似，都是一组SQL语句的集合。</p><p><strong>其与存储体的区别如下</strong>：</p><ul><li>存储体可以有0或多个返回值。适合批量操作。</li><li>函数有且仅有一个返回值。适合用于对数据处理后返回一个数据。</li></ul><p>(部分摘抄自<a href="https://shockerli.net/post/1000-line-mysql-note/">https://shockerli.net/post/1000-line-mysql-note/</a>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建函数</span></span><br><span class="line">DELIMITER $(可使用其他符号)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name (参数列表) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">- 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">- 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">- 参数部分，由<span class="string">&quot;参数名&quot;</span>和<span class="string">&quot;参数类型&quot;</span>组成。多个参数用逗号隔开。</span><br><span class="line">- 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">- 若函数体只有一条语句，可以省略<span class="keyword">begin</span>-<span class="keyword">end</span></span><br><span class="line">- 必须有 <span class="keyword">return</span> 返回值语句。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">SELECT</span> function_name(实参列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] function_name;</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">&#x27;partten&#x27;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name;</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> function_name 函数选项</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据员工名获取工资</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getsal(empName <span class="built_in">VARCHAR</span>(<span class="number">10</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> @sal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> @sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name=empName;</span><br><span class="line"></span><br><span class="line">RETURN @sal;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> getsal(<span class="string">&#x27;Hunold&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>​        MySQL内置函数有单行函数和分组函数：</p><ul><li><strong>单行函数</strong>：作用范围只有一行，即一个记录。</li><li><strong>分组函数</strong>：<strong>作用的范围是多个记录（即一列）</strong>，对多个记录进行统计，再返回一个结果。又称统计函数。</li></ul><h4 id="单行函数-字符函数"><a href="#单行函数-字符函数" class="headerlink" title="单行函数-字符函数"></a>单行函数-字符函数</h4><p><strong><span style="font-size:25px;"><code>LENGTH(str)</code></span></strong> </p><p>返回str的长度（字节数），其中，若使用的是<strong>utf8字符集</strong>，<strong>则一个英文占1个字节，一个中文占3个字节</strong>。</p><p>eg：</p><p><code>SELECT LENGTH(&#39;不摇碧莲&#39;);</code> 返回12.<br><code>SELECT LENGTH(&#39;jonh&#39;);</code>  返回4.</p><p><code>----------------------------------------------------------------------------------</code> </p><p><strong><span style="font-size:25px;"><code>UPPER(str)</code>、<code>LOWER(str)</code></span></strong> </p><p>转化为大写、小写。eg：</p><p><code>SELECT UPPER(&#39;john&#39;); </code><br><code>SELECT LOWER(&#39;MIKE&#39;);</code> </p><p><code>----------------------------------------------------------------------------------</code> </p><p><strong><span style="font-size:25px;"><code>CONCAT(str1,str2,...)</code></span></strong> </p><p>拼接字符。</p><p><code>SELECT CONCAT(last_name,&#39;_&#39;,first_name) &#39;name&#39; FROM employees;</code><br><code>SELECT CONCAT(LOWER(last_name),&#39;_&#39;,UPPER(first_name)) &#39;name&#39; FROM employees;</code> （函数嵌套）</p><p><code>----------------------------------------------------------------------------------</code> </p><p><strong><span style="font-size:25px;"><code>SUBSTR substring</code></span></strong> </p><p><strong>该函数有4个重载的形式。<span style="color:red">sql中的索引从1开始</span></strong>。</p><p><code>substr(str,start)</code>：</p><p><code>substr(str FROM pos)</code>     返回从pos开始的子字符串</p><p><code>substr(str, pos, length)</code>     返回从索引pos开始，长度为length的子字符串</p><p><code>substr(str FROM pos FOR length)</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">&#x27;一二三四五六&#x27;</span>,<span class="number">4</span>) <span class="keyword">output</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">&#x27;一二三四五六&#x27;</span> <span class="keyword">FROM</span> <span class="number">3</span>) <span class="keyword">output</span>;  <span class="comment">#三四五六</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">&#x27;一二三四五六&#x27;</span>,<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">output</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">&#x27;一二三四五六&#x27;</span> <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="number">3</span>) <span class="keyword">output</span>;</span><br></pre></td></tr></table></figure><p><code>----------------------------------------------------------------------------------</code> </p><p><strong><span style="font-size:25px;"><code>INSTR(str,substr)</code></span></strong> </p><p><strong>返回子串第一次出现的位置，若不包含该子串，返回0</strong>。</p><p><code>SELECT INSTR(&#39;一二三四五六&#39;, &#39;四五六&#39;) output; #4</code><br><code>SELECT INSTR(&#39;一二三四五六&#39;, &#39;四六&#39;) output; #0</code> </p><p><code>----------------------------------------------------------------------------------</code> </p><p><strong><span style="font-size:25px;"><code>TRIM([deleteStr] FROM str)</code></span></strong> </p><p><strong>去掉前后的空格或指定字符（中间的字符不受影响）</strong>。eg：</p><p><code>SELECT TRIM(&#39;     啊哈哈哈   &#39;) output;</code><br><code>SELECT TRIM(&#39;a&#39; FROM &#39;aaaaa啊哈哈aaa&#39;) output;</code> </p><p><code>----------------------------------------------------------------------------------</code> </p><p><strong><span style="font-size:25px;"><code>LPAD(str,length,padstr) </code></span></strong> </p><p><strong>用padstr对str进行左填充达到length长度</strong>。<code>rpad()</code>同理。</p><p>eg：</p><p><code>SELECT LPAD(&#39;张三&#39;,10,&#39;a&#39;) output;</code>  # aaaaaaaa张三</p><p><code>SELECT RPAD(&#39;张三&#39;,10,&#39;a&#39;) output;</code>  # 张三aaaaaaaa</p><p>**其中，若是length参数小于str的长度，相当于substr(str,1,length)**，对lpad、rpad都一样。eg：</p><p><code>SELECT LPAD(&#39;张三四&#39;,2,&#39;a&#39;) output;</code>  # 张三</p><p><code>SELECT RPAD(&#39;张三四&#39;,2,&#39;a&#39;) output;</code>  # 张三</p><p><code>----------------------------------------------------------------------------------</code> </p><p><strong><span style="font-size:25px;"><code>REPLACE(str,fromStr,toStr) </code></span></strong> </p><p>替换。eg：</p><p><code>SELECT REPLACE(&#39;小明爱上了小红&#39;,&#39;小红&#39;,&#39;小绿&#39;) output;</code>  #小红爱上了小绿</p><h4 id="单行函数-数字函数"><a href="#单行函数-数字函数" class="headerlink" title="单行函数-数字函数"></a>单行函数-数字函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#四舍五入</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">1.56</span>) <span class="keyword">output</span>; <span class="comment"># 2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">-1.54</span>) <span class="keyword">output</span>; <span class="comment">#-2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">1.567</span>, <span class="number">2</span>) <span class="keyword">output</span>; <span class="comment"># 1.57</span></span><br><span class="line"><span class="comment">#向上取整</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">1.2</span>) <span class="keyword">output</span>; <span class="comment">#2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">-1.1</span>) <span class="keyword">output</span>; <span class="comment"># -1</span></span><br><span class="line"><span class="comment">#向下取整</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">1.2</span>) <span class="keyword">output</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">-1.2</span>) <span class="keyword">output</span>; <span class="comment"># -2</span></span><br><span class="line"><span class="comment">#截断</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.1999</span>,<span class="number">1</span>) <span class="keyword">output</span>; <span class="comment"># 1.1，没有四舍五入</span></span><br><span class="line"><span class="comment">#模运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MOD</span>(<span class="number">10</span>,<span class="number">3</span>) <span class="keyword">output</span>; <span class="comment">#10%3</span></span><br><span class="line"><span class="comment">#生成0-1的任意数以及0-100的任意数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RAND</span>(),<span class="keyword">RAND</span>()*<span class="number">100</span>;</span><br></pre></td></tr></table></figure><h4 id="单行函数-日期函数"><a href="#单行函数-日期函数" class="headerlink" title="单行函数-日期函数"></a>单行函数-日期函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回当前系统日期+时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>() <span class="string">&#x27;time&#x27;</span>;</span><br><span class="line"><span class="comment">#返回当前系统日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURDATE</span>() <span class="string">&#x27;time&#x27;</span>;</span><br><span class="line"><span class="comment">#返回当前系统时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURTIME</span>() <span class="string">&#x27;time&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#截取日期中的年、月、日day、小时hour、分min?、秒second</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) <span class="string">&#x27;year&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(<span class="string">&quot;1998-12-12&quot;</span>) <span class="string">&#x27;year&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(hiredate) <span class="string">&#x27;year&#x27;</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(<span class="keyword">NOW</span>()) <span class="string">&#x27;minute&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>()) <span class="string">&#x27;month&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> MONTHNAME(<span class="keyword">NOW</span>()) <span class="string">&#x27;monthname&#x27;</span>; <span class="comment"># 获取月的英文名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将字符串根据指定格式转化为日期，具体格式见下表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STR_TO_DATE</span>(<span class="string">&#x27;1999-10-22&#x27;</span>,<span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">output</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> hiredate=<span class="keyword">STR_TO_DATE</span>(<span class="string">&#x27;4-3 1992&#x27;</span>,<span class="string">&#x27;%c-%d %Y&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#将日期根据指定格式转化为字符，</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">&#x27;%Y年%m月%d日&#x27;</span>) <span class="keyword">output</span>;</span><br><span class="line"><span class="comment">#查询有奖金的员工名跟入职日期(xx月/xx日 xx年的格式)</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name, <span class="keyword">DATE_FORMAT</span>(hiredate,<span class="string">&#x27;%m月/%d日 %Y年&#x27;</span>) <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>; </span><br><span class="line"><span class="comment">#计算两个日期之间相差的天数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(<span class="keyword">MAX</span>(hiredate),<span class="keyword">MIN</span>(hiredate)) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200526104150723.png" alt="image-20200526104150723" style="zoom: 50%;" /><h4 id="单行函数-其他函数"><a href="#单行函数-其他函数" class="headerlink" title="单行函数-其他函数"></a>单行函数-其他函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();<span class="comment">#当前版本</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();<span class="comment">#当前数据库名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(); <span class="comment">#当前用户名</span></span><br><span class="line"><span class="comment">#返回字符串的加密形式、md5加密形式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">PASSWORD</span>(<span class="string">&#x27;objk&#x27;</span>),<span class="keyword">MD5</span>(<span class="string">&#x27;ojbk&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--若exp1为null，返回exp2值，否则返回exp1的值。</span></span><br><span class="line">IFNULL(exp1, exp2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若expr为真，返回1，否则0</span></span><br><span class="line">isnull(expr)</span><br></pre></td></tr></table></figure><h4 id="单行函数-流程控制函数"><a href="#单行函数-流程控制函数" class="headerlink" title="单行函数-流程控制函数"></a>单行函数-流程控制函数</h4><p><strong><span style="font-size:25px;"><code>if(condition,expr1,expr2)</code></span></strong> </p><p><strong>若条件为真，返回expr1，否则返回expr2</strong>。</p><p>eg：</p><p><code>SELECT last_name,IF(commission_pct IS NOT NULL,&#39;有奖金&#39;,&#39;没奖金&#39;) 备注 FROM employees;</code> </p><h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><p>常见的分组函数有：</p><p><strong><code>sum(expr)</code> 求和 </strong></p><p><strong><code>avg(expr)</code> 求平均值 </strong></p><p><strong><code>max(expr)</code> 求最大值 </strong></p><p><strong><code>min(expr)</code> 求最小值 </strong></p><p><strong><code>count(expr)</code> 求数量</strong> </p><p>其中：</p><ul><li><strong>分组函数的参数一般为字段名</strong>。</li><li>sum、avg一般<strong>只接受数值型参数</strong>，max、min、count<strong>可接受任何类型的参数</strong>。</li><li><strong>5个函数对null值忽略</strong>，即对null值不统计、不计算。</li><li>可与<code>distinct</code>配合使用，<strong>会对结果先去重，再进行函数计算</strong>。</li><li><strong>与分组函数一同查询的字段应有限制（分组函数查询结果只有一个值，而查询字段可能会有多个值），一般要求是<code>group by</code>后的字段</strong>。</li></ul><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(salary) <span class="string">&#x27;sum&#x27;</span>,<span class="keyword">AVG</span>(salary) <span class="string">&#x27;average&#x27;</span>,<span class="keyword">MIN</span>(salary) <span class="string">&#x27;min&#x27;</span>,<span class="keyword">MAX</span>(salary) <span class="string">&#x27;max&#x27;</span>,<span class="keyword">COUNT</span>(salary) <span class="string">&#x27;count&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(last_name),<span class="keyword">MIN</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(hiredate),<span class="keyword">MIN</span>(hiredate) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> salary) 去重,<span class="keyword">SUM</span>(salary) 不去重 <span class="keyword">FROM</span> employees;<span class="comment">##</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> commission_pct),<span class="keyword">COUNT</span>(commission_pct) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p><strong><code>COUNT()</code>函数</strong> </p><p>​        在5个函数中，<code>count()</code>函数有些许不同。</p><p>​        <strong>可使用<code>count(*)</code>跟<code>count(1)</code>来统计一个表有多少个记录。使用后者相当于在每个记录中添加一个名为1的字段（即新添加一个列），并统计共有多少行</strong>。</p><p>tips：myisam引擎下，<code>count(*)</code>效率更高；innodb引擎下，两者效率相差不多。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h4><p>见<code>函数\内置函数</code>第5点。</p><h4 id="case-when"><a href="#case-when" class="headerlink" title="case..when"></a><code>case..when</code></h4><p><strong>该语法有两种使用形式，可嵌套在select中（此时整个case-when执行后返回一个值），也可单独使用</strong>。</p><p>**第一钟类似Java的<code>swich..case</code>**。具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case 要判断的字段、表达式</span><br><span class="line"></span><br><span class="line">when 常量1 then 要显示的值1或语句1;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">when 常量n then 要显示的值n或语句n;</span><br><span class="line"></span><br><span class="line">else 默认显示</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>eg，根据部门id的不同，显示不同的最终工资：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary 原工资,department_id,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary*<span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">40</span> <span class="keyword">THEN</span> salary*<span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary*<span class="number">1.3</span></span><br><span class="line"><span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 最终工资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p><strong>第二种用法类似多层if，</strong>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case </span><br><span class="line"></span><br><span class="line">when condition1 then 要显示的值1或语句1;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">when condition_n then 要显示的值n或语句n;</span><br><span class="line"></span><br><span class="line">else 默认显示</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--嵌套在select中使用</span></span><br><span class="line"><span class="comment">--根据工资的大小区间分多个工资级别：</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 工资级别</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在存储过程中使用</span></span><br><span class="line"><span class="comment">--根据工资显示工资级别</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> testcase(<span class="keyword">IN</span> score <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> score&gt;=<span class="number">90</span> <span class="keyword">AND</span> score&lt;=<span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">WHEN score&gt;=80 THEN SELECT &#x27;B&#x27;;</span><br><span class="line">WHEN score&gt;=60 THEN SELECT &#x27;C&#x27;;</span><br><span class="line">ELSE <span class="keyword">SELECT</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> $ </span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> testcase(<span class="number">95</span>);</span><br></pre></td></tr></table></figure><p>两种case-when的特点：</p><ul><li><strong>可以作为表达式， 嵌套在其他语句中使用（此时整个CASE-WHEN执行完毕后返回一个值，如第一种用法的例子）</strong>；可以作为独立的语句，但必须放在begin-end中。</li><li><strong>如果WHEN中的值满足或条件成立， 则执行对应的THEN后面的语句，并且结束CASE</strong>。如果都不满足， 则执行ELSE中的语句或值。</li><li>ELSE可以省略， 如果ELSE省略了， <strong>并且所有WHEN条件都不满足， 则返回NULL</strong>。</li></ul><h4 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h4><p><strong>if结构只能使用在begin-end中</strong>。</p><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF search_condition THEN statement_list   </span><br><span class="line">ELSEIF search_condition THEN statement_list</span><br><span class="line">...</span><br><span class="line">[ELSE statement_list;]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- while循环</span></span><br><span class="line">[label_name:] while 循环条件 <span class="keyword">do</span></span><br><span class="line">    循环体;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span> [label_name];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line"><span class="comment">-- 退出循环</span></span><br><span class="line">退出整个循环 leave label_name;</span><br><span class="line">退出当前循环 iterate label_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--loop循环</span></span><br><span class="line">[label_name:] loop</span><br><span class="line">    循环体;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> [label_name];</span><br><span class="line"><span class="comment">--需搭配leave和iterate，否则会死循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--repeat</span></span><br><span class="line">[label_name:] repeat</span><br><span class="line">    循环体;</span><br><span class="line">until 结束循环的条件</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span> [label_name];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DQL&quot;&gt;&lt;a href=&quot;#DQL&quot; class=&quot;headerlink&quot; title=&quot;DQL&quot;&gt;&lt;/a&gt;DQL&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;该笔记的实例代码中的数据库是&lt;code&gt;myemploees&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquo</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="http://example.com/2021/08/25/Linux/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/08/25/Linux/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</id>
    <published>2021-08-25T06:06:50.376Z</published>
    <updated>2021-08-30T05:00:56.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux系统的文件结构"><a href="#Linux系统的文件结构" class="headerlink" title="Linux系统的文件结构"></a>Linux系统的文件结构</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/bin</span>        二进制文件，系统常规命令</span><br><span class="line"><span class="string">/boot</span>       系统启动分区，系统启动时读取的文件</span><br><span class="line"><span class="string">/dev</span>        设备文件</span><br><span class="line"><span class="string">/etc</span>        大多数配置文件</span><br><span class="line"><span class="string">/home</span>       普通用户的家目录</span><br><span class="line"><span class="string">/lib</span>        32位函数库</span><br><span class="line"><span class="string">/lib64</span>      64位库</span><br><span class="line"><span class="string">/media</span>      手动临时挂载点</span><br><span class="line"><span class="string">/mnt</span>        手动临时挂载点</span><br><span class="line"><span class="string">/opt</span>        第三方软件安装位置</span><br><span class="line"><span class="string">/proc</span>       进程信息及硬件信息</span><br><span class="line"><span class="string">/root</span>       临时设备的默认挂载点</span><br><span class="line"><span class="string">/sbin</span>       系统管理命令</span><br><span class="line"><span class="string">/srv</span>        数据</span><br><span class="line"><span class="string">/var</span>        数据</span><br><span class="line"><span class="string">/sys</span>        内核相关信息</span><br><span class="line"><span class="string">/tmp</span>        临时文件</span><br><span class="line"><span class="string">/usr</span>        用户相关设定</span><br></pre></td></tr></table></figure><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><ul><li><code>vim 文件名</code>：打开要编辑的文件</li><li><code>vim +10 文件</code>：打开文件并跳到第10行</li><li><code>vim -R 文件</code>：以只读模式打开文件</li><li>命令模式<ul><li>方向键控制光标位置</li><li><code>dd</code>：删除当前整行</li><li><code>/str</code>：查找。</li><li><code>i</code>：在光标所在位置前插入</li><li><code>a</code>：在光标所在位置后插入</li><li><code>o</code>：在当前行下另起一新行插入</li><li><code>:</code>：进入底行模式</li></ul></li><li>插入模式<ul><li>此时可以对文件内容进行编辑，左下角会显示 “– 插入 –””</li><li>按”ESC”进入底行模式</li></ul></li><li>底行模式<ul><li><code>:q</code>：退出vim</li><li><code>:q!</code>：强制退出</li><li><code>:wq</code>：保存并退出</li></ul></li></ul><h2 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h2><ul><li><p>创建用户</p><ul><li><code>useradd 用户名</code> ：在/home目录下创建一个与用户名同名的家目录，且创建一个与用户名同名的组</li><li><code>useradd -d 目录名 用户名</code> ：指定家目录</li><li><code>useradd -g 组名 用户名</code> ：指定组</li></ul></li><li><p>删除用户</p><ul><li><code>userdel 用户名</code> ：删除指定用户，不删除家目录</li><li><code>userdel -r 用户名</code> ：删除指定用户并删除家目录</li></ul></li><li><p>其他</p><ul><li><code>id 用户名</code> ：查询用户信息</li></ul></li><li><p><code>passwd 用户名</code> ：修改/指定用户密码</p><ul><li><code>su -  用户名</code> ：切换用户</li><li><code>usermod -g 用户组 用户名</code> ：修改用户的组</li><li> <code>usermod –d 目录名 用户名</code> ：改变用户登陆的初始目录。</li></ul></li></ul><h2 id="组操作"><a href="#组操作" class="headerlink" title="组操作"></a>组操作</h2><ul><li><p><code>groupadd 组名</code> ：创建组</p></li><li><p><code>groupdel 组名</code> ：删除组</p></li><li><p><code>chgrp 组名 文件/目录名</code>：修改文件/目录所在组</p></li><li><p><code>usermod –g 组名 用户名</code>：改变用户所在组。</p></li><li><p><code>chgrp -R 组名 目录</code>：使目录的所有子文件或目录递归生效。</p></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li><p><code>pwd</code>：查看当前目录的绝对路径。（print name of current/working directory）</p></li><li><p><code>ls [选项] [目录或是文件]</code>：查看目录</p><ul><li><p><code>ls</code>：查看当前目录下的所有目录和文件  </p></li><li><p><code>ls -l</code>：列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），<strong>与命令<code>ll</code>效果一样</strong>。</p></li><li><p><code>ls -al</code>：结合<code>-a</code>跟<code>-l</code>。</p></li><li><p><code>ls /bin</code>：查看指定目录下的所有目录和文件 </p></li><li><p><code>ls -ahl</code>：<strong>查看当前目录下</strong>的<strong>文件或目录的所有者、所在组等信息</strong> 。</p></li><li><p><code>ls name1 name2</code>：ls两个目录。</p></li><li><p>一些选项：</p><table><thead><tr><th align="left">选项</th><th align="left">长选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">–all</td><td align="left">列出所有文件，包括隐藏文件。</td></tr><tr><td align="left">-d</td><td align="left">–directory</td><td align="left">与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。</td></tr><tr><td align="left">-F</td><td align="left">–classify</td><td align="left">这个选项会在每个所列出的名字后面加上一个指示符。</td></tr><tr><td align="left">-h</td><td align="left">–human-readable</td><td align="left">当以长格式列出时，以可读格式显示文件的大小（如1M），而不是显示字节数。</td></tr><tr><td align="left">-l</td><td align="left"></td><td align="left">以长格式显示结果。</td></tr><tr><td align="left">-r</td><td align="left">–reverse</td><td align="left">以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。</td></tr><tr><td align="left">-S</td><td align="left"></td><td align="left">命令输出结果按照文件大小来排序。</td></tr><tr><td align="left">-t</td><td align="left"></td><td align="left">按照修改时间来排序。</td></tr></tbody></table></li></ul></li><li><p><code>cd [option] [dir]</code>：切换到指定目录</p><ul><li><code>cd ~</code> 或者 <code>cd</code> ：回到当前用户的家目录</li><li><code>cd ..</code>： 回到当前目录的上一级目录</li></ul></li><li><p><code>file filename</code>：打印出文件内容的简单描述。</p></li><li><p><code>mkdir [选项] directory</code>：创建<strong>目录</strong> </p><ul><li><code>-p</code> ：创建多级目录</li><li><code>mkdir test</code>：在当前目录创建test目录</li><li><code>mkdir /home/test</code>：使用绝对路径。</li></ul></li><li><p><code>rmdir [选项] targetDir</code>：删除指定<strong>目录</strong> </p><ul><li>rmdir 删除的是空目录，目录下有内容时无法删除。</li><li>需要删除非空目录，需要使用 <code>-rf</code>选项 。</li></ul></li><li><p><code>touch file</code> ：指令创建空<strong>文件</strong></p></li><li><p><code>cp [选项] source dest</code>：拷贝文件到指定目录</p><ul><li>无指定选项时只能拷贝文件：<code>cp test.txt /home/zhangsan</code> </li><li>使用<code>-r </code>递归复制整个文件夹：<code>cp -r test zhangsan</code> </li><li>有相同名称文件时会提示是否覆盖，使用<code>\cp</code>强制覆盖不提醒。</li></ul></li><li><p><code>rm [选项] target</code>：删除文件或目录</p><ul><li><code>-r</code> ：递归删除整个文件夹 </li><li><code>-f</code> ： 强制删除不提示</li></ul></li><li><p><code>mv oldNameFile newNameFile</code>：重命名</p><p><code>mv 文件名或目录名 目标目录名</code> ：移动文件</p></li><li><p><code>cat [选项] 要查看的文件</code>：查看文件内容，以只读的方式打开。</p><ul><li>-n ：显示行号</li></ul></li><li><p><code>more 文件名</code>：以分页的形式查看文件内容。相关的快捷键：</p><ul><li>空格：下一页</li><li>enter：下一行</li><li>q：退出more，不显示剩余的内容。</li><li>CTRL+F：下一屏</li><li>CTRL+B：上一屏</li><li>=：输出当前行号</li><li><code>:f</code> ：输出文件名和当前行号</li></ul></li><li><p><code>less 文件名</code>：与more类似。<strong>区别：more在翻页至文件结束时会退出more默认，less模式可以来回翻页</strong>。快捷键：</p><ul><li><p>空格：下一页。</p></li><li><p>PgUp：上一页。</p></li><li><p>PgDn：下一页</p></li><li><p><code>/字符串</code>：向下搜索字符串</p></li><li><p><code>?字符串</code>：向上搜索字符串</p></li><li><p>q：退出less</p></li><li><p>其他参数：</p><table><thead><tr><th>Page UP or b</th><th>向上翻滚一页</th></tr></thead><tbody><tr><td>Page Down or space</td><td>向下翻滚一页</td></tr><tr><td>UP Arrow</td><td>向上翻滚一行</td></tr><tr><td>Down Arrow</td><td>向下翻滚一行</td></tr><tr><td>G</td><td>移动到最后一行</td></tr><tr><td>1G or g</td><td>移动到开头一行</td></tr><tr><td>/charaters</td><td>向前查找指定的字符串</td></tr><tr><td>n</td><td>向前查找下一个出现的字符串，这个字符串是之前所指定查找的</td></tr><tr><td>h</td><td>显示帮助屏幕</td></tr><tr><td>q</td><td>退出 less 程序</td></tr></tbody></table></li></ul></li><li><p><code>&gt;</code> <strong>输出重定向</strong> : 会将原来的文件的内容覆盖 </p><p><code>&gt;&gt;</code> <strong>追加</strong>： 不会覆盖原来文件的内容，而是追加到文件的尾部。eg：</p><ul><li><code>ls -l &gt;文件</code> ：列表的内容写入文件 a.txt 中（覆盖写）</li><li><code>ls -al &gt;&gt;文件</code>：列表的内容追加到文件 aa.txt 的末尾</li><li><code>cat 文件 1 &gt; 文件 2</code>：将文件 1 的内容覆盖到文件 2</li><li><code>echo &quot;内容&quot; &gt;&gt; 文件</code>：在文件后追加自定义内容</li></ul></li><li><p><code>echo [选项] [输出内容]</code>：输出内容到控制台（<strong>输出内容双引号可选</strong>）</p><ul><li><code>-n</code>：不输出尾随的换行符</li><li><code>-e</code>：启用反斜杠转义的解释</li><li><code>-E：</code>禁用反斜杠转义的解释（默认）</li></ul></li><li><p><code>head 文件</code>：查看文件头 10 行内容（默认）</p><p><code>head -n N</code> 文件：查看文件头N行内容，N是整数</p></li><li><p><code>tail 文件</code>：查看文件后 10 行内容） </p><p><code>tail -n N</code> 文件 ：查看文件后N行内容</p><p><code>tail -f 文件</code>：实时追踪该文档的所有更新</p></li><li><p><code>ln -s [原文件或目录] [软链接名]</code> ：给原文件创建一个软链接。（<strong>类似于Windows的快捷方式</strong>）</p><p><code>rm -rf linkName</code>：删除软链接。与删除普通目录一样的操作</p><p><code>ln 原文件或目录 硬连接名</code>：创建硬连接。</p></li><li><p><code>chown 用户名 文件/目录名</code>：修改（change owner）文件或目录的所有者。</p></li><li><p><code>chown newowner:newgroup 文件/目录</code>： 改变文件/目录的所有者和所有组。</p></li><li><p><code>chown -R 用户名 目录</code>：使目录的所有子文件或目录递归生效。</p></li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul><li><p>date</p><ul><li><code>date</code>：显示当前时间</li><li><code>date +%Y</code>：显示当前年份</li><li><code>date +%m</code>：显示当前月份</li><li><code>date +%d</code>：显示当前是哪一天</li><li><code>date &quot;+%Y-%m-%d %H:%M:%S</code>：显示年月日时分秒</li><li><code>date -s 字符串时间</code>：设置时间</li></ul></li><li><p><code>cal [选项]</code> ：不加选项，显示本月日历。</p><p><code>cal 2020</code>：显示2020年的日历</p></li></ul><h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><ul><li><p><strong>find</strong> </p><ul><li><code>find /home -name a.txt</code>：查找/home目录下名为a.txt的文件</li><li><code>find /root -user zhangsan</code>：查找/root目录下用户zhangsan的文件</li><li><code>find /home -size +20M</code>：查找/home目录下文件大小大于20M的文件。（**<code>-n</code>表示小于n，<code>n</code>表示等于n**）</li><li><code>find / -name *.txt</code>：查找所有.txt文件</li></ul></li><li><p><strong>locate</strong>。locaate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的locate 数据库实现快速定位给定的文件。<strong>Locate 指令无需遍历整个文件系统，查询速度较快</strong>。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。</p><p>第一次运行前，必须使用 <code>updatedb</code>指令创建 locate 数据库.</p><ul><li><code>update</code></li><li><code>locate *.txt</code></li><li><code>locate a.txt</code>：<strong>查找所有文件名包含a.txt的文件</strong>。</li></ul></li><li><p><strong>grep</strong> </p><ul><li><code>grep -i &quot;str&quot; demo_file</code> ：在文件中查找包含字符串(不区分大小写) 的行，双引号可省略</li><li><code>grep -A 3 -i &quot;example&quot; demo_text</code> ：输出成功匹配的行，以及该行之后的三行  </li><li><code>grep -r &quot;ramesh&quot; *</code>  ：在一个文件夹中递归查询包含指定字符串的文件</li><li><code>grep -n txt a.txt</code>：查找a.txt中包含txt的行，并显示行号。</li><li><code>cat a.txt | grep -n txt</code>：将<code>cat a.txt</code>的输出内容传递给<code>grep -n txt</code>命令处理。结果与上同。<strong>管道符<code>|</code>表示将前一个命令的处理结果输出传递给后面的命令处理</strong> </li></ul></li></ul><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><ul><li><p><code>gzip/gunzip</code>（<strong>只对文件有效</strong>）</p><ul><li><code>gzip filename</code>：将文件压缩为.gz压缩文件。<strong>且原文件不保留</strong>。</li><li><code>gunzip filename.gz</code>：解压文件。</li></ul></li><li><p><code>zip/unzip</code>（<strong>文件目录皆可</strong>）</p><ul><li><code>zip a.zip  a.txt</code>：将文件a.txt压缩到a.zip文件。（<strong>原目录/文件保留</strong>）</li><li><code>zip -r myzip.zip testdir</code>：将testdir目录递归压缩为myzip.zip文件（myzip.zip存放在当前目录）。（<strong>原目录/文件保留</strong>）</li><li><code>unzip -d /root myzip.zip</code>：将myzip.zip文件解压到/root目录下。</li></ul></li><li><p><code>tar</code></p><p>语法：<code>tar [选项] XXX.tar.gz（压缩后的文件名） 打包的内容</code> </p><ul><li><p>相关选项：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar.gz打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>调用gzip命令压缩</td></tr><tr><td>-x</td><td>解压</td></tr></tbody></table></li><li><p><code>tar -zcvf a.tar.gz a.txt a2.txt a3.txt </code>：压缩多个文件，将 a.txt-a3.txt压缩至 a.tar.gz</p></li><li><p><code>tar -zcvf temp.tar.gz ./*</code>：将当前目录的所有文件压缩为temp.tar.gz。</p></li><li><p><code>tar -zxvf temp.tar.gz -C dir</code>：将temp.tar.gz解压到dir目录下。</p></li><li><p><code>tar -zxvf temp.tar.gz</code>：解压到当前目录。</p></li></ul></li></ul><h2 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h2><ul><li><code>chmod u=rwx,g=rx,o=x 文件目录名</code> ：修改文件/目录的用户权限为rwx，组权限为rx，其他组权限为x。</li><li><code>chmod o+w 文件目录名</code> ：文件/目录的其他组权限加上w权限。</li><li><code>chmod a-x 文件目录名</code> ：文件/目录的所有权限去除x权限。</li><li><code>chmod 751 文件目录名</code>，<strong>751按照ugo的顺序对应</strong>；7对应111，5对应011。相当于 <code>chmod u=rwx,g=rx,o=x 文件目录名</code>  </li></ul><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><ul><li><code>df -lh</code> ：查询系统整体磁盘使用情况（挂载目录，总容量，已使用百分比等）。</li><li><code>du [option] 目录</code> ：查询指定目录的磁盘占用情况。<ul><li><code>-s</code> 指定目录占用大小汇总 </li><li><code>-h</code> 带计量单位 </li><li><code>-a</code> 含文件 </li><li><code>--max-depth=1</code> 子目录深度</li><li><code>-c</code> 列出明细的同时，增加汇总值</li></ul></li><li><code>ls -l /home | grep &quot;^d&quot; | wc -l</code> ：统计当前目录的目录个数（<strong>不包含子目录里的目录</strong>）</li><li><code>ls -lR /home | grep &quot;^-&quot; | wc -l</code> ：递归统计当前目录的目录个数，即包含子目录。</li><li><code>tree 目录</code> ：显示指定目录的树状结构（需先安装tree命令：<code>yum install tree</code>）</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>init 0-6</code> ：切换运行级别</li><li><code>help 指令</code> ：查看指令的说明文档</li><li><code>man 指令</code> ：查看指令的说明文档</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux系统的文件结构&quot;&gt;&lt;a href=&quot;#Linux系统的文件结构&quot; class=&quot;headerlink&quot; title=&quot;Linux系统的文件结构&quot;&gt;&lt;/a&gt;Linux系统的文件结构&lt;/h2&gt;&lt;figure class=&quot;highlight jboss-cl</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/Tag/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList-JDK1.8</title>
    <link href="http://example.com/2021/08/25/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedList-JDK8/"/>
    <id>http://example.com/2021/08/25/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedList-JDK8/</id>
    <published>2021-08-25T06:06:50.372Z</published>
    <updated>2021-08-30T04:57:39.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>LinkedList 的继承体系：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320171051562.png" alt="image-20210320171051562" style="zoom:67%;" /><p>LinkedList <strong>底层是基于双向链表实现的，所以 LinkedList 的容量上限是物理内存或 JVM 内存上限，它无需像 ArrayList 般进行扩容，且支持高效的插入和删除操作</strong>，但是<strong>存储元素的节点需要额外的空间存储前驱和后继的引用</strong>，且不支持 O(1) 的随机访问，虽然实现了 List 接口，有 <code>get(int)</code> 方法，但其时间复杂度是 O(n) 。</p><p><strong>LinkedList 中有两个引用 first、last 分别指向头结点和尾结点，所以在链表头部和尾部插入效率比较高，但在其他指定位置进行插入时，效率一般</strong>。因为在指定位置插入<strong>需要先定位到该位置处的节点</strong>，此操作的时间复杂度为 O(n)。另外，LinkedList 是非线程安全的集合类。</p><p>LinkedList 可以作为队列、栈来使用。需要使用栈时应优先使用 LinkedList ，而避免使用 Stack 类。</p><p>关于 AbstractSequentialList 抽象类：AbstractSequentialList 提供了一套基于顺序访问的接口。通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口。<strong>但 LinkedList 并没有直接该类的方法，而是重新实现了一套方法</strong>。</p><p>LinkedList 内的结点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-get"><a href="#2-get" class="headerlink" title="2. get()"></a>2. get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回索引 index 对应的结点（即第 index+1 个结点）</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 根据 index 是否小于 size 的一半决定从 first 还是 last 开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 LinkedList 因为是基于链表实现，索引不能随机访问元素。这里有<strong>一个小优化</strong>：会根据 index 离哪一端近来决定从 first 还是 last 开始遍历。</p><p>此外，LinkedList 还有针对队列和栈的一些方法：<code>getFirst() getLast() poll() pop()</code>  等，都是直接返回头结点或尾结点的值。</p><h2 id="3-关于遍历"><a href="#3-关于遍历" class="headerlink" title="3. 关于遍历"></a>3. 关于遍历</h2><p><strong>遍历 LinkedList 应该使用 iterator 或者 foreach 循环（会转换为使用 iterator ）</strong>，应该<strong>避免如下形式的遍历</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    Integet item = list.get(i);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedList 的 <code>get(int)</code> 方法时间复杂度是 O(n) ，若是集合中的元素数量较大，效率会很低</strong>。</p><p>LinkedList 的迭代器实现：</p><blockquote><p>调用 <code>iterator()</code> 方法时最终会调用 <code>listIterator(0)</code> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定索引开始迭代</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-add"><a href="#4-add" class="headerlink" title="4. add()"></a>4. add()</h2><p>LinkedList 继承和实现了多个类和接口，有很多插入元素的方法，如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320210837017.png" alt="image-20210320210837017"></p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320210935569.png" alt="image-20210320210935569"></p><p>针对队列和栈的一些方法大都是在头结点和尾结点操作，逻辑较简单，这里主要分析前 add 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 直接插入到链表尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 先找到 index 位置的结点（node(index)），再把 element 插入到该结点之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// last 后移</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点 </span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 新结点的 prev 指向 succ 的 prev，next 指向 succ</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// succ 的 prev 指向新结点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 若 succ 原本是头结点，则插入新结点后将 first 指向 newNode</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则 pred 的 next 连接 newNode</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些操作都是典型的链表操作，不难理解。</p><p><code>add(index, element)</code> 的逻辑是：</p><ul><li>若 index 等于 size，<strong>表示要插入链表尾部，直接调用 linkLast 即可</strong>；</li><li><strong>否则需要先定位到 index 处的结点，再把新结点插入到该结点之前</strong>。</li></ul><h2 id="5-remove"><a href="#5-remove" class="headerlink" title="5. remove()"></a>5. remove()</h2><p>相对 LinkedList 的插入方法，它也有很多对应的删除方法，这里主要分析 <code>remove(index)</code> 和 <code>remove(obj)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的元素，返回该元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">// 检查索引</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，删除成功返回 true，否则 false</span></span><br><span class="line"><span class="comment">// 若是有多个相同的值，则只删除找到的第一个（unlink 后立即 return）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// o 为 null 值</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 不为 null。使用 equals 比较</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定节点从链表中移除</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prev 为空表示 x 是头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 first 指向 next 即可</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;<span class="comment">///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似的，判断 x 是不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;<span class="comment">///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//将 x 的 item 引用置 null</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink 方法的逻辑如下（假设删除的节点既不是头节点，也不是尾节点）：</p><ol><li>将待删除节点 x 的前驱的后继指向 x 的后继</li><li><strong>将待删除节点 x 的前驱引用置空，断开与前驱的链接</strong> </li><li>将待删除节点 x 的后继的前驱指向 x 的前驱</li><li><strong>将待删除节点 x 的后继引用置空，断开与后继的链接</strong> </li></ol><p>（其实就是双链表的断开结点操作）</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ul><li><a href="http://www.tianxiaobo.com/2018/01/31/LinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK-1-8">LinkedList 源码分析(JDK 1.8) - 田小波</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;LinkedList 的继承体系：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/bxgitee/no</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java集合源码" scheme="http://example.com/Tag/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap-JDK1.8</title>
    <link href="http://example.com/2021/08/25/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedHashMap-JDK8/"/>
    <id>http://example.com/2021/08/25/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedHashMap-JDK8/</id>
    <published>2021-08-25T06:06:50.371Z</published>
    <updated>2021-09-10T16:30:53.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedHashMap <strong>继承自 HashMap，在 HashMap 的基础上维护了一个双向链表，也可以理解为，在 HashMap 的结点的基础上，添加了 before 和 after 2 个引用来支持双向链特性，解决了 HashMap 遍历顺序和插入顺序不一致的问题</strong>。除此之外，LinkedHashMap <strong>对访问顺序也提供了相关支持</strong>。在一些场景下，该特性很有用，比如实现 LRU 缓存。</p><p>在实现上，LinkedHashMap 很多方法直接继承自 HashMap，<strong>仅为维护双向链表覆写了部分方法</strong>。</p><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>先看Entry 继承体系：</p><p>Map 中 Entry 的继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap.TreeNode -&gt; LinkedHashMap.Entry -&gt; HashMap.Node -&gt; Map.Entry</span><br></pre></td></tr></table></figure><p>它们对应的成员变量：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210321152715920.png" alt="image-20210321152715920" style="zoom:80%;" /><p><strong>可以看到 LinkedHashMap.Entry 中的 before 和 after 变量，它们提供了双向链表的特性</strong>。同时 TreeNode 继承自 LinkedHashMap.Entry，所以它也可以作为双向链表的结点。<strong>LinkedHashMap 中使用的就是这两类结点，它在原本的链表、红黑树基础上通过 before、after 引用维护了一个双向链表</strong>，如下图（<strong>图片来自参考链接</strong>）：</p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg"/><blockquote><p>关于 Entry 继承体系更多细节：<a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/#31-entry-%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB">Entry 继承体系</a> </p></blockquote><h2 id="链表建立过程"><a href="#链表建立过程" class="headerlink" title="链表建立过程"></a>链表建立过程</h2><p>LinkedHashMap 中有<strong>两个引用：head、tail</strong>，指向双向链表的头和尾。</p><p><strong>在通过 <code>put</code> 方法加入元素的时候就同时将新增结点链入链表尾部</strong>。但 <strong style="color:red">LinkedHashMap 并没有覆盖 HashMap 的 put 方法，使用的都是父类的 put</strong> 。<strong>其维护双向链表的关键方法在于插入结点时调用的 <code>newNode()</code> 方法</strong>。</p><p>如下（标 ★★ 处）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中的 put 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中的 putVal 方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// ★★</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// ★★</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap 覆盖了父类的  <code>newNode()</code> 方法</strong>，它们的区别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建的是 Node 类型结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建的是 LinkedHashMap.Entry 类型结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 将 p 链入双向链表尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap</span></span><br><span class="line"><span class="comment">// 将 p 链入双向链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:red">所以关键点是 LinkedHashMap 覆盖了父类的  <code>newNode()</code> 方法，在创建结点时使用的是这个覆盖方法，在该方法中创建的是 LinkedHashMap.Entry 类型的结点，并将其链入双向链表尾部</strong>。</p><p><strong>通过维护双向链表，在遍历时只要顺着链表遍历就可以保证遍历顺序跟插入顺序一致</strong>。</p><p>另外，在 put 方法的最后还有一个 <code>afterNodeInsertion(evict);</code> 方法，在 JDK 8 HashMap 的源码中，相关的方法有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>这些方法的用途是<strong>在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中</strong>。即 LinkedHashMap  覆盖了这 3 个回调方法。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p>与插入操作一样，LinkedHashMap 的删除操作也是直接使用父类的实现。<strong>在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。<font color="red">LinkedHashMap 删除结点后维护链表的操作是通过上述的回调方法实现的</font></strong>。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);<span class="comment">// ----删除结点后调用回调方法----</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆盖</span></span><br><span class="line"><span class="comment">// 将指定结点从链表中断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">// 结点向下转型为 LinkedHashMap.Entry </span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="维护访问顺序"><a href="#维护访问顺序" class="headerlink" title="维护访问顺序"></a>维护访问顺序</h2><p>上文讲的是 LinkedHashMap 如何维护插入顺序，而除了插入顺序， LinkedHashMap 还可以维护访问顺序， LinkedHashMap 有一个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p><strong>该变量为 true 时表示启用访问顺序维护</strong>。该值默认为 false ，可通过该构造方法指定为 true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所谓维护访问顺序就是：当调用<code>get/getOrDefault/replace</code>等访问了结点的方法时，将这些方法访问的结点移动到链表的尾部</strong>。</p><p>代码：（<strong>注意 LinkedHashMap 重写了两个 get 方法</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 若 accessOrder 为 true，调用 afterNodeAccess</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 若 accessOrder 为 true 且当前结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 讲 p 从原位置移除</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 讲 p 链入尾部</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h2><p>LinkedHashMap 的最后一个回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest    LinkedHashMap.Entry&lt;K,V&gt; first;    // 根据条件判断是否移除最近最少被访问的节点（头结点）    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;        K key = first.key;        removeNode(hash(key), key, null, false, true);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>其中，removeEldestEntry 方法是一个空实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>可以通过继承 LinkedHashMap ，并重写该方法、自实现判断逻辑来实现 LRU 缓存</strong>。比如根据结点数量或结点存货时间来判断是否要移除。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>主要实现在 LinkedHashIterator 内部类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;        LinkedHashMap.Entry&lt;K,V&gt; next;        LinkedHashMap.Entry&lt;K,V&gt; current;        <span class="keyword">int</span> expectedModCount;        LinkedHashIterator() &#123;            <span class="comment">// 只需要从双向链头结点开始即可            next = head;            expectedModCount = modCount;            current = null;        &#125;        public final boolean hasNext() &#123;            return next != null;        &#125;        final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;            LinkedHashMap.Entry&lt;K,V&gt; e = next;            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            if (e == null)                throw new NoSuchElementException();            // 沿着双向链遍历，这样就可以保证插入顺序（当然要注意访问顺序有无开启）            // 因为双向链的结点是按插入顺序依次插入的            current = e;            next = e.after;            return e;        &#125;        public final void remove() &#123;            Node&lt;K,V&gt; p = current;            if (p == null)                throw new IllegalStateException();            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            current = null;            K key = p.key;            removeNode(hash(key), key, null, false, false);            expectedModCount = modCount;        &#125;    &#125;</span></span><br></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/">LinkedHashMap 源码详细分析（JDK1.8） - 田小波</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedHashMap &lt;strong&gt;继承自 HashMap，在 HashMap 的基础上维护了一个双向链表，也可以理解为，在 Has</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java集合源码" scheme="http://example.com/Tag/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
