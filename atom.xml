<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bxxiao</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-17T06:22:58.911Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>bxxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS详解</title>
    <link href="http://example.com/2021/04/16/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/04/16/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-16T02:08:41.653Z</published>
    <updated>2021-04-17T06:22:58.911Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></p><p><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，<strong>即抽象同步队列</strong>，这个类在 <code>java.util.concurrent.locks</code> 包下。</p><ul><li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li><li>队列：<strong>使用先进先出（FIFO）队列存储数据</strong>；</li><li>同步：实现了同步的功能。</li></ul><p><strong>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器</strong>，比如 <code>ReentrantLock</code> ，<code>Semaphore</code> ，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。也能利用 AQS 非常轻松容易地构造出符合自己需求的同步器。</p><h2 id="AQS-基本数据结构"><a href="#AQS-基本数据结构" class="headerlink" title="AQS 基本数据结构"></a>AQS 基本数据结构</h2><p>AQS 内部定义了一个 <strong>volatile 变量</strong> <code>state</code> 来<strong>标识资源的状态</strong>，<code>state</code> 的值没有统一的定义，<strong>不同的锁实现对state的定义和操作不同</strong>。对于 AQS 来说， <strong>线程同步的关键就是对状态值 state 进行操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>AQS 提供了 3 个方法来操作 state ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure><p>其中，第 3 个方法<strong>基于 <code>Unsafe.compareAndSwapInt()</code> 方法保证原子性</strong>。</p><p>AQS 类本身实现的是一些<strong>竞争资源时排队和阻塞的机制</strong>，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。其内部使用一个 FIFO 的双端阻塞队列，并用了两个指针标识队头队尾，<strong>注意两个变量都使用 volatile 修饰，这两个变量可能同时会有多个线程访问，所以修改 head、tail 的操作都使用 cas 操作</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><p>队列并<strong>不是直接储存线程，而是储存拥有线程的 Node 节点</strong>。</p><p>Node 内部类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记一个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标记一个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus的4个值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，取值范围是上面定义的 4 个静态常量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 结点对应的线程</span></span><br><span class="line">    <span class="comment">// 连接下一个在condition里等待的结点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断共享模式的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="comment">// 要注意结点的模式是由nextWaiter记录的</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS里面的addWaiter私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用了Node的这个构造函数</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 其它代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 的 5 种状态含义：</p><ul><li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度，即不参与资源竞争。<strong>当 timeout 或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化</strong>。</li><li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为 SIGNAL 。</li><li><strong>CONDITION</strong>(-2)：表示结点等待在 Condition 上，当其他线程调用了 Condition 的 <code>signal()</code> 方法后，CONDITION 状态的结点将<strong>从条件等待队列转移到阻塞队列中</strong>，等待获取同步锁。</li><li><strong>PROPAGATE</strong>(-3)：javadoc：waitStatus value to indicate the next acquireShared should unconditionally propagate。应该是表示：下一次共享模式下的资源请求会无条件传播？</li><li><strong>0</strong>：新结点入队时的默认状态。</li></ul><p>由源码可知，<strong>通过 Node 可以实现两个队列</strong>：</p><ul><li>一个是通过 prev 和 next 实现的 CLH 队列（线程同步队列，双向队列），即阻塞队列。</li><li>一个是通过 nextWaiter 实现 Condition 等待条件上的等待队列，这是一个单向队列。AQS 有个内部类 ConditionObject ， <strong>一个 ConditioObject 对象就是一个条件变量，每个条件变量对应一个条件队列（单向链表队列），其用来存放调用条件变量的 await 方法后被阻塞的线程</strong>。这里的条件队列就是通过 nextWaiter 维护。</li></ul><h2 id="资源共享模式"><a href="#资源共享模式" class="headerlink" title="资源共享模式"></a>资源共享模式</h2><p>资源有两种共享模式，或者说两种同步方式：</p><ul><li>独占模式（Exclusive）：资源是独占的，<strong>一次只能有一个线程获取到资源</strong>。如果一个线程获取到了资源，就会标记是这个线程获取到了。如 ReentrantLock。</li><li>共享模式（Share）：<strong>资源可以同时被多个线程获取</strong>，具体的<strong>资源个数可以通过参数指定</strong>。如 Semaphore/CountDownLatch。</li></ul><p>AQS <strong>针对不同的模式提供了不同的顶层 api</strong> ：</p><ul><li><p>在<strong>独占方式下</strong>获取和释放资源使用的 API 为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(in arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span></span><br></pre></td></tr></table></figure></li><li><p>在<strong>共享方式下</strong>获取和释放资源的 API 为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure></li></ul><p>AQS 是基于<strong>模板方法模式</strong>的，其中<strong>获取资源/释放资源等方法需要由子类实现</strong>，主要有：</p><ul><li><p><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到 Condition 才需要去实现它。</p></li><li><p>独占模式相关方法：</p><ul><li><code>boolean tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li><code>boolean tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li></ul></li><li><p>共享模式相关方法：</p><ul><li><code>int tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>int tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。</li></ul></li></ul><p><strong>这些方法都是定义成 <code>protected</code> 而不是 <code>abastract</code>，这样子类只需要实现需要的方法即可，比如独占模式下只用实现 tryAcquire-tryRelease 即可</strong>。</p><p>它们的方法体都是抛出一个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br></pre></td></tr></table></figure><h2 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h2><h3 id="acquire-源码解析"><a href="#acquire-源码解析" class="headerlink" title="acquire() 源码解析"></a>acquire() 源码解析</h3><p><code>accquire(int)</code> 方法是<strong>独占模式下获取资源的底层入口</strong>，其总体逻辑是：首先尝试获取资源，若获取成功则返回；否则进入阻塞队列等待，直到获得资源为止，<strong>且等待过程是不响应线程打断的（interrunpt）</strong>，若中途有被打断过，则作记录，获取资源成功后再补上打断。</p><p>acquire 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 尝试获取资源</span></span><br><span class="line">        !tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 失败时的操作</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程：</p><ul><li><code>tryAcquire()</code> 尝试获取资源，成功则返回 true，否则 false。<strong>这里体现了非公平锁的特性，每个线程获取锁时会尝试直接抢占加塞一次（即与阻塞队列中的线程竞争）</strong>。</li><li><code>tryAcquire()</code> 获取资源失败，则通过 <code>addWaiter()</code> 将线程加入阻塞队列队尾，并标记为独占模式（<code>Node.EXCLUSIVE</code>）。</li><li><code>acquireQueued()</code> <strong>将线程阻塞在阻塞队列直到线程获取到资源时返回</strong>，若等待过程中线程有被打断过，返回 true，否则 false 。</li><li><strong>线程在等待过程中被中断是不响应的</strong>，所以若是有被打断过，则通过 <code>selfInterrupt()</code> 将打断补上。</li></ul><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h4><p><code>tryAcquire()</code> 具体实现由子类提供。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h4><p><code>addWaiter()</code> 将线程加入阻塞队列队尾，并返回当前线程所在的结点。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// fast path 指如果队列不为空，通过 CAS 操作尝试直接加入队尾</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 设置head需要通过CAS保证线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若队列为空或 CAS 操作失败</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cas自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 队列为空，初始化一个空结点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        <span class="comment">// 不为空，加入队尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="acquireQueued-★"><a href="#acquireQueued-★" class="headerlink" title="acquireQueued() ★"></a>acquireQueued() ★</h4><p>线程在阻塞队列中阻塞，直到获取到资源，若等待过程有被打断过，返回 true，否则 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记是否获取资源成功</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记等待过程是否有被打断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// “自旋”</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前结点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果p是head，即node是队列第二个结点，且获取资源成功</span></span><br><span class="line">            <span class="comment">// 这里可以看出只有node结点是队列的第二个结点，才有机会去竞争资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将node设为头结点，即head指向的结点就是获取到资源的结点或为null</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将p从队列断开（node.prev已为null）</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;<span class="comment">// 成功获取到资源</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否应该进行阻塞(shouldParkAfterFailedAcquire)，若是，通过park进入waiting状态，当被</span></span><br><span class="line">            <span class="comment">// 唤醒时，判断线程是否被打断过(parkAndCheckInterrupt)，若是，将interrupted置为true</span></span><br><span class="line">            <span class="comment">// 即等待过程中被打断只是先做一下标记，最后再返回；这就是不响应打断的具体表现</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果等待过程中没有成功获取资源（抛出异常或其他情况？），那么取消结点在队列中的等待。</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;<span class="comment">///</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>下面<strong>重点分析</strong>下 <code>shouldParkAfterFailedAcquire()</code> 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前驱结点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 若为SIGNAL，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 否则，若是大于0（大于0只有一种状态，就是CANCEL(1)，表示结点已放弃参与竞争）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 往前一直找，找到一个状态小于0的结点</span></span><br><span class="line">        <span class="comment">// 随后所有的CANCEL结点会从队列中断开，稍后会被gc掉</span></span><br><span class="line">        <span class="comment">// 只有位于第二个结点的线程才能竞争资源，所以需要去掉状态为CANCEL的结点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 状态不是CANCEL，则通过CAS尝试设置为SIGNAL，</span></span><br><span class="line">        <span class="comment">// 允许失败，如其他线程在释放资源时</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false，随后再进入该方法进行判断</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shouldParkAfterFailedAcquire()</code> 方法的作用是<strong>判断是否应该进行阻塞</strong>，是则返回 true；<strong>判断的标准是前驱结点的状态是否是 <code>SIGNAL</code>(-1)。如果不是 <code>CANCEL</code> ，则通过 CAS 尝试修改为 <code>SIGNAL</code>，这样下次进入该方法可以直接返回不作处理</strong>。</p><p><strong>将前驱结点状态置为 <code>SIGNAL</code> 的原因是</strong>：</p><p>在释放资源成功后，会唤醒阻塞中的结点（中的线程），<strong>而执行唤醒操作是有条件的</strong>，即：（代码在release 方法中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">    unparkSuccessor(h);</span><br></pre></td></tr></table></figure><p>也就是<strong>如果结点是状态是 0 ，就不会执行唤醒操作。而一个结点被创建出来直到加入队列中时，并没有设置它的状态（即 Node 类的 waitStatus 成员变量），即一直是默认值 0</strong> ，所以需要在 <code>shouldParkAfterFailedAcquire()</code> 方法中将前驱结点的状态设置为 <code>SIGNAL</code>，即让其状态不等于 0 ，<strong>以便让前驱结点在释放资源时会唤醒自己</strong>。</p><p><strong>即一个结点的状态如果是 <code>SIGNAL</code> ，则该结点释放资源时会去唤醒后继结点</strong>。</p><p>同时<code>shouldParkAfterFailedAcquire()</code> 方法也会将当前结点前面状态为 <code>CANCEL</code> 的结点从队列中断开。</p><p>总结该方法作用：<strong>检查当前结点是否处于一个“安全状态”，即是否可以被唤醒，是则返回 true ，否则进行一些处理之后返回 false</strong>。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正阻塞线程的方法（通过park），被唤醒(unpark)或打断(interrupt)后，返回当前线程是否有被打断过</span></span><br><span class="line"><span class="comment">// 另外要注意的是 Thread.interrupted() 会清除打断标志</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结下 <code>acquireQueued()</code> 的具体流程：</p><ol><li>检查状态，找到安全休息点；</li><li>通过 <code>park()</code> 进入 waiting 状态，等待被 <code>unpark()</code> 或 <code>interrupt()</code> 唤醒。</li><li>被唤醒后记录打断状态，然后判断是否能尝试获取资源（是否是第二个结点），若能则尝试获取。</li><li>若获取资源成功，将当前结点设置为 head ，返回是否被中断过；若获取失败，回到 1 。</li></ol><p>一些要注意的点：</p><ul><li><p><strong>阻塞队列中的结点，只有处于第二个结点的位置，才有机会去竞争资源</strong>。</p></li><li><p><strong>若当前结点成功竞争到资源，则将 head 指针指向该结点，所以 head 指向的结点是获取到资源的结点或为 null</strong> 。</p></li><li><p><strong>线程进入阻塞前需要进行状态检查</strong>，保证可以有进行资源竞争的机会。</p></li><li><p>若阻塞过程被 <code>interrupt()</code> ，<strong>只是做一个标记</strong>（<code>acquireQueued()</code> 中将 <code>interrupted</code> 置为 true），<strong>不会进行其他响应，当获取到资源时再返回是否被打断过</strong>，若有再在 <code>acquire()</code> 中通过 <code>selfInterrupt()</code> 补上。</p></li></ul><h3 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h3><p><strong>此方法是独占模式下线程释放共享资源的顶层入口</strong>。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p><p><code>release()</code> 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过tryRelease尝试释放资源，若成功，则唤醒阻塞队列的下一格线程，</span></span><br><span class="line">    <span class="comment">// 并返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法需要由子类提供具体实现。</p><p><strong>一般情况下 <code>tryRelease()</code> 都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，所以其他线程不可能拿到资源，也就是只可能有一个线程来释放资源，所以直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题</strong>。</p><p>但要注意它的返回值，<strong>release()是根据 <code>tryRelease()</code> 的返回值来判断该线程是否已经完成释放掉资源了。</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回 false。</p><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a>unparkSuccessor()</h4><p>此方法的作用是：<strong>用 <code>unpark()</code> 唤醒等待队列中最靠前的非 CANCEL 线程</strong>。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 若当前结点状态小于0，置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到下一个需要被唤醒的点，一般情况下nede.next就是要唤醒的结点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 若s为null或状态是CANCEL</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从队尾往前，找到最靠前的状态 &lt;= 0的结点，将s指向它</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// s不为null</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此时，再和 <code>acquireQueued()</code> 联系起来</strong>：</p><ul><li>某个结点 s 被唤醒后，进入 <code>if (p == head &amp;&amp; tryAcquire(arg))</code> 的判断；</li><li>如果 s 是是老二结点，则直接可以竞争资源；</li><li>如果不是，通过 <code>shouldParkAfterFailedAcquire()</code> 方法调整后也会跑到 head 之后，在下一次自旋就可以满足 <code>p==head</code> 进而竞争资源；</li><li>如果竞争成功，就把自己设置成 head 结点，表示已经获取到资源了，<code>acquire()</code> 方法结束。</li></ul><h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared()"></a>acquireShared()</h3><p>共享模式下获取资源的顶层入口，尝试获取指定资源数，若成功则方法结束；否则进入阻塞队列等待，直到获取到直到资源，同独占模式一样，等待过程不响应中断，过后再补上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared()"></a>tryAcquireShared()</h4><p><strong>该方法需要由子类实现</strong>，JDK 定义好了它的返回值含义：</p><ul><li>返回负数，表示获取资源失败；</li><li>返回 0 ，表示获取资源成功，但剩余资源为 0 。</li><li>返回正数，表示获取资源成功，还有剩余资源可获取（<strong>正数不代表剩余资源数</strong>）。</li></ul><h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared()"></a>doAcquireShared()</h4><p>获取资源失败后进入阻塞队列等待，直到获取到资源，等待过程不响应中断。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">// 插入队尾</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">// 标记是否获取到了资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">// 是否被中断过</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取前驱结点</span></span><br><span class="line">            <span class="comment">// 如果当前结点是老二</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取资源，并记录返回值</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取资源成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将当前结点置为head并根据r的值决定是否唤醒其他线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();<span class="comment">// 补上中断</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否可以进入阻塞，与独占模式同</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAcquireShared()</code> 的过程与 <code>acquireQueued()</code> 大致相同，主要区别是共享模式中若获取资源后还有剩余资源，则会继续唤醒阻塞的线程，唤醒线程的源码在 <code>setHeadAndPropagate()</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Sets head of queue, and checks if successor may be waiting in shared mode, if so propagating if either propagate &gt; 0 or PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node); <span class="comment">// 设置node为新head</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 符合条件，唤醒后继共享模式线程</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>doReleaseShared()</code> 分析方法见下文。</p></blockquote><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared()"></a>releaseShared()</h3><p><strong>共享模式下线程释放共享资源的顶层入口</strong>。它会释放指定量的资源，如果成功释放会唤醒等待队列里的其他线程来获取资源。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared()"></a>tryReleaseShared()</h4><p>释放指定资源数，成功返回 true，否则 false 。需要由子类实现。</p><h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h4><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="comment">// 自旋，共享模式，持有同步状态的线程可能有多个，采用循环CAS保证线程安全</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 可能同时有多个线程释放资源，</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/waterystone/p/4920797.html&quot;&gt;https://www.cnblogs.com/waterystone/p/4920797.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="多线程" scheme="http://example.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java并发" scheme="http://example.com/Tag/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>多线程-原理</title>
    <link href="http://example.com/2021/04/16/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/04/16/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8E%9F%E7%90%86/</id>
    <published>2021-04-15T16:36:11.645Z</published>
    <updated>2021-04-16T01:19:31.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h3><p>在并发编程中，需要处理两个关键问题：<strong>线程之间如何通信及线程之间如何同步</strong>。通信是指线程之间以何种机制来交换信息。<strong>同步</strong>是指程序中用于<strong>控制不同线程间操作发生相对顺序的机制</strong>。</p><p>有两种并发模型可以解决这两个问题：</p><ul><li><strong>消息传递</strong>并发模型。线程之间<strong>没有公共状态，线程之间必须通过发送消息来显式进行通信</strong>；而由于消息的发送必须在消息的接收之前，<strong>即需要等待回应到达后再执行剩下步骤</strong>，因此同步是隐式进行的。</li><li><strong>共享内存</strong>并发模型。线程之间<strong>共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信</strong>；这种模型中，同步需要显式进行，即程序员<strong>必须显式指定某个方法或某段代码需要在线程之间互斥执行</strong>。</li></ul><p><strong>Java 的并发采用的是共享内存模型</strong>。</p><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>Java 内存模型，即 Java Memory Model。</p><p>Java 内存模型是一个<strong>抽象概念</strong>，其<strong>主要目的是定义程序中各种共享变量的访问规则</strong>， 即关注在虚拟机中把共享变量值存储到内存和从内存中取出变量值这样的底层细节。这里的<strong>共享变量指实例字段、静态字段和构成数组对象的元素</strong>，但是<strong>不包括局部变量与方法参数（即位于虚拟机栈的数据），因为后者是线程私有的，不会被共享，自然就不会存在竞争问题</strong>。</p><blockquote><p>为了获得更好的执行效能， Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。</p></blockquote><p><strong>Java 内存模型规定了所有的共享变量都存储在<font color="red">主内存</font>中。每个线程还有自己的<font color="red">工作内存</font>，线程的<font color="red">工作内存中保存了被该线程使用过的共享变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据</font>。不同的线程之间也无法直接访问对方工作内存中的变量，<font color="red">线程间变量值的传递均需要通过主内存来完成</font></strong>。</p><p><strong>所以如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤</strong>：</p><ol><li>线程 A 将本地内存中更新过的共享变量刷新到主内存中去。</li><li>线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量。</li></ol><p>线程、主内存、工作内存三者的交互关系如图所示：（图片仿制自《深入理解JVM》）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210413101152168.png" alt="image-20210413101152168"></p><p>上述的主内存、工作内存都是抽象概念，<strong>并不真实存在，可以把它们跟一些区域作对应</strong>：</p><ul><li><p>主内存可以对应 JVM 内存区域中堆的对象实例数据部分以及方法区的静态变量。在更底层，可以类比物理硬件的主内存，<strong>但物理上它仅是虚拟机内存的一部分</strong>。</p></li><li><p>工作内存则<strong>对应虚拟机栈的部分区域</strong>，在更底层，可与 <strong>CPU 的高速缓存（L1/L2 Cache）、寄存器对应</strong>。</p></li></ul><h3 id="内存间交互"><a href="#内存间交互" class="headerlink" title="内存间交互"></a>内存间交互</h3><p>….（《深入理解JVM P442》）</p><h3 id="JMM-的特征"><a href="#JMM-的特征" class="headerlink" title="JMM 的特征"></a>JMM 的特征</h3><p>….（《深入理解JVM P450》）</p><p>原子性</p><p>可见性</p><p>有序性</p><h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h2><p>CPU与主内存之间会添加一级或多级高速缓冲存储器，即Cache。</p><p><strong>在Cache内部是按行存储的， 其中每一行称为一个Cache行</strong>。Cache行是<strong>Cache与主内存进行数据交换的单位</strong>，Cache行的大小一般为2的幂次数字节。当CPU访问某个变量时， 首先会去看CPU Cache内是否有该变量， 如果有则直接从中获取，否则就去主内存里面获取该变量， <strong style="color:red">然后把该变量所在内存区域的一个Cache行大小的内存块（局部性原理）复制到Cache中</strong>。</p><p><strong>由于存放到Cache行的是内存块而不是单个变量， 所以可能会把多个变量存放到一个Cache行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</strong>。</p><p>比如CPU1、CPU2读取了同一个缓存行，若CPU1对其中的一个变量修改，在缓存一致性协议下，CPU2中对应的缓存行就会失效，即破坏了CPU2的一级缓存，CPU2需要到二级缓存查找（甚至到主存），造成性能下降。</p><p>比如有4个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure><p>假设缓存行大小32字节，一个long类型8个字节，当CPU访问a时，会把a及附近的b、c、d一起放入缓存行。</p><p><strong style="color:red">也就是地址连续的多个变量才有可能会被放到一个缓存行中</strong>。比如创建数组时，数组里面的多个元素就会被放入同一个缓存行。</p><p>在正常情况下单线程访问时将数组元素放入一个或者多个缓存行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p><p>测试缓存行demo见<code>test/TestCacheLine</code>。</p><p>JDK8之前使用声明多个填充变量的方法来避免伪共享问题，让一个缓存行只有一个有用变量：</p><p>该例中，若缓存行大小是64B，则value+p1-6是56B，对象头是8B，所以共64B。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK8提供了一个注解<code>@sun.misc.Contended</code>解决伪共享问题，它可以自行执行填充。上面代码可以改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是， 在默认情况下， @Contended注解只用于Java核心类， 比如rt包下的类。如果用户类路径下的类需要使用这个注解， 则需要添加JVM参数：<code>-XX:-RestrictContended</code>。填充的宽度默认为128，要自定义宽度则可以设置</p><p><code>-XX:ContendedPaddingWidth</code>参数。</p></blockquote><h2 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h2><p> Java 中共享变量存在内存可见性问题。</p><p>先看看多线程下处理共享变量时 Java 的内存模型：（来自《Java并发编程之美》）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210219144936496.png" alt="image-20210219144936496" style="zoom:80%;" /><p>Java 内存模型规定，将所有的变量都存放在主内存中，<strong>当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工作内存中的变量</strong>。</p><p>Java 内存模型是一个抽象的概念， 在实际实现中线程的工作内存如下图：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210219145156011.png" alt="image-20210219145156011" style="zoom:80%;" /><p>以该 CPU 架构，一个 A、B 线程共享变量产生的<strong>内存不可见问题示例</strong>：</p><p>假设线程 A 和线程 B 使用不同 CPU 执行， 并且当前两级 Cache 都为空。</p><ul><li>线程 A 首先获取共享变量 X 的值， 由于两级 Cache 都没有命中， 所以加载主内存中 X 的值，假如为 0。<strong>然后把 X=0 的值缓存到两级缓存</strong>，线程 A 修改 X 的值为 1，然后将其写入两级 Cache， 并且刷新到主内存。线程 A 操作完毕后， 线程 A 所在的CPU 的两级 Cache 内和主内存里面的 X 的值都是 1 。</li><li>线程 B 获取 X 的值，一级缓存没有命中，<strong>二级缓存命中</strong>，所以返回 X=1；这时候主内存中也是 X=1。然后线程 B 修改 X 的值为 2， 并将其存放到线程 2 所在的一级 Cache 和共享二级 Cache 中，最后更新主内存中X的值为 2；到这里一切都是好的。</li><li>随后线程 A 这次又需要修改 X 的值，<strong>获取时一级缓存命中，并且 X=1，到这里问题就出现了，明明线程B已经把X的值修改为了2，线程 A 获取的还是1。这就是共享变量的内存不可见问题，也就是线程 B 写入的值对线程 A 不可见</strong>。</li><li><strong>总结下大概就是</strong>：A 改了 X，随后 B 改了 X，<strong>而 B 改 X 时不能刷新 X 在 A 线程中 Cache 的值</strong>，当 A 再次读取 X 在它的 L1 Cache 中命中，不能读取到新的值。<strong style="color:red">即一个线程不能立刻感知到另一个线程对某变量的修改，导致读取了错误的数据</strong>。</li></ul><p><strong>另一种简洁的描述</strong>：</p><p>主内存中存在一个变量 X=1 ，线程 A、B 的工作内存都保存有 X 的副本，某时刻 A 改变了 X 的值为 X=2，并将其写入主内存，随后 B 要使用这个值，因为工作内存保留有 X 的副本，所以会直接使用工作内存中 X 的值（命中缓存），这时 X 的值还是 1 。即 B 感知不到 A 对变量 X 的修改，读取了错误的数据。</p><p>使用 synchronized 和 volatile 都可以避免这种问题。</p><p>一个 Java 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (run) &#123; <span class="comment">// ....</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;在main线程中将run置为false&quot;</span>);</span><br><span class="line">        run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1s 后将 run 置 false ，线程t并没有停止。</p><p>其<strong>原因分析</strong>：</p><ul><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210219171540525.png" alt="image-20210219171540525" style="zoom:67%;" /></li><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，<strong>而 t 依旧是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值</strong>。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210219171616293.png" alt="image-20210219171616293" style="zoom:67%;" /></li></ul><p>一种解决方法是为 <code>run</code> 加上<code>volatile</code>修饰符，加上该修饰符的变量在读写时都是从主存读写。<code>volatile</code> 能保证可见性但不能保证原子性。</p><h2 id="Java-指令重排序"><a href="#Java-指令重排序" class="headerlink" title="Java 指令重排序"></a>Java 指令重排序</h2><p><strong>Java 内存模型允许编译器和处理器对指令重排序以提高运行性能， 并且<font color="red">只会对不存在数据依赖性的指令重排序</font>。在单线程下重排序可以保证最终执行的结果与程序顺序执行的结果一致，但是在多线程下就会存在问题</strong>。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            System.out.println(num + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num = <span class="number">2</span>; <span class="comment">//--1--</span></span><br><span class="line">ready = <span class="keyword">true</span>; <span class="comment">//--2--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动线程 1 ，再启动线程 2 ，**当线程 2 执行了 <code>actor2()</code> 时，线程 1 不一定输出打印 4，而有可能是 0 **。这是因为 1、2处代码 不一定是按顺序执行，可能是先执行 <code>ready = true;</code> ，这时线程 1 判断 ready 为 true ，执行 <code>System.out.println(num + num);</code> ，而这时 <code>num=2;</code> 还未执行，num 的值还是 0 ，所以输出打印 0 。</p><p><strong>使用 volatile 修饰 ready 变量可以解决该问题</strong>。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>volatile 提供一种比锁更轻量级的<strong>线程间的通信机制</strong>。</p><p>volatile 可以<strong>避免内存可见性问题和指令重排序问题</strong>：</p><ul><li>volatile 可以确保对一个变量的更新对其他线程马上可见。当一个变量被声明为 volatile 时，<strong>线程在修改一个变量后，会同时把工作内存中的值同步回主内存；读取该变量时，会先从主内存把最新值加载到工作内存再进行读取，而不是直接使用当前线程的工作内存中的值</strong>。</li><li>volatile 会严格限制编译器和处理器对 volatile 变量与普通变量的重排序（JSR-133）。<strong>限制处理器的指令重排序是通过内存屏障来实现的</strong>。</li></ul><p>硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p><ol><li><strong>阻止屏障两侧的指令重排序</strong>；</li><li><strong>强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效</strong>。</li></ol><p>volatile 的内存语义和 synchronized 有相似之处， 具体来说就是：</p><ul><li>当线程写入了 volatile 变量值时就等价于线程退出 synchronized 同步块（<strong>把写入工作内存的变量值同步到主内存</strong>）</li><li>读取 volatile 变量值时就相当于进入同步块（<strong>先清空本地内存变量值，再从主内存获取最新值</strong>）</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>tobe…..</p><h3 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h3><p>原始的单例模式存在线程安全问题，可以加上 synchronized ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首次访问会同步，而之后的使用不用进入synchronized</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响性能。</p><p>因此就有了double-checked locking：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但该代码在多线程环境下是有问题的。</p><p>在同步块内的 <code>INSTANCE = new Singleton();</code> 语句对应的字节码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">...</span><br><span class="line">17: new #3 // class .../Singleton</span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line">21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line">...</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br></pre></td></tr></table></figure><p>其中的21、24指令不一定会按顺序执行，可能会先执行24，再执行21，执行24时，INSTANCE已不为null，所以其他线程调用<code>getInstance()</code>可以获取到INSTANCE，但此时INSTANCE的构造方法还未执行完毕，如果在构造方法中要执行很多初始化操作，那么拿到的是将是一个未初始化完毕的单例。</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排。</p><blockquote><p>volatile 屏蔽指令重排序的语义在 JDK 5 才被修复，也就是 JDK 5 之前 DCL 无法安全地使用。</p></blockquote><h2 id="先行发生规则"><a href="#先行发生规则" class="headerlink" title="先行发生规则"></a>先行发生规则</h2><p><strong>先行发生规则即 happens-before 规则</strong>。</p><p>若两个操作满足先行发生原则，则可以有<strong>较好的可见性、顺序性和线程安全性（不能百分比保证）</strong>。它是<strong style="color:red">判断操作间是否具备顺序性，线程是否安全的非常有用的手段</strong>。依赖这个原则，<strong>可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题</strong>，而不需要陷人 Java 内存模型苦涩难懂的定义之中。</p><p>定义：</p><p>“先行发生”原则指的是两个操作之间的偏序关系，具体是：<strong>若操作 A 先行发生于操作 B，则在发生操作 B 之前，操作 A 产生的影响能被操作Ｂ观察到</strong>，“影响”包括<strong>修改共享变量的值、发送了消息、调用了方法</strong>等。（<strong>注意，操作 A、B 可以属于同一个线程也可以是不同线程</strong>）</p><p>下面是 Java 内存模型下一些“天然的”先行发生关系：（来自《深入理解JVM》）</p><ul><li><p><strong>程序次序规则</strong>（Program Order Rule） ：<strong style="color:red">在一个线程内</strong>，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p></li><li><p><strong>管程锁定规则</strong>（Monitor Lock Rule） ：一个 unlock 操作先行发生于后面对<strong>同一个锁</strong>的 lock 操作。这里必须强调的是“同一个锁”， <strong>“后面”是指时间上的先后</strong>。</p></li><li><p><strong>volatile 变量规则</strong>（Volatile Variable Rule） ：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的<strong>“后面”同样是指时间上的先后</strong>。</p></li><li><p><strong>线程启动规则</strong>（Thread Start Rule） ：Thread 对象的 <code>start()</code> 方法先行发生于此线程的每一个动作。</p></li><li><p><strong>线程终止规则</strong>（Thread Termination Rule） ：线程中的所有操作都先行发生于对此线程的终止检测。</p></li><li><p><strong>线程中断规则</strong>（Thread Interruption Rule） ：对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</p></li><li><p><strong>对象终结规则</strong>（Finalizer Rule） ：一个对象的初始化完成（构造函数执行结束） 先行发生于它的 <code>finalize()</code>  方法的开始。</p></li><li><p><strong>传递性</strong>（Transitivity） ：如果操作 A 先行发生于操作 B， 操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</p></li></ul><p>这些先行发生关系<strong>无须任何同步器协助就已经存在，可以在编码中直接使用</strong>，Java 语言<strong>无须任何同步手段保障就能成立</strong>的先行发生规则<strong>有且只有</strong>这些。<strong style="color:red">如果两个操作之间的关系不在此列，并且无法从这些规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序</strong>。</p><p>另外，<strong>两个操作之间存在 happens-before 关系，并不意味着 JVM 必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序</strong>。</p><p><strong style="color:red">时间先后顺序与先行发生原则之间没有必然因果关系，衡量并发安全问题必须以先行发生原则为准，而不是以时间先后</strong>。</p><p>一个帮助理解的示例：（来自《深入理解JVM》）</p><p>线程 A 先执行 <code>setValue(1)</code> ，线程 B 后执行 <code>getValue()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次分析先行发生原则中的各项规则。</p><ul><li>由于两个方法分别由线程 A 和 B 调用，不在一个线程中，所以程序次序规则在这里不适用；</li><li>由于没有同步块，自然就不会发生 lock 和 unlock 操作， 所以管程锁定规则不适用； </li><li>由于 value 变量没有被 volatile 关键字修饰， 所以 volatile 变量规则不适用； </li><li>后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。</li><li>因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，<strong>因此可以判定，尽管线程 A 在操作时间上先于线程 B，但是无法确定线程 B 中 <code>getValue()</code> 方法的返回结果， 换句话说， 这里面的操作不是线程安全的，不能保证它们的执行顺序</strong>。</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>CAS 的全称是：<strong>比较并交换（Compare And Swap）</strong>。在 CAS 中，有这样三个值：</p><ul><li>V：<strong>要更新的变量</strong>(var)</li><li>E：<strong>预期值</strong>(expected)</li><li>N：<strong>新值</strong>(new)</li></ul><p><strong>比较并交换的过程如下</strong>：</p><p>先获取预期值（<strong>也就是旧值</strong>），然后判断 V 的值是否等于 E，如果等于，<strong>则认为在此期间 V 没有被修改过</strong>，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新，什么都不做。<strong>即若是要修改的变量的值为预期值，将其修改为新值，否则什么都不做</strong>。</p><p>这里的<strong>预期值 E 本质上指的是“旧值”</strong>。</p><p><strong>CAS 是一种原子操作，在底层使用了一种系统原语，是一条 CPU 的原子指令，是从 CPU 层面保证其原子性的</strong>，所以当判断了变量的值为旧值要进行修改时，<strong>不会出现被其他线程抢先修改的情况</strong>。</p><p><strong>当多个线程同时使用CAS操作一个变量时，只有一个可以成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，且一般会通过自旋不断尝试直到成功</strong> 。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>CAS 操作是乐观锁的具体实现，可以实现<strong>无锁并发</strong>，操作<strong>失败时线程并不会被挂起</strong>，且一般会<strong>结合自旋</strong>（如<code>while</code> 循环） 不断尝试直到成功，<strong>自旋期间会占用 CPU，所以若是自旋时间过长，会浪费大量的 CPU 资源</strong>。所以 CAS 操作<strong>适用于“读多写少”</strong>的情况。</p><p>另外，CAS <strong>只能保证一个共享变量的原子操作</strong>。</p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>ABA 问题即：当前线程获取了某个变量的值为 A（expect值），<strong>在进行 CAS 操作之前，其他线程把该变量的值修改为 B，又修改为 A，这时当前线程在进行 CAS 操作时获取到的变量值为 A，会认为变量没有被修改过</strong>，但其实已被修改了 2 次。</p><p>ABA 问题的解决思路是为变量<strong>加上版本号或者时间戳</strong>。JDK 1.5 的 <code>AtomicStampedReference</code> 类和 <code>AtomicMarkableReference</code> 类可以解决 ABA 问题。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而通过 ThreadLocal ，可以实现针对某一个变量，每个线程访问的都是该变量在当前线程的副本。 <code>ThreadLocal</code> 类主要解决的就是让每个线程绑定自己的值，<strong>即创建一个变量，每一个线程访问该变量获取的都是该变量在该线程的副本</strong>。</p><p><strong>如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 <code>ThreadLocal</code> 变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote><p><code>sleep(int i)</code>表示睡眠i s</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String str = <span class="string">&quot;str from t1&quot;</span>;</span><br><span class="line">            threadLocal.set(str);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 获取的是自己放置的str，获取不到t2放置的</span></span><br><span class="line">            String str1 = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str after 2s: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获取的str为null，不能获取到t1放置的str</span></span><br><span class="line">            String str = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            String str1 = <span class="string">&quot;str from t2&quot;</span>;</span><br><span class="line">            threadLocal.set(str1);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>Thread 类包含一个 <code>ThreadLocal.ThreadLocalMap</code> 成员变量，其实质是一个 Map，映射关系是 <code>ThreadLocal-Object</code>，存放多个 ThreadLocal 的本地副本（<strong>一个 ThreadLocal 在多个线程中都有一个副本，对应的，一个线程可以拥有多个 ThreadLocal 的本地副本</strong>）。</p><p>从Thread类源码开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即 <strong>Thread 类中有一个 threadLocals 和一个 inheritableThreadLocals， 它们都是 ThreadLocalMap 类型（<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类）的变量</strong>， 而 <strong>ThreadLocalMap 是一个定制化的 map，存放多个ThreadLocal 变量在当前线程的副本，<code>ThreadLocalMap</code> 存储以 <code>ThreadLocal</code> 为 key ，Object 对象为 value 的键值对</strong>。</p><p>在默认情况下， 每个线程中的这两个变量都为 null， <strong>只有当前线程第一次调用 ThreadLocal 的 <code>set()</code> 或者 <code>get()</code> 方法时才会创建它们</strong>。</p><p>从上面可以看出，<strong style="color:red">每个线程的本地变量不是存放在 ThreadLocal 实例里面，而是存放在对应线程的 threadLocals 变量里面</strong>。<strong>ThreadLocal 就是一个工具壳， 通过它来从当前线程的 threadLocals 中获取值或放入值</strong>。</p><p>如果线程一直不终止， 那么这个本地变量会一直存放在调用线程的 threadLocals 变量里面， <strong>所以当不需要使用本地变量时可以通过调用 ThreadLocal 变量的 <code>remove()</code> 方法</strong>， 从当前线程的 threadLocas 里面删除该本地变量，<strong>避免内存泄漏</strong>。</p><h3 id="set-、get-源码分析"><a href="#set-、get-源码分析" class="headerlink" title="set()、get()源码分析"></a>set()、get()源码分析</h3><blockquote><p>基于 JDK8</p></blockquote><p><code>set()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// threadLocalMap不为null，修改值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 第一次调用则创建当前线程对应的threadLocalMap，并将value放进去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 不为null则从中尝试获取值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前ThreadLocal对象为key，从线程的threadLocalMap中尝试获取值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map为null或其中没有当前ThreadLocal对应的值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化（若未初始化）线程的 threadLocalMap ，并将 当前ThreadLocal-null 放入 map</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();<span class="comment">//该方法只是返回一个null</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// map不为null（表示其中没有当前ThreadLocal对应的值）</span></span><br><span class="line">    <span class="comment">// 放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 否则创建一个ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 并同样放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong style="color:red">可以看到<code>set()</code>、<code>get()</code>方法都是先从当前线程中获取ThreadLocalMap对象</strong>。</li></ul><p>Thread、ThreadLoacal、ThreadLoacalMap 的关系图解：（图片来自 JavaGuide ）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210218180050123.png" alt="image-20210218180050123" style="zoom:80%;" /><h3 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h3><blockquote><p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放但又无法使用，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p></blockquote><p><strong><code>ThreadLocalMap</code> 中的 <font color="red">key 是 <code>ThreadLocal</code> 的弱引用</font>（继承了 WeakReference ），而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry</strong>。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p><p><strong>如图，假设 ThreadLocal 失去强引用，则只剩下 Entry 中 key 的弱引用，下一次 gc 时就会被回收，而 value 不会被清理</strong>。</p><p>（图片来自 <a href="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210311200342986.png">ThreadLocal的内存泄露的原因分析</a> ）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210311200342986.png" alt="image-20210311200342986" style="zoom:80%;" /><p>ThreadLocalMap 实现中已经考虑了这种情况，<strong style="color:red">在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的 Entry</strong>。<strong>使用完  <code>ThreadLocal</code> 变量后最好手动调用<code>remove()</code>方法</strong>。</p><p>（清除的具体方法是 <code>ThreadLocal.ThreadLocalMap#expungeStaleEntry</code> ）</p><p>ThreadLocalMap 的静态内部类 Entry ：</p><p><strong style="color:red">注意只有 key ，即 ThreadLocal 是弱引用，value 是强引用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:red">为什么使用弱引用</strong>？</p><p><strong>若使用强引用，则上图中的虚线改为实线，当外部的 Threadlocal 对象的强引用失去时，因为有 key 作为强引用，所以 ThreadLocal 对象不会被回收，而在外部又没有这个 ThreadLocal 对象的强引用，所以访问不了该 Entry ，即造成了 Entry 的内存泄漏</strong>。</p><p>InheritableThreadLocal(to be …)</p><h3 id="副本指向同一个对象"><a href="#副本指向同一个对象" class="headerlink" title="副本指向同一个对象"></a>副本指向同一个对象</h3><p>另外要注意的一个点是，<strong>一个 ThreadLocal 变量在各个线程的副本可以指向同一个对象</strong>：</p><p>定义 Stu 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：（线程 t1、t2 中的 ThreadLocal 变量指向的是同一个对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Stu&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stu stu = <span class="keyword">new</span> Stu(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        threadLocal.set(stu);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stu stuCopy = threadLocal.get();</span><br><span class="line">        System.out.println(stuCopy);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        threadLocal.set(stu);</span><br><span class="line">        Stu stu1 = threadLocal.get();</span><br><span class="line">        stu1.setName(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Stu&#123;name=&#x27;lisi&#x27;, age=20&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h2&gt;&lt;h3 id=&quot;并发编程模型&quot;&gt;&lt;a href=&quot;#并发编程模型&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="多线程" scheme="http://example.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java并发" scheme="http://example.com/Tag/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>synchronized 优化</title>
    <link href="http://example.com/2021/04/08/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/04/08/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-08T06:15:43.048Z</published>
    <updated>2021-04-17T06:23:04.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象头的Mark-Word"><a href="#对象头的Mark-Word" class="headerlink" title="对象头的Mark Word"></a>对象头的Mark Word</h2><p>HotSpot 虚拟机对象的对象头包含两部分。</p><p><strong>第一部分是用于存储对象自身的运行时数据</strong>， 如哈希码(HashCode) 、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（<strong>未开启压缩指针</strong>）中分别为32个比特和64个比特， 官方称它为“<strong>Mark Word</strong>”；</p><p><strong>第二部分是类型指针</strong>，指向当前对象所属类的元数据。</p><p>如果是数组对象的话, 对象头还有一部分是存储数组的长度。</p><p>对象需要存储的运行时数据很多，考虑到虚拟机的空间效率， <strong>Mark Word被设计成一个有着动态定义的数据结构，以便根据对象的状态复用自己的存储空间</strong>。</p><p>不同状态的数据结构如下：</p><p>32位JVM的Mark Word不同状态下的结构：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210215171435678.png" alt="image-20210215171435678"></p><p>64位：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210215171452314.png" alt="image-20210215171452314"></p><p>当对象状态为偏向锁时，<code>Mark Word</code> 存储的是偏向的线程 ID ；</p><p>当状态为轻量级锁时，<code>Mark Word</code> 存储的是指向线程栈中 <code>Lock Record</code> 的指针；</p><p>当状态为重量级锁时，<code>Mark Word</code> 为指向堆中的 monitor 对象的指针。</p><h2 id="锁优化概述"><a href="#锁优化概述" class="headerlink" title="锁优化概述"></a>锁优化概述</h2><p>Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。<strong>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费很多的处理器时间，对于代码简单的同步块（如被<code>synchronized</code> 修饰的<code>get</code>  或<code>set</code> 方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说<code>synchronized</code> 是 java 语言中一个重量级的操纵</strong>。</p><p>Java 6 为了减少获得锁和释放锁带来的性能消耗，<strong>引入了“偏向锁”和“轻量级锁“</strong>。在Java 6 以前，所有的锁都是”重量级“锁。在 Java 6 及其以后，一<strong>个对象其实有四种锁状态，它们级别由低到高依次是</strong>：</p><ol><li>无锁状态。无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它。</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><blockquote><p>一些文章说是锁可以升级, 但不能降级。在 <a href="http://concurrent.redspider.group/article/02/9.html#922-%E5%81%8F%E5%90%91%E9%94%81">synchronized与锁</a> 中的观点是锁可以降级（Hotspot 支持锁降级）。</p></blockquote><p><strong>几种锁会随着竞争情况逐渐升级</strong>。</p><blockquote><p><strong>以下被 synchronized 上锁的对象称为 lockObj</strong> ，其关联的 monitor 对象则直接称为 monitor</p></blockquote><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁，<strong>偏向锁适合一个线程的情况</strong>。</p><p>总的来说，偏向锁会偏向第一个访问锁的线程，当线程访问同步代码时，若发现 lockObj 的 Mark Word 中的线程 ID 是自己的，则直接执行同步代码，也就是说，<strong style="color:red">偏向锁在资源无竞争情况下消除了同步语句，省略了 CAS 操作，只是执行一个简单的判断就可以执行同步代码，提高了程序的运行性能</strong>。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>当线程第一次访问一个同步代码块时，会尝试将自己的线程 ID 设置在 lockObj 的 Mark Word 中和栈帧中的锁记录里，当再次访问该同步块时，会检测 lockObj 的  Mark Word 中放的是不是自己的线程 ID 。</p><p><strong>如果是，则表示获取到了锁，直接进入同步代码块，无需进行其他操作</strong>。</p><p><strong>如果不是，会撤销偏向锁，升级为轻量级锁</strong>。</p><blockquote><p>而根据参考链接，以及网上大部分博客，都是写的这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，分两种情况：</p><ul><li>CAS 操作成功，表示另一个线程已经执行完并退出同步块。锁不会升级，仍然为偏向锁，只不过偏向了新的线程。</li><li>CAS 操作失败，表示之前的线程仍然存在，<strong>暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，随后两个线程按照轻量级锁的方式进行竞争</strong>。</li></ul></blockquote><p>而通过实际例子进行验证，应该是第一种情况，即若是线程 id 不是当前线程的，升级为轻量级锁。</p><p>验证示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (dog) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (dog) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：(只保留部分对象头）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">28</span>:<span class="number">36.480</span> c.TestBiased [t1] - lock.Dog object <span class="built_in">int</span>ernals:</span><br><span class="line"><span class="comment">// 00000101 表示为偏向锁</span></span><br><span class="line"><span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:<span class="number">28</span>:<span class="number">36.483</span> c.TestBiased [t1] - lock.Dog object <span class="built_in">int</span>ernals:</span><br><span class="line"><span class="number">05</span> <span class="number">88</span> <span class="number">7</span>d <span class="number">1</span>b (<span class="number">00000101</span> <span class="number">10001000</span> <span class="number">01111101</span> <span class="number">00011011</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:<span class="number">28</span>:<span class="number">36.483</span> c.TestBiased [t2] - lock.Dog object <span class="built_in">int</span>ernals:</span><br><span class="line"><span class="number">05</span> <span class="number">88</span> <span class="number">7</span>d <span class="number">1</span>b (<span class="number">00000101</span> <span class="number">10001000</span> <span class="number">01111101</span> <span class="number">00011011</span>)</span><br><span class="line">Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">4</span> bytes <span class="keyword">external</span> = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:<span class="number">28</span>:<span class="number">36.493</span> c.TestBiased [t1] - lock.Dog object <span class="built_in">int</span>ernals:</span><br><span class="line"><span class="number">05</span> <span class="number">88</span> <span class="number">7</span>d <span class="number">1</span>b (<span class="number">00000101</span> <span class="number">10001000</span> <span class="number">01111101</span> <span class="number">00011011</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// t2发现dog的对象头保留了其他线程的id，撤销偏向锁，升级为轻量级锁</span></span><br><span class="line"><span class="number">13</span>:<span class="number">28</span>:<span class="number">36.494</span> c.TestBiased [t2] - lock.Dog object <span class="built_in">int</span>ernals:</span><br><span class="line"><span class="number">60</span> ef ec <span class="number">1</span>b (<span class="number">01100000</span> <span class="number">11101111</span> <span class="number">11101100</span> <span class="number">00011011</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放轻量级锁，变为无锁状态</span></span><br><span class="line"><span class="number">13</span>:<span class="number">28</span>:<span class="number">36.494</span> c.TestBiased [t2] - lock.Dog object <span class="built_in">int</span>ernals:</span><br><span class="line"><span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>)</span><br></pre></td></tr></table></figure><h3 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h3><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p><p><strong>偏向锁升级为轻量级锁所需的开销是比较大的</strong>，大概的过程如下：</p><blockquote><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol></blockquote><p>所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘</p><p>，这时<strong>可以设置 JVM 参数关闭偏向锁</strong>：<code>-XX:UseBiasedLocking=false</code> 。</p><p>另外要注意的是：若是调用了 Object 类的 <code>wait()</code>/<code>notify()</code> 方法，会直接升级为重量级锁。</p><h3 id="偏向锁的延迟特性"><a href="#偏向锁的延迟特性" class="headerlink" title="偏向锁的延迟特性"></a>偏向锁的延迟特性</h3><p><strong>jdk6默认开启偏向锁，但默认情况下是延时开启的，也就是说，<font color="red">程序刚启动创建的对象是不会开启偏向锁的，几秒后后创建的对象才会开启偏向锁的</font></strong>。</p><p>验证示例：（使用 jol 工具包打印对象头，使用 logback 打印日志信息，基于 jdk8，64 位 JVM，<strong>注意打印的字节是小端序</strong>）</p><p>创建一个Dog类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>test1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (dog)&#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210216133250351.png" alt="image-20210216133250351" style="zoom:80%;" /><ul><li>对象刚创建时是normal状态（001）</li><li>由于对象是程序刚启动时就创建，所以进入临界区时是轻量级锁状态（LightWeight locked，00），不是偏向锁状态。</li><li>解锁后回复到normal状态。</li></ul><hr><p>test2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (dog)&#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象是刚启动时创建的，即使延迟5s后进入synchronized也是使用轻量级锁。输出结果与1同。</p><hr><p>test3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    <span class="keyword">synchronized</span> (dog)&#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(ClassLayout.parseInstance(dog).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210216133827656.png" alt="image-20210216133827656"></p><ul><li>延迟5s后再创建dog对象，其初始时是Biased状态（101），只是没有记录线程id等信息。</li><li>进入synchronized后，记录线程id等信息。</li><li>退出synchronized后mark word仍不变。</li></ul><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID<br>当撤销偏向锁阈值到达 20 次（默认次数）时（<strong>即第20次开始</strong>），<strong>jvm会在给<font color="red">之后的对象</font>加锁时重新使用偏向锁，而不是使用轻量级锁</strong>。</p><p>示例见 <code>lock.TestBiased#test6</code> </p><p>在t2的前19次（0-18），给对象加锁时都将偏向锁改为轻量级锁（<strong>即其他线程访问撤销偏向锁的情况</strong>），<strong>在第20次（19）及其之后的加锁中进行了重偏向（注意是加锁一个重偏向一个）</strong>，将Mark Word的线程id改为t2线程。</p><p>重偏向的阈值是20次，<strong>而当到达40次时（即重偏向操作进行了20次），<font color="red">当前类的所有对象</font>都会变为不可偏向</strong>。</p><p>demo见<code>lock.TestBiased.test7</code>。</p><p>在t2的19-38进行了重偏向，在t3的第1次（0）已不可偏向，又使用了轻量级锁。t3之后创建的dog对象不可偏向，而cat对象可以。</p><blockquote><p><strong><font color="red">上述的撤销偏向锁，重偏向、批量撤销偏向锁都是只针对一个类而言</font></strong>。</p></blockquote><hr><blockquote><p>锁消除</p><p>JIT编译器会对一些synchronized块进行优化，若加锁的对象不可能被共享（比如对局部变量加锁），那么JIT会将synchronized去掉，省去不必要的开销。</p></blockquote><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p><strong>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞</strong>。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>JVM 会为每个线程<strong>在当前线程的栈帧中创建用于存储锁记录（Lock Record）的空间</strong>，称为Displaced Mark Word。（当一个线程对一个锁多次重入时，会对应有多个锁记录）</p><p>如果一个线程发现 lockObj 处于轻量级锁状态，则<strong>会先把锁（lockObj）的 Mark Word 复制到锁记录，然后尝试用 CAS 操作将 Mark Word 替换为锁记录地址</strong>，如果成功，表示获取到锁；如果失败，表示已有其他线程占有轻量级锁，<strong>当前线程用自旋尝试获取锁</strong>。</p><p>若是自旋失败，<strong>则会升级为重量级锁，这时当前线程会将 lockObj 的 Mark Word 标志位置为 <code>10</code>，并设置 monitor 对象的地址，然后线程进入 monitor 的 EntryList 进行阻塞，等待竞争锁</strong>。</p><p><strong>关于自旋</strong>：</p><p>自旋是线程占用 CPU 并不断尝试获取锁，一般使用循环。<strong>若是持锁线程在自旋结束前释放了锁，那么当前线程就可以成功获取到锁，避免升级为重量级锁，减少开销</strong>。JVM 采用了适应性自旋——<strong>线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少</strong>。</p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费（即暂停持锁线程让当前线程自旋，显然必定是自旋失败的），多核 CPU 自旋才能发挥优势。 </li><li><strong>在 Java 6 之后自旋锁是自适应的</strong>，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋。 </li><li>Java 7 之后不能控制是否开启自旋功能（默认开启）</li></ul><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁时，当前线程会将用 CAS 操作将锁记录中的内容换回 lockObj 的 Mark Word 中，若没有竞争，该过程会成功，<strong>这时 lockObj 变为无锁状态</strong>；<strong>若有其他线程自旋失败将锁升级为重量级锁，则操作失败，此时会释放锁并唤醒在 monitor 的 EntryList 中阻塞的线程</strong>。</p><p>一张图说明加锁和释放锁的过程：（来自参考链接）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210409103833453.png" alt="image-20210409103833453"></p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁也就是 monitor 锁，不再赘述。</p><h2 id="总结锁的升级流程"><a href="#总结锁的升级流程" class="headerlink" title="总结锁的升级流程"></a>总结锁的升级流程</h2><p>（来自参考链接）</p><p>每一个线程在准备获取共享资源时： 第一步，检查 MarkWord 里面是不是放的自己的 ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。</p><p>第二步，如果 Mark Word 不是自己的 ThreadId ，锁升级，这时候，用 CAS 来执行切换，新的线程根据 Mark Word 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Mark Word 的内容置为空。</p><p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。</p><p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。</p><p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p><p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p><h2 id="各种锁的优缺点对比"><a href="#各种锁的优缺点对比" class="headerlink" title="各种锁的优缺点对比"></a>各种锁的优缺点对比</h2><p>来自《Java并发编程的艺术》：</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td><strong>加锁和解锁不需要额外的消耗</strong>，和执行非同步方法比仅存在纳秒级的差距。</td><td><strong>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</strong>。</td><td><strong>适用于只有一个线程访问同步块场景</strong>。</td></tr><tr><td>轻量级锁</td><td><strong>竞争的线程不会阻塞</strong>，提高了程序的响应速度。</td><td><strong>如果始终得不到锁竞争的线程使用自旋会消耗CPU</strong>。</td><td><strong>追求响应时间。同步块执行速度非常快</strong>。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td><strong>线程阻塞，响应时间缓慢</strong>。</td><td><strong>追求吞吐量。同步块执行时间较长</strong>。</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p> <a href="http://concurrent.redspider.group/article/02/9.html#922-%E5%81%8F%E5%90%91%E9%94%81">synchronized与锁</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象头的Mark-Word&quot;&gt;&lt;a href=&quot;#对象头的Mark-Word&quot; class=&quot;headerlink&quot; title=&quot;对象头的Mark Word&quot;&gt;&lt;/a&gt;对象头的Mark Word&lt;/h2&gt;&lt;p&gt;HotSpot 虚拟机对象的对象头包含两部分。&lt;/p</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="多线程" scheme="http://example.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java并发" scheme="http://example.com/Tag/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Comparable和Comparator用法小结</title>
    <link href="http://example.com/2021/03/29/Java/%E5%85%B6%E4%BB%96/Comparable%E5%92%8CComparator%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://example.com/2021/03/29/Java/%E5%85%B6%E4%BB%96/Comparable%E5%92%8CComparator%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2021-03-29T03:01:14.672Z</published>
    <updated>2021-03-29T03:09:59.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Comparable 接口和 Comparator 接口都是用来比较两个对象。一个类实现 Comparable 表示该类的对象之间可以比较；Comparator 则表示一个比较器，传入两个对象，返回比较结果。</p><p>它们的代码定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组工具类和集合工具类中提供的 sort 排序方法就要求被排序的类实现 Comparable 接口或需要传入一个 Comparator 对象。</p><h2 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h2><p><code>compareTo</code> 或 <code>compare</code> 都是返回一个 int 类型值。</p><p>对于 <code>o1.compareTo(o2)</code> 或 <code>compare(o1, o2)</code> ，返回不同 int 值时的意义：</p><ul><li>返回 0 ，表示两个值相等。</li><li><strong style="color:red">返回 负数，表示 o1 会排在 o2 前面。即若是返回负数，o1、o2 位置不变</strong>。</li><li><strong style="color:red">返回 正数，表示 o1 会排在 o2 后面。即若是返回正数，o1、o2 位置交换</strong>。</li></ul><p>根据这 3 个点，在定义比较规则时，从 “<strong>返回负数表示两个值位置不变</strong>” 这个点入手：</p><ul><li>若是要按某个值升序排序，即返回负数的情况（o1，o2 位置不变）是 o1&lt;o2 ，则应该 <code>return o1-o2</code> 。这样当返回负数时，o1、o2 是升序的，位置不用变；返回正数，表示 o1 大于 o2，此时是降序的，应该交换位置。</li><li>而若是降序，返回负数的情况应是 o1&gt;o2 ，则应该 <code>return o2-o1</code> 。同理。</li></ul><p>示例：</p><p>定义类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">A</span>&gt;</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序时按 num 值递增进行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(A o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递增（升序），对应上面所说的 return o1-o2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num - o.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 A 的多个对象加入 List ，用 sort 方法进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="string">&quot;a1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    A a2 = <span class="keyword">new</span> A(<span class="string">&quot;a2&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    A a3 = <span class="keyword">new</span> A(<span class="string">&quot;a3&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;A&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(a1);</span><br><span class="line">    list.add(a2);</span><br><span class="line">    list.add(a3);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="keyword">before</span> sort: [A&#123;<span class="type">name</span>=<span class="string">&#x27;a1&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a2&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a3&#x27;</span>&#125;]</span><br><span class="line"><span class="keyword">after</span> sort: [A&#123;<span class="type">name</span>=<span class="string">&#x27;a1&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a3&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a2&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure><p>再看一个复杂一点的例子，对一个 nx2 的数组按<strong>第一个值升序排序，若第一个值相等，第二个值倒序排序</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;before sort: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （这里使用 Lambda 表达式， o1、o2 是一个一维数组）</span></span><br><span class="line">    <span class="comment">// 第一个值相等时，第二个值倒序排序；否则第一个值升序排序</span></span><br><span class="line">    Arrays.sort(array, (o1, o2)-&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o2[<span class="number">1</span>] - o1[<span class="number">1</span>] : o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\nafter sort: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before sort:</span> </span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">after sort:</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>]     </span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Comparable 接口和 Comparator 接口都是用来比较两个对象。一个类实现 Comparable 表示该类的对象之间可以比较；</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="其他" scheme="http://example.com/categories/Java/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Java" scheme="http://example.com/Tag/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashSet和LinkedHashSet简单分析-JDK1.8</title>
    <link href="http://example.com/2021/03/23/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashSet%E5%92%8CLinkedHashSet-JDK1.8/"/>
    <id>http://example.com/2021/03/23/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashSet%E5%92%8CLinkedHashSet-JDK1.8/</id>
    <published>2021-03-23T08:26:37.432Z</published>
    <updated>2021-03-23T08:26:23.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HashSet 实质上仍是一个 HashMap ，它<strong>通过组合的方式内部封装了一个 HashMap</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure><p><strong>其所有的操作都是基于这个 HashMap。且 HashSet 只使用 HashMap 的 key，value 使用一个静态成员变量来填充</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>HashMap 拥有无序性、唯一性的特点，HashSet 自然也继承了这些特点。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashSet 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看到前 3 个构造方法和 HashMap 的 3 个方法一一对应，都使用对应的 HashMap 构造方法来初始化 map</strong>。</p><p>另外，最后一个构方法多了一个 boolean 参数，它只是为了跟第 3 个构造方法区分，且初始化的是一个 LinkedHashMap 。这个构造方法是<strong>包访问级别</strong>的，<strong>它是为了给 LinkedHashSet 使用的</strong>。</p><h3 id="add-和-remove"><a href="#add-和-remove" class="headerlink" title="add 和 remove"></a>add 和 remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value 使用 PRESENT 静态变量填充</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看到都是调用 HashMap 对应的方法</strong>。所以 HashSet 的数据操作都是对其中的 map 进行操作的。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>HashSet 和 LinkedHashSet 的继承关系如下：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210323155049269.png" alt="image-20210323155049269" style="zoom:67%;" /><p>可以看到 LinkedHashSet 是 HashSet 的子类。</p><p>LinkedHashSet 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 LinkedHashSet <strong>都是调用父类的最后一个构造方法来创建，即初始化了一个 LinkedHashMap</strong>。LinkedHashSet 的操作同样都是基于这个 LinkedHashMap，所以其<strong>拥有元素的唯一性，又能保持元素的顺序</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两个 Set 集合实质上都一个 Map，其所有操作都是基于这个 map，所以它们的特性跟 HashMap 基本一样。</p><p>所以 HashSet 检查元素重复的过程是：</p><ul><li>计算元素的 hash 值；</li><li>计算对应的桶索引；</li><li>将元素跟桶上的元素比较：<ul><li>若 hash 值不同，则判断两个元素不同</li><li>若 hash 值相同，则继续比较，<ul><li>若 <code>==</code> 或 <code>equals()</code> 比较返回 true，则认为相同；</li><li>否则认为不同。</li></ul></li></ul></li></ul><p><strong>即两个元素相同的标准是：hash 值相同，且  <code>==</code> 或 <code>equals()</code> 比较仍相同</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashSet&quot;&gt;&lt;a href=&quot;#HashSet&quot; class=&quot;headerlink&quot; title=&quot;HashSet&quot;&gt;&lt;/a&gt;HashSet&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap-JDK1.8</title>
    <link href="http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedHashMap%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedHashMap%20-%20JDK1.8/</id>
    <published>2021-03-21T09:11:45.718Z</published>
    <updated>2021-03-21T09:11:27.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedHashMap <strong>继承自 HashMap，在 HashMap 的基础上维护了一个双向链表，解决了 HashMap 遍历顺序和插入顺序不一致的问题</strong>。除此之外，LinkedHashMap <strong>对访问顺序也提供了相关支持</strong>。在一些场景下，该特性很有用，比如实现 LRU 缓存。</p><p>在实现上，LinkedHashMap 很多方法直接继承自 HashMap，<strong>仅为维护双向链表覆写了部分方法</strong>。</p><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>先看Entry 继承体系：</p><p>Map 中 Entry 的继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap.TreeNode -&gt; LinkedHashMap.Entry -&gt; HashMap.Node -&gt; Map.Entry</span><br></pre></td></tr></table></figure><p>它们对应的成员变量：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210321152715920.png" alt="image-20210321152715920" style="zoom:80%;" /><p><strong>可以看到 LinkedHashMap.Entry 中的 before 和 after 变量，它们提供了双向链表的特性</strong>。同时 TreeNode 继承自 LinkedHashMap.Entry，所以它也可以作为双向链表的结点。<strong>LinkedHashMap 中使用的就是这两类结点，它在原本的链表、红黑树基础上通过 before、after 引用维护了一个双向链表</strong>，如下图（<strong>图片来自参考链接</strong>）：</p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg"/><blockquote><p>关于 Entry 继承体系更多细节：<a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/#31-entry-%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB">Entry 继承体系</a> </p></blockquote><h2 id="链表建立过程"><a href="#链表建立过程" class="headerlink" title="链表建立过程"></a>链表建立过程</h2><p>LinkedHashMap 中有<strong>两个引用：head、tail</strong>，指向双向链表的头和尾。</p><p><strong>在通过 <code>put</code> 方法加入元素的时候就同时将新增结点链入链表尾部</strong>。但 <strong style="color:red">LinkedHashMap 并没有覆盖 HashMap 的 put 方法，使用的都是父类的 put</strong> 。<strong>其维护双向链表的关键方法在于插入结点时调用的 <code>newNode()</code> 方法</strong>。</p><p>如下（标 ★★ 处）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中的 put 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中的 putVal 方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// ★★</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// ★★</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap 覆盖了父类的  <code>newNode()</code> 方法</strong>，它们的区别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建的是 Node 类型结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建的是 LinkedHashMap.Entry 类型结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 将 p 链入双向链表尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap</span></span><br><span class="line"><span class="comment">// 将 p 链入双向链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:red">所以关键点是 LinkedHashMap 覆盖了父类的  <code>newNode()</code> 方法，在创建结点时使用的是这个覆盖方法，在该方法中创建的是 LinkedHashMap.Entry 类型的结点，并将其链入双向链表尾部</strong>。</p><p>通过维护双向链表，在遍历时只要顺着链表遍历就可以保证遍历顺序跟插入顺序一致。</p><p>另外，在 put 方法的最后还有一个 <code>afterNodeInsertion(evict);</code> 方法，在 JDK 1.8 HashMap 的源码中，相关的方法有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>这些方法的用途是<strong>在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中</strong>。即 LinkedHashMap  覆盖了这 3 个回调方法。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>与插入操作一样，LinkedHashMap 的删除操作也是直接使用父类的实现。<strong>在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。<font color="red">LinkedHashMap 删除结点后维护链表的操作是通过上述的回调方法实现的</font></strong>。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);<span class="comment">// ----删除结点后调用回调方法----</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆盖</span></span><br><span class="line"><span class="comment">// 将指定结点从链表中断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">// 结点向下转型为 LinkedHashMap.Entry </span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="维护访问顺序"><a href="#维护访问顺序" class="headerlink" title="维护访问顺序"></a>维护访问顺序</h2><p>上文讲的是 LinkedHashMap 如何维护插入顺序，而除了插入顺序， LinkedHashMap 还可以维护访问顺序， LinkedHashMap 有一个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p><strong>该变量为 true 时表示启用访问顺序维护</strong>。该值默认为 false ，可通过该构造方法指定为 true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所谓维护访问顺序就是：当调用<code>get/getOrDefault/replace</code>等访问了结点的方法时，将这些方法访问的结点移动到链表的尾部</strong>。</p><p>代码：（<strong>注意 LinkedHashMap 重写了两个 get 方法</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 若 accessOrder 为 true，调用 afterNodeAccess</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 若 accessOrder 为 true 且当前结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 讲 p 从原位置移除</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 讲 p 链入尾部</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h2><p>LinkedHashMap 的最后一个回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 根据条件判断是否移除最近最少被访问的节点（头结点）</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，removeEldestEntry 方法是一个空实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以通过继承 LinkedHashMap ，并重写该方法、自实现判断逻辑来实现 LRU 缓存</strong>。比如根据结点数量或结点存货时间来判断是否要移除。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/">LinkedHashMap 源码详细分析（JDK1.8） - 田小波</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedHashMap &lt;strong&gt;继承自 HashMap，在 HashMap 的基础上维护了一个双向链表，解决了 HashMap </summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashMap-JDK1.7</title>
    <link href="http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.7/"/>
    <id>http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.7/</id>
    <published>2021-03-21T02:39:00.462Z</published>
    <updated>2021-03-21T02:38:42.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="底层存储结构"><a href="#底层存储结构" class="headerlink" title="底层存储结构"></a>底层存储结构</h2><p>内部<strong>包含了一个 Entry 类型的数组 table。Entry 存储着键值对</strong>。且每个 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。<strong>JDK1.7 的 HashMap 使用拉链法来解决冲突，同一个链表中存放 哈希值和数组取模运算 结果相同（即桶索引相同）的 Entry</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>JDK1.7 的构造方法机制与 JDK1.8 大致相同，都只是先初始化 threshold、loadFactor，存储元素的数组等到第一次插入键值时才根据 threshold、loadFactor 的值创建。</p><h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 key 为 null，作另外处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据 hash 和 table 长度计算桶索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先遍历索引所在的链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 若 hash 相同，且key相同（== 或 equals ），则进行 value 的替换</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 否则使用头插法插入新结点</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>key 为 null 时，因为无法调用其 <code>hashCode()</code> 计算 hash 值，所以 HashMap 把 key 为 null 的值放在 <code>table[0]</code></strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addEntry：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩容检查</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 扩容后重新计算索引</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新结点</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外要注意的是开头的判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 table 为空，说明其还未初始化，调用 inflateTable 方法初始化，<strong>会根据 threshold 找到一个大于它的最小的 2 的幂次方的数作为 table 的长度</strong>。</p><h2 id="确定桶下标"><a href="#确定桶下标" class="headerlink" title="确定桶下标"></a>确定桶下标</h2><p><code>put()</code> 方法中的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 hash</span></span><br><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="comment">// 根据 hash 和 table 长度计算桶索引</span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"><span class="comment">//========================================</span></span><br></pre></td></tr></table></figure><p>hash 方法（<strong>扰动函数</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 h 值进行 4 次扰动，减少哈希碰撞</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexFor 方法：</p><ul><li><strong>若一个正整数 x 是 2 的 n 次方，则对于 任一整数 y，有 <code>y % x = y &amp; (x - 1)</code></strong>。</li><li>所以 indexFor 方法实际上是进行了 <code>%</code> 运算，<strong style="color:red">使用 <code>y &amp; (x - 1)</code> 形式的原因是对于计算机来说，位运算效率更高</strong>。</li><li><strong>HashMap 的容量总是 2 的 n 次方</strong>，所以总是满足该关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容原理"><a href="#扩容原理" class="headerlink" title="扩容原理"></a>扩容原理</h2><p>在添加结点时，会先判断 size 是否到达阈值，到达则扩容，新容量指定为原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩容逻辑在 resize 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原数组的元素转移到新数组</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 重新计算阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据新容量重新计算桶索引</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 头插法插入</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;底层存储结构&quot;&gt;&lt;a href=&quot;#底层存储结构&quot; class=&quot;headerlink&quot; title=&quot;底层存储结构&quot;&gt;&lt;/a&gt;底层存储结构&lt;/h2&gt;&lt;p&gt;内部&lt;strong&gt;包含了一个 Entry 类型的数组 table。Entry 存储着键值对&lt;/strong</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList-JDK1.8</title>
    <link href="http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/ArrayList%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/ArrayList%20-%20JDK1.8/</id>
    <published>2021-03-20T14:20:41.630Z</published>
    <updated>2021-03-20T14:19:59.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些重要成员变量"><a href="#一些重要成员变量" class="headerlink" title="一些重要成员变量"></a>一些重要成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    // 实现了 <span class="title">RandomAccess</span> ，表示具有随机访问的特性</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组最大长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定容量为 0 时 elementData 的初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用无参构造器时 elementData 的初始值（默认大小时）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定长度的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定为 0 时，赋值一个空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造器</span></span><br><span class="line"><span class="comment">// 默认长度是 10，但调用构造器并不会将 elementData 初始化为长度为 10 的数组，</span></span><br><span class="line"><span class="comment">// 而是赋值一个空数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>ArrayList 提供了两个 add 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素插入到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量检查</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">// 将新元素插入序列尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入到 index 位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引合法性</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add(int index, E element)</code> 每次都需要移动元素，时间复杂度是 O(n) ，若是频繁使用会影响效率，应尽量少使用。</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p><strong>调用 <code>add</code> 方法时，插入元素之前都会先进行容量检查，若容量不够，则需要进行扩容</strong>。扩容的新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，大约是旧容量的 1.5 倍。扩容的具体实现在 <code>grow()</code> 方法，<strong>扩容时使用 <code>Arrays.copyOf()</code> ，这个操作代价很高</strong>。</p><p><strong>如果能确定元素个数，则最好在创建 ArrayList 对象时就指定容量大小，减少扩容操作的次数</strong>。</p><p>扩容逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果使用的是默认构造器，elementData 会被赋值为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA（空数组），</span></span><br><span class="line"><span class="comment">// 在第一次添加元素时（没有使用ensureCapacity主动扩容），会将数组扩容到长度为 10（即默认长度 - DEFAULT_CAPACITY）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若指定的最小容量大于 当前数组的长度 ，进行扩容。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若所需最小容量大于当前数组长度，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 扩容的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量，为旧容量的 1.5 倍左右</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="comment">// 如果 1.5 倍新容量小于最小所需容量，将新容量置为 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 若 newCapacity 大于 MAX_ARRAY_SIZE，计算新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 若最小所需容量大于 MAX_ARRAY_SIZE ，返回 Integer.MAX_VALUE ， 否则 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 还提供一个主动扩容的方法，该方法将数组扩容为指定大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少重新分配的次数</strong>。</p><p><strong>若是使用无参构造器创建一个 ArrayList（即默认长度为 10），并不会一开始就将 elementData 初始化为长度为 10 的数组，只是赋值一个空数组</strong>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>会等到第一次添加元素时，才会将数组长度扩容为 10</strong>（会在 calculateCapacity 方法中判断 elementData 是否是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，若是，指定 minCapacity 为 10）。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>ArrayList 有两个 remove 方法：</p><p>它们的操作的时间复杂度为 O(N)，所以 ArrayList 删除元素的代价是非常高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定索引处的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 要删除的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要移动元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从数组的 index+1 位置开始，将 numMoved 个元素依次向前移动一位，覆盖被删除值</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将最后一个元素置空，并将 size 值减1    </span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除所有 null 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速删除，即不用进行索引检查，不返回被删除元素值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize"></a>trimToSize</h3><p>往 ArrayList 插入大量元素后，又删除很多元素，<strong>此时底层数组会空闲出大量的空间。因为 ArrayList 没有自动缩容机制，导致底层数组大量的空闲空间不能被释放，造成浪费</strong>。对于这种情况，ArrayList 也提供了相应的处理方法，即 trimToSize 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果当前元素个数小于数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = </span><br><span class="line">            <span class="comment">// size 为 0 直接赋值为空数组</span></span><br><span class="line">            (size == <span class="number">0</span>)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            <span class="comment">// 否则只保留前 size 个元素</span></span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>ArrayList 实现了 RandomAccess 接口（该接口是个标志性接口），表明它具有随机访问的能力。在遍历 ArrayList 时，使用 for 循环的效率会比使用 foreach 效率要高，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 foreach 会转化为使用迭代器遍历，效率不如使用 for 循环</strong>。</p><h2 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h2><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此<strong>保存元素的数组不一定都会被使用</strong>，那么就<strong>没必要全部进行序列化</strong>。</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><p>ArrayList 实现了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制<strong>只序列化数组中有元素填充那部分内容</strong>。</p><p>序列化时会调用 <code>writeObject()</code> 方法，<strong>该方法在传入的对象存在 <code>writeObject()</code> 方法时会去反射调用该对象的 writeObject() 来实现序列化</strong>。反序列化原理类似。</p><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><p>ArrayList 有一个继承自 AbstractList 的成员变量 <code>modCount</code> ，记录 ArrayList 被改变的次数（添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小时），<strong>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException</strong>。在 <code>writeObject()</code> 方法中有所体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.tianxiaobo.com/2018/01/28/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ArrayList 源码分析 - 田小波</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">ArrayList 源码+扩容机制分析 - JavaGuide</a> </p><p><a href="http://www.cyc2018.xyz/Java/Java%20%E5%AE%B9%E5%99%A8.html">Java 容器 - CyC</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些重要成员变量&quot;&gt;&lt;a href=&quot;#一些重要成员变量&quot; class=&quot;headerlink&quot; title=&quot;一些重要成员变量&quot;&gt;&lt;/a&gt;一些重要成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList-JDK1.8</title>
    <link href="http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedList%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedList%20-%20JDK1.8/</id>
    <published>2021-03-20T14:20:41.629Z</published>
    <updated>2021-03-20T14:04:20.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedList 的继承体系：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320171051562.png" alt="image-20210320171051562" style="zoom:67%;" /><p>LinkedList <strong>底层是基于双向链表实现的，所以 LinkedList 的容量上限是物理内存或 JVM 内存上限，它无需像 ArrayList 般进行扩容，且支持高效的插入和删除操作</strong>，但是<strong>存储元素的节点需要额外的空间存储前驱和后继的引用</strong>，且不支持 O(1) 的随机访问，虽然实现了 List 接口，有 <code>get(int)</code> 方法，但其时间复杂度是 O(n) 。</p><p><strong>LinkedList 中有两个引用 first、last 分别指向头结点和尾结点，所以在链表头部和尾部插入效率比较高，但在其他指定位置进行插入时，效率一般</strong>。因为在指定位置插入<strong>需要先定位到该位置处的节点</strong>，此操作的时间复杂度为 O(n)。另外，LinkedList 是非线程安全的集合类。</p><p>LinkedList 可以作为队列、栈来使用。需要使用栈时应优先使用 LinkedList ，而避免使用 Stack 类。</p><p>关于 AbstractSequentialList 抽象类：AbstractSequentialList 提供了一套基于顺序访问的接口。通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口。<strong>但 LinkedList 并没有直接该类的方法，而是重新实现了一套方法</strong>。</p><p>LinkedList 内的结点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回索引 index 对应的结点（即第 index+1 个结点）</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 根据 index 是否小于 size 的一半决定从 first 还是 last 开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 LinkedList 因为是基于链表实现，索引不能随机访问元素。这里有<strong>一个小优化</strong>：会根据 index 离哪一端近来决定从 first 还是 last 开始遍历。</p><p>此外，LinkedList 还有针对队列和栈的一些方法：<code>getFirst() getLast() poll() pop()</code>  等，都是直接返回头结点或尾结点的值。</p><h2 id="关于遍历的问题"><a href="#关于遍历的问题" class="headerlink" title="关于遍历的问题"></a>关于遍历的问题</h2><p><strong>遍历 LinkedList 应该使用 iterator 或者 foreach 循环（会转换为使用 iterator ）</strong>，应该避免如下形式的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    Integet item = list.get(i);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedList 的 <code>get(int)</code> 方法时间复杂度是 O(n) ，若是集合中的元素数量较大，效率会很低</strong>。</p><p>LinkedList 的迭代器实现：</p><blockquote><p>调用 <code>iterator()</code> 方法时最终会调用 <code>listIterator(0)</code> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定索引开始迭代</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>LinkedList 继承和实现了多个类和接口，有很多插入元素的方法，如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320210837017.png" alt="image-20210320210837017"></p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320210935569.png" alt="image-20210320210935569"></p><p>针对队列和栈的一些方法大都是在头结点和尾结点操作，逻辑较简单，这里主要分析前 add 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 直接插入到链表尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 先找到 index 位置的结点（node(index)），再把 element 插入到该结点之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// last 后移</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点 </span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 新结点的 prev 指向 succ 的 prev，next 指向 succ</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// succ 的 prev 指向新结点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 若 succ 原本是头结点，则插入新结点后将 first 指向 newNode</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则 pred 的 next 连接 newNode</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些操作都是典型的链表操作，不难理解。</p><p><code>add(index, element)</code> 的逻辑是：</p><ul><li>若 index 等于 size，<strong>表示要插入链表尾部，直接调用 linkLast 即可</strong>；</li><li><strong>否则需要先定位到 index 处的结点，再把新结点插入到该结点之前</strong>。</li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>相对 LinkedList 的插入方法，它也有很多对应的删除方法，这里主要分析 <code>remove(index)</code> 和 <code>remove(obj)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的元素，返回该元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">// 检查索引</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，删除成功返回 true，否则 false</span></span><br><span class="line"><span class="comment">// 若是有多个相同的值，则只删除找到的第一个（unlink 后立即 return）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// o 为 null 值</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 不为 null。使用 equals 比较</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定节点从链表中移除</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prev 为空表示 x 是头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 first 指向 next 即可</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;<span class="comment">///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似的，判断 x 是不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;<span class="comment">///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//将 x 的 item 引用置 null</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink 方法的逻辑如下（假设删除的节点既不是头节点，也不是尾节点）：</p><ol><li>将待删除节点 x 的前驱的后继指向 x 的后继</li><li><strong>将待删除节点 x 的前驱引用置空，断开与前驱的链接</strong> </li><li>将待删除节点 x 的后继的前驱指向 x 的前驱</li><li><strong>将待删除节点 x 的后继引用置空，断开与后继的链接</strong> </li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.tianxiaobo.com/2018/01/31/LinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK-1-8">LinkedList 源码分析(JDK 1.8) - 田小波</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedList 的继承体系：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/bxgitee/noteImage/ra</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL概述</title>
    <link href="http://example.com/2021/03/20/MySQL/MySQL%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/03/20/MySQL/MySQL%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-20T12:57:38.415Z</published>
    <updated>2021-03-20T12:59:33.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        MySQL很牛逼。</p><p><strong><span style="color:red">MySQL是属于C/S架构的软件</span></strong>。</p><p>MySQL的优点：可将数据持久化到本地；可用sql语言进行查询，便于管理。</p><hr><h2 id="MySQL的卸载及安装"><a href="#MySQL的卸载及安装" class="headerlink" title="MySQL的卸载及安装"></a>MySQL的卸载及安装</h2><h3 id="MySQL卸载"><a href="#MySQL卸载" class="headerlink" title="MySQL卸载"></a>MySQL卸载</h3><p>MySQL的卸载：<a href="https://www.bilibili.com/video/BV12b411K7Zu?p=249">https://www.bilibili.com/video/BV12b411K7Zu?p=249</a>  第6集</p><h3 id="MySQL8-0-22的安装"><a href="#MySQL8-0-22的安装" class="headerlink" title="MySQL8.0.22的安装"></a>MySQL8.0.22的安装</h3><p><a href="https://blog.csdn.net/qq_43715354/article/details/109354222">https://blog.csdn.net/qq_43715354/article/details/109354222</a></p><p>按照该教程至第八步。</p><ul><li><p>启动cmd。</p></li><li><p>输入<code>mysql -u root -p</code> </p></li><li><p>输入上述随机生成的密码进入数据库。进入后需要修改密码，因为随机生成的密码在登录后会过期。（这时若不修改密码，执行一切sql语句都会报错，提醒修改密码）</p></li><li><p>修改密码的命令：</p><ul><li><p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;newPassword&#39;;</code> </p></li><li><p><code>flush privileges;</code> </p></li></ul></li></ul><h3 id="my-ini文件"><a href="#my-ini文件" class="headerlink" title="my.ini文件"></a>my.ini文件</h3><p>MySQL的安装目录下的<code>my.ini</code>文件是MySQL的配置文件，在其中可配置相关信息（#开头的为注释），其中的<code>[mysqld]</code>下可配置服务端的相关信息，如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\\Program Files\MySQL\mysql-<span class="number">8.0</span>.<span class="number">22</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\\Program Files\MySQL\mysql-<span class="number">8.0</span>.<span class="number">22</span>\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为utf8mb4</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment">#mysql_native_password</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br></pre></td></tr></table></figure><hr><h2 id="MySQL服务的启动和关闭"><a href="#MySQL服务的启动和关闭" class="headerlink" title="MySQL服务的启动和关闭"></a>MySQL服务的启动和关闭</h2><p>可通过</p><p><strong>【右键我的电脑】-》【管理】-》【服务和应用程序】-》【服务】-》【找到MySQL】-》【双击，选择启动/关闭】</strong> </p><p>或者：</p><p><strong>以【管理员身份运行命令行】-》【输入命令<code>net stop/start mysqlServerName</code>】</strong> </p><hr><h2 id="登录MySQL及环境变量"><a href="#登录MySQL及环境变量" class="headerlink" title="登录MySQL及环境变量"></a>登录MySQL及环境变量</h2><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><p>​        可通过MySQL自带的命令行（只能登录root用户）。</p><p>​        也可通过命令行：</p><p>​        <code>mysql -h localhost -P 3306 -u root -p </code> </p><p>​        <code>mysql -h localhost -P 3306 -u root -padmin</code> （<strong>用于连接远程</strong>）</p><p>​        <code>mysql -u root -pPassword</code> （<strong>连接本地MySQL</strong>）</p><h3 id="MySQL环境变量"><a href="#MySQL环境变量" class="headerlink" title="MySQL环境变量"></a>MySQL环境变量</h3><p>​        若以上命令不可用，可能原因是没有配置环境变量（<strong>若是使用msi安装包安装则MySQL会自动配置</strong>）。</p><p>​        手动配置过程：在<code>Path</code>环境变量中添加MySQL的安装目录中的bin目录路径即可。</p><hr><h2 id="MySQL语法规范及常用命令"><a href="#MySQL语法规范及常用命令" class="headerlink" title="MySQL语法规范及常用命令"></a>MySQL语法规范及常用命令</h2><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ul><li>MySQL中的<strong>命令以<code>;</code>或<code>\g</code>结束</strong>。</li><li>MySQL命令不区分大小写。</li><li>注释<ul><li>单行注释：<code>#注释</code>或<code>-- 注释</code>(空格必需)</li><li>多行注释：<code>/* 注释 */</code> </li></ul></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>进入MySQL后，可使用以下相关命令：</p><p>显示所有数据库：<strong><code>show databases;</code></strong> </p><p><code>----------------------------------</code> </p><p>使用指定数据库：<strong><code>use dababaseName;</code> </strong></p><p><code>----------------------------------</code>   </p><p>显示当前数据库中的所有表：<strong><code>show tables;</code> </strong></p><p><code>----------------------------------</code> </p><p>显示指定数据库的所有表（<strong>使用该命令后，当前数据库位置不变</strong>）：<strong><code>show tables from databaseName</code> </strong></p><p><code>----------------------------------</code> </p><p>查看表结构：<strong><code>desc tableName</code> </strong> </p><p><code>----------------------------------</code> </p><p>查看MySQL版本：</p><p>在MySQL中：<strong><code>select version();</code> </strong> </p><p>在MySQL外：<strong><code>mysql --version</code>或<code>mysql -V</code> </strong> </p><p><code>----------------------------------</code> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        MySQL很牛逼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;MySQL是属于C/S架</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="http://example.com/2021/03/20/MySQL/%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/03/20/MySQL/%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-03-20T12:55:23.154Z</published>
    <updated>2021-03-20T12:59:41.520Z</updated>
    
    <content type="html"><![CDATA[<p>（以下部分内容摘抄自<a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL" target="_blank">javaGuide博客文档</a>）</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​        <strong>事务是逻辑上的一组操作，即一个或多个SQL语句，要么都执行，要么都不执行</strong>。<strong>如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚</strong>。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功， 则事物被顺利执行。</p><p>​        事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200716162156.png"></p><ol><li><p><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p><ul><li><p><strong>ACID里的AID都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个C,实际上它依赖于应用层,也就是依赖于开发者.这里的一致性是指<font color="red">系统从一个正确的状态,迁移到另一个正确的状态</font>.什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性</strong>。</p><p>（来自<a href="https://www.zhihu.com/question/31346392/answer/362597203">https://www.zhihu.com/question/31346392/answer/362597203</a> 作者：孟波）</p></li></ul></li><li><p><strong>隔离性（Isolation）：</strong> 并发访问数据库时，<strong>一个用户的事务不被其他事务所干扰</strong>，各并发事务之间是独立的；</p></li><li><p><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ol><h3 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h3><p>​        事务可分为隐式事务和显式事务。隐式事务如DML语言（insert、update、delete），每一个语句都是一个事务；而显式事务通过sql语句开启事务跟关闭事务，一个事务可有多条语句。</p><p>​        <strong>msyql默认关闭事务，通过<code>SHOW VARIABLES LIKE &#39;%autocommit%&#39;;</code>命令可看到``autocommit=ON`，即自动提交默认开启。创建事务前需关闭自动提交</strong>。<strong><span style="color:red;">事务中不能包括DDL语句</span></strong>。</p><p>显示事务的创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.开启事务</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> TRASACTION; <span class="comment">#可选</span></span><br><span class="line"><span class="comment">--编写事务语句</span></span><br><span class="line">语句1</span><br><span class="line">语句2</span><br><span class="line">...</span><br><span class="line"><span class="comment">--结束事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>一个转账的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>(</span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">money <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">account</span> <span class="keyword">VALUES</span>(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">1000</span>),(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#转账例子</span></span><br><span class="line"><span class="comment">#开启事务（关闭事务自动提交）</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">#事务语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">1500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line"><span class="comment">#提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h4 id="回滚点SAVEPOINT"><a href="#回滚点SAVEPOINT" class="headerlink" title="回滚点SAVEPOINT"></a>回滚点SAVEPOINT</h4><p>​        回滚点跟<code>ROLLBACK</code>搭配使用，其作用是设置一个保存点，当执行<code>ROLLBACK</code>时回滚到保存点。</p><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> a;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> a;</span><br></pre></td></tr></table></figure><p>执行以上语句后查询account表，可发现只删除了id为2的记录。</p><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p>​        在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（<strong>多个用户对同一数据进行操作</strong>）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><p><strong>脏读（Dirty read）:</strong> <strong>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的</strong>，比如可能出现错误而回滚事务，导致修改后的数据没有存入数据库。</p></li><li><p><strong>丢失修改（Lost to modify）:</strong> <strong>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改</strong>。 例如：</p><ul><li><p>事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。（<strong>即结果应该是A=18，但因为事务2的修改覆盖了事务1的修改，使事务1丢失</strong>）</p></li><li><p>考虑飞机订票系统中的一个活动序列: </p><ol><li>甲售票点（甲事务）读出某航班的机票余额A,设A=16. </li><li>乙售票点（乙事务）读出同一航班的机票余额A,也为16. </li><li>甲售票点卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库. </li><li>乙售票点也卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库. </li></ol><p><strong><span style="color:red">结果明明卖出两张机票，数据库中机票余额只减少1</span></strong>。 </p></li></ul></li><li><p><strong>不可重复读（Unrepeatableread）:</strong> <strong>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的结果可能不一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读</strong>。（事务1读数据的过程中，事务2把数据给改了，导致事务1两次读的数据不同）</p></li><li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，<strong>第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</strong>。（<strong>在同一事务下，连续执行两次同样的SQL语句第二次的SQL语句可能返回之前不存在的行</strong>）</p></li></ul><p><strong><span style="color:red">不可重复读和幻读区别</span></strong>： </p><p><strong>不可重复读的重点是数据的值被修改，比如多次读取一条记录发现其中某些列的值被修改</strong>，幻读的重点在于<strong>新增或者删除比如多次读取一条记录发现记录增多或减少了</strong>。</p><h3 id="MySQL的事务隔离级别"><a href="#MySQL的事务隔离级别" class="headerlink" title="MySQL的事务隔离级别"></a>MySQL的事务隔离级别</h3><p><strong><span style="color:red">SQL 标准定义了四个隔离级别：</span></strong> </p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong><span style="color:red">可能会导致脏读、幻读或不可重复读</span></strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong><span style="color:red">可以阻止脏读，但是幻读或不可重复读仍有可能发生</span></strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> <strong>对同一字段的多次读取结果都是一致的</strong>，除非数据是被本身事务自己所修改，<span style="color:red"><strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></span>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> <strong>最高的隔离级别，完全服从ACID的隔离级别</strong>。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但效率极低。该标准类似于线程锁。</li></ul><p>可总结为下表（<strong>打勾表示可能发生</strong>）</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>MySQL <strong>InnoDB 存储引擎</strong>的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。可以<strong>通过<code>SELECT @@tx_isolation;</code>命令</strong>来查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure><p>​        <strong><span style="color:red">这里需要注意的是</span></strong>：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是<strong>Next-Key Lock 锁算法</strong>，因此<strong><span style="color:red">可以避免幻读的产生</span></strong>，这与其他数据库系统(如 SQL Server) 是不同的。所以说<strong><span style="color:red">InnoDB 存储引擎的默认支持的隔离级别已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别</span></strong>。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，<strong>但是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读），<span style="color:red"> 并不会有任何性能损失</span></strong>。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><p>设置事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span>/<span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> </span><br><span class="line"><span class="keyword">read</span> uncommitted | <span class="keyword">read</span> committed | repeatable <span class="keyword">read</span>(默认) | <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure><h3 id="锁机制与InnoDB锁算法（to-be-continue）"><a href="#锁机制与InnoDB锁算法（to-be-continue）" class="headerlink" title="锁机制与InnoDB锁算法（to be continue）"></a>锁机制与InnoDB锁算法（to be continue）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（以下部分内容摘抄自&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL&quot; target=&quot;_blank&quot;&gt;javaGuide博客文档&lt;/a&gt;）&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HashMap-JDK1.8</title>
    <link href="http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.8/</id>
    <published>2021-03-20T04:12:49.715Z</published>
    <updated>2021-04-17T04:24:07.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashMap 最早出现在 JDK1.2 ，底层基于哈希表实现，<strong>JDK1.8 之前处理哈希碰撞使用的是拉链法，在 JDK1.8 引入了红黑树优化，即当链表过长时会转换为红黑树，提高查询效率</strong>。HashMap 允许 null 键和 null 值，null 键对应的哈希值是 0。<strong>HashMap 不保证键值对的顺序，在某些操作后，键值对的顺序会改变</strong>（比如扩容时）。</p><p>HashMap <strong>不是线程安全集合</strong>。</p><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>HashMap 使用拉链法哈希算法，<strong>在 JDK1.8 引入红黑树来优化过长链表</strong>。</p><p>HashMap 定位元素的过程是：</p><ul><li>计算桶索引。</li><li>在桶所在链表（或红黑树）查找元素。</li></ul><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，只执行 <code>resize()</code> 方法对数组扩容。</p><h2 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h2><p>HashMap 的 4 个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">// 默认装载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">// 默认初始容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了第 3 个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 以上皆是参数检查</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>构造方法只是初始化一些重要变量，而其他数据结构是延迟到插入键值对时再进行初始化</strong>。</p><h3 id="初始容量、负载因子、阈值"><a href="#初始容量、负载因子、阈值" class="headerlink" title="初始容量、负载因子、阈值"></a>初始容量、负载因子、阈值</h3><table><thead><tr><th align="left">名称</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">initialCapacity</td><td align="left">HashMap 初始容量</td></tr><tr><td align="left">loadFactor</td><td align="left">负载因子</td></tr><tr><td align="left">threshold</td><td align="left">当前 HashMap 所能容纳键值对数量的最大值（阈值），超过这个值，则需扩容</td></tr></tbody></table><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The load factor used when none specified in constructor. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The next size value at which to resize (capacity * load factor). */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>HashMap 中并没有定义 capacity 这个属性，它只是构造方法中用一次，没必要定义一个变量保存。</p><p>其中，<code>threshold=capacity*loadFactor</code>，这里要注意的一个点是，<strong>上面的 tableSizeFor 方法并不是这么初始化 threshold 的值的</strong>。</p><p>在构造方法 3 中，可以看到使用了 tableSizeFor 方法来初始化 threshold 值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 cap 减 1</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 进行 5 次移位、或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 最后 + 1</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的<strong>目的是找到大于或等于 cap 的最小的 2 的幂次方的数</strong>，将该值赋值给 threshold  。<strong style="color:red">这里其实不是计算 threshold ，而是根据指定的 cap 计算 table 的容量，只是将值暂存在 threshold </strong>。</p><p>负载因子的作用是规定了可使用的容量比例，通过调节负载因子，可使 HashMap 时间和空间复杂度上有不同的表现：</p><ul><li>将负载因子调小，即所能容纳的数据表少，但相应的会减少键之间的哈希碰撞，链表长度减少，使得增删查改效率变高，<strong>这就是典型的拿空间换时间</strong>；</li><li>反之，将负载因子调大，能提高空间利用率，但哈希碰撞概率增大，性能相对下降。</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>get 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// (n - 1) &amp; hash 计算得出 key 对应的桶索引</span></span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断桶第一个元素是不是目标</span></span><br><span class="line">        <span class="comment">// hash 值相同</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            <span class="comment">// 且通过 == 比较相同或 equals 比较相同</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 第一个元素不是目标</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若是红黑树，在红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则在链表中查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总结一下查找 key 的过程（省略一些 null 检查）：</span></span><br><span class="line"><span class="comment">// 1. 先计算 key 对应的桶索引</span></span><br><span class="line"><span class="comment">// 2. 获取桶的第一个结点，判断该结点是否是目标，</span></span><br><span class="line"><span class="comment">//    其中，判断标准是：hash 相同且使用 == 或 equals 比较相同</span></span><br><span class="line"><span class="comment">// 3. 否则再根据 first 是红黑树还是链表进行查找，判断标准跟上同</span></span><br></pre></td></tr></table></figure><h3 id="计算桶索引"><a href="#计算桶索引" class="headerlink" title="计算桶索引"></a>计算桶索引</h3><p>分析其中计算桶索引的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first = tab[(n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p><strong>HashMap 中桶数组的大小 length 保证总是 2 的 n 次幂</strong>，<strong style="color:red">此时，<code>(n - 1) &amp; hash</code> 等价于 hash 值对 length 取余，即计算桶索引实质上是 hash 值对桶数组取模，使用位运算计算方式的原因是对于计算机来说，位运算效率更高</strong>。</p><blockquote><p><strong>若一个正整数 x 是 2 的 n 次方，则对于 任一整数 y，有 <code>y % x = y &amp; (x - 1)</code></strong> 。</p></blockquote><p>再看看计算 hash 值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>并不是直接使用 key 的 hashCode() 方法返回值，而是会再进行一次异或操作</strong>。</p><p><code>&gt;&gt;&gt;</code> 是右移补零操作符，int 类型值是 4 个字节，即 32 位，通过 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 的方式可以让高 16 位值与低 16 位值进行异或，<strong>即让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中，加大 hash 值的复杂度</strong>。</p><p><strong style="color:red">重新计算 hash 可以增加 hash 的复杂度，当覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因</strong>。</p><p>还要注意的一个点是：HashMap 是允许 key 为 null 的，<strong>当 key 为 null 时，由 hash 方法可看出返回的是 0 ，则 key 为 null 的键值对总是对应桶索引 0</strong> 。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>核心逻辑在 putVal 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 若 table 为空或长度为 0 ，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算对应的桶索引，若索引处为空，直接插入键值对即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶索引处已有键值对</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 先判断第一个键值对，若 hash 相同，且 == 或 equals 比较相等，将 e 指向 p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶中引用类型是 TreeNode，则调用红黑树的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 链表中不包含要插入的键值对，将该结点插入到链表最后</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 若链表长度到达树化阈值，则进行树化操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  hash 相同，且 == 或 equals 比较相等，停止循环（此时 e 指向 p.next）</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要插入的键值对是否存在 HashMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span></span><br><span class="line">            <span class="comment">// 通过 put(k, v) 调用该方法时，onlyIfAbsent 为 false ，所以只要 e 不为 null 就会更新</span></span><br><span class="line">            <span class="comment">// 若 onlyIfAbsent 为 true，则 oldValue 为 null 才指向更新</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// HashMap 中该方法为空方法</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 插入后若 size 到达阈值，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// HashMap 中该方法为空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal 方法总结：</p><ul><li><strong style="color:red">当桶数组 table 为空时，通过扩容的方式初始化 table</strong>（初始化 HashMap 后第一次插入值就会通过扩容初始化 table）。</li><li>计算桶索引，若对应的桶为 null，直接插入即可。</li><li>若桶已存有值<ul><li><strong>先比较第一个结点的 key 是否相同，是则更新</strong>。</li><li><strong>判断结点类型是否是树结点</strong>，是则按红黑树的方式插入键值对。</li><li>否则将键值对<strong>插入链表尾部</strong>或更新 key 相同的结点的值，如果是前者，<strong style="color:red">则链入链表后需要根据链表长度决定是否将链表转为红黑树</strong>。</li></ul></li><li><strong>插入新键值对后判断键值对数量是否大于阈值，大于的话则进行扩容操作</strong>。</li></ul><p><strong>两个 key “相同”的标准是两个 key 的 hash 相同且通过 <code>==</code> 或 <code>equals()</code> 比较返回 true</strong> 。<strong>HashMap 中可以存在两个 hash 相同，但 key 通过 equals 比较不相同的键值对</strong>。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>扩容逻辑位于 resize 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 计算新容量(newCap)和新阈值(newThr)</span></span><br><span class="line">    <span class="comment">// table 不为空，已经初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">        <span class="comment">// 将阈值置为 Integer.MAX_VALUE ，直接返回 oldTab</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试按旧容量和阈值的 2 倍计算新容量和阈值的大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// table 为空，且 oldThr 大于 0</span></span><br><span class="line">    <span class="comment">// 调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况</span></span><br><span class="line">    <span class="comment">// 此时 threshold 存的是 capacity</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// table 为空，且 oldThr 也为 0，对应调用 HashMap() 的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 置为默认容量大小</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// threshold = capacity * loadfactor</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按阈值计算公式进行计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">///=============================</span></span><br><span class="line">    <span class="comment">// 2. 创建新 table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 3. 将旧table的值映射到新table</span></span><br><span class="line">    <span class="comment">// 旧 table 不为空，则需要将其中的元素重新映射到新 table</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 当前桶只有一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 当前桶存的是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>resize 方法的逻辑概括</strong>：</p><ul><li>计算新桶数组的容量 newCap 和新阈值 newThr。</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li><li><strong>将键值对节点重新映射到新的桶数组里</strong>。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。    </li></ul><h3 id="计算-newCap-和-newThr-逻辑分析"><a href="#计算-newCap-和-newThr-逻辑分析" class="headerlink" title="计算 newCap 和 newThr 逻辑分析"></a>计算 newCap 和 newThr 逻辑分析</h3><p>分析计算 newCap 和 newThr 的两个分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个条件分支</span></span><br><span class="line"><span class="keyword">if</span> ( oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 嵌套条件分支</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;...&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个条件分支</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>分支一：</p><ul><li><p><code>oldCap &gt; 0</code>：桶数组 table 已经被初始化。</p><ul><li>oldCap &gt;= 2<sup>30</sup>：这时如果旧容量到达 MAXIMUM_CAPACITY(2<sup>30</sup>) ，则将阈值置为Integer.MAX_VALUE，即 2<sup>31</sup>-1，<strong>且这时不进行扩容，直接返回旧 table</strong>。</li><li><strong>newCap &lt; 2<sup>30</sup> &amp;&amp; oldCap &gt; 16</strong>：这时会先将 newCap x 2，若满足条件，将新阈值 newThr = oldThr &lt;&lt; 1，**这时若是传入的 loadFactor 的值（<code>HashMap(int, float) </code>构造方法）大于 8 且为 2 的幂次方，则此操作可能造成溢出，这时 newThr 为 0** 。<strong style="color:red">大多数情况下都是这种情况，即将容量扩大一倍</strong>。</li></ul></li><li><p><code>(oldCap==0 &amp;&amp;)oldThr &gt; 0</code>：threshold &gt; 0，且桶数组未被初始化</p><ul><li>调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，<strong>这种情况下 threshold 存的并不是阈值，而是暂存容量（<code>this.threshold = tableSizeFor(initialCapacity);</code>）</strong>，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出。</li></ul></li><li><p><code>oldCap == 0 &amp;&amp; oldThr == 0</code>：桶数组未被初始化，且 threshold 为 0</p><ul><li>调用 HashMap() 构造方法会产生这种情况。该构造方法中只是初始化了 loadFacotr 变量。这时使用默认值计算 newCap 和 newThr 。（即默认容量 16， 默认负载因子 0.75）</li></ul></li></ul><p>分支二：分支一中 oldCap &gt; 0 时 newThr 出现溢出，或 (oldCap==0 &amp;&amp;)oldThr &gt; 0时，newThr 会为 0，根据容量和装载因子计算。</p><h3 id="映射到新-table-链表"><a href="#映射到新-table-链表" class="headerlink" title="映射到新 table(链表)"></a>映射到新 table(链表)</h3><p>若旧 table 不为空，需要将键值对映射到新 table 中，对旧 table 进行遍历，若桶不为空，有 3 种情况：</p><ul><li>桶中只有一个元素，直接将该元素映射到新 table 。（<code>e.hash &amp; (newCap - 1)</code>）</li><li>桶类型是红黑树，则拆分红黑树。</li><li>桶类型是链表，遍历链表，<strong>并将链表节点按原顺序进行分组再映射到新 table，注意映射到新 table 后结点的相对顺序没变</strong>。</li></ul><p><strong>这里分析第 3 种情况</strong>。</p><p>往底层数据结构中插入节点时，一般都是先通过模运算计算桶位置，接着把节点放入桶中即可。事实上可以把重新映射看做插入操作。在 JDK 1.7 中，也确实是这样做的。<strong>但在 JDK 1.8 中，则对这个过程进行了一定的优化，逻辑上要稍微复杂一些</strong>。</p><p><strong>优化逻辑分析见参考链接</strong>。</p><p><strong>总的来说就是</strong>：</p><ul><li><strong style="color:red">若 <code>e.hash &amp; oldCap</code> 的值为 0 ，则 e 在新 table 的桶索引跟在旧 table 中的一样</strong>。</li><li><strong style="color:red">若不为 0 ，则在新 table 的桶索引为 <code>旧索引 + oldCap</code> </strong>。</li></ul><p><strong>这样就不用使用 <code>e.hash &amp; (newCap - 1)</code> 来计算桶索引，效率更高</strong>。</p><p><strong>resize 中根据这个逻辑把链表分成两个队列，将两个队列分别插入新 table 对应的桶</strong>。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">    <span class="comment">// 两个队列（链表）</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入 lo 队列</span></span><br><span class="line">            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则插入 hi 链队列</span></span><br><span class="line">            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 将整个 lo 链表插入到新 table 的 j 桶即可</span></span><br><span class="line">    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j] = loHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入到 j + oldCap 桶</span></span><br><span class="line">    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j + oldCap] = hiHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 1.8 版本下 HashMap 扩容效率要高于之前版本。比如相对于 JDK1.7 ，JDK 1.7 为了防止因 hash 碰撞引发的拒绝服务攻击，在<strong>计算 hash 过程中引入随机种子</strong>。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的 hash。而在 JDK 1.8 中，则通过引入红黑树替代了该种方式。从而避免了多次计算 hash 的操作，提高了扩容效率。</p><h2 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h2><p>树结点内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeNode 的继承关系是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode -&gt; LinkedHashMap.Entry -&gt; HashMap.Node -&gt; Map.Entry</span><br></pre></td></tr></table></figure><p>HashMap.Node 即链表类型结点。</p><h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><p>在将键值对插入链表后，会判断是否需要树化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====== putVal 中的代码片段</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 若 table 为空或长度不到 MIN_TREEIFY_CAPACITY，则优先扩容，不进行树化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// hd 为头节点（head），tl 为尾节点（tail）</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 按顺序将普通链表转成 树形节点链表（注意还不是红黑树）</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将普通节点替换成树形节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// p 接入尾部</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 先将树型链表赋值到 index 处的桶</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 将树形链表转换成红黑树</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>treeifyBin 中并不是直接将链表树化，<strong>要树化要满足两个条件</strong>：</p><ol><li>链表长度大于等于 TREEIFY_THRESHOLD（在 putVal 方法中判断）</li><li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY</li></ol><p><strong style="color:red">即链表长度到达 8 ，且桶数组容量大于等于 64 时才会进行树化，若只是链表长度到 8 ，则优先进行扩容</strong>。</p><p><strong>优先进行扩容的原因</strong>：（来自参考链接）</p><p>当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。<strong>毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程</strong>。同时，<strong>桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事</strong>。</p><p>另外，<strong>树化前会先将链表转为树型链表，TreeNode 继承自 Node 类，所以 TreeNode 仍然包含 next 引用，在这个过程中<font color="red">原链表的节点顺序最终通过 next 引用被保存下来</font></strong>。</p><p>树化的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（摘自参考链接）</p><p>HashMap 在设计之初，并没有考虑到以后会引入红黑树进行优化。所以并没有像 TreeMap 那样，要求键类实现 comparable 接口或提供相应的比较器。但由于<strong>树化过程需要比较两个键对象的大小</strong>，在键类没有实现 comparable 接口的情况下，怎么比较键与键之间的大小了就成了一个棘手的问题。为了解决这个问题，HashMap 是做了三步处理，确保可以比较出两个键的大小，如下：</p><ol><li>比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较</li><li>检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较</li><li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 （大家自己看源码吧）</li></ol><p><strong style="color:red">链表转成红黑树后，原链表的顺序通过 next 引用被保留了（红黑树的根节点会被移动到链表的第一位），仍然可以按遍历链表的方式去遍历上面的红黑树。这样的结构为后面红黑树的切分以及红黑树转成链表做好了铺垫</strong>。</p><h3 id="红黑树拆分"><a href="#红黑树拆分" class="headerlink" title="红黑树拆分"></a>红黑树拆分</h3><p>扩容后需要将旧 table 中的键值对映射到新 table，<strong>若是存在红黑树结点，需要进行拆分重新映射</strong>。</p><p>拆分红黑树按照一般思路，可以先将红黑树转换为链表，再将链表<strong>按 resize() 方法中分组的方式进行重新映射</strong>。<strong style="color:red">由上已知红黑树中通过 next 引用仍然保留着原来链表的顺序，所以对红黑树进行重新映射时，直接按照映射链表的方式进行即可</strong>，不用先转换为链表，无形中提高了效率。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// == resize() 中代码片段</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"><span class="comment">// ==================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 tab 是 newTab </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 两个队列</span></span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。</span></span><br><span class="line"><span class="comment">     * 下面的循环是对红黑树节点进行分组，与 resize 中类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 loHead 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 链表长度小于等于 6(UNTREEIFY_THRESHOLD)，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 否则需要树化</span></span><br><span class="line"><span class="comment">             * hiHead == null 时，表明扩容后，</span></span><br><span class="line"><span class="comment">             * 所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新映射红黑树<strong>逻辑总结</strong>：</p><ul><li>与映射链表的逻辑基本一致（红黑树中保存了原链表的顺序）</li><li>不同的地方在于，重新映射后，<strong>会将红黑树拆分成两条由 TreeNode 组成的链表</strong>。<strong>这时若是链表的长度小于等于UNTREEIFY_THRESHOLD，则需要将 TreeNode 链表转换为 Node 链表</strong>（见下一小节）。</li><li><strong>否则根据条件还需要将 TreeNode 链表树化</strong>。</li></ul><p>也就是说，<strong>红黑树拆分是<font color="red">先将树拆成两个链</font>，再根据条件判断是否需要树化</strong>。</p><h3 id="红黑树链化"><a href="#红黑树链化" class="headerlink" title="红黑树链化"></a>红黑树链化</h3><p>红黑树链化的方法是 <code>untreeify()</code> ，<strong>因为红黑树中仍然保留了原链表节点顺序，所以只需将 TreeNode 结点转换为 Node 结点即可</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历 TreeNode 链表，并用 Node 替换</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// 替换节点类型</span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchValue 表示是否 value 相同才删除，若是使用 remove(key) 方法时，是要删除指定 key 的键值对，所以</span></span><br><span class="line"><span class="comment">// matchValue 指定为 false；若是使用 remove(key, value)，则指定为 true（需要同时匹配 value）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 定位桶位置</span></span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果 key 与第一个结点相同，将 node 指向第一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是 TreeNode 类型，调用红黑树的查找逻辑定位待删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链表，则遍历找到指定 key</span></span><br><span class="line">            <span class="comment">// 找到结点时，node 指向待删除结点， p 指向 node 的前驱结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除结点（若找不到则 node 为 null）</span></span><br><span class="line">        <span class="comment">// 对于 remove(key,value) 方法，matchValue 为 true，所以需要匹配 value 值</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 删除树结点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// node 是桶的第一个结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// node 指向待删除结点， p 指向 node 的前驱结点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transient-table"><a href="#transient-table" class="headerlink" title="transient table"></a>transient table</h2><p><a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#%E8%A2%AB-transient-%E6%89%80%E4%BF%AE%E9%A5%B0-table-%E5%8F%98%E9%87%8F"> 被 transient 所修饰 table 变量</a> </p><p>HashMap 中 table 数组被 transient 修饰，表示 table 不会被默认的序列化机制序列化。HashMap 通过实现<code>readObject/writeObject</code>两个方法自定义了序列化的内容。</p><p>为什么不直接将整个 table 序列化即可？</p><ol><li><strong>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</strong>。</li><li><strong style="color:red">同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误</strong>。<ul><li>HashMap 的 <code>get/put/remove</code> 等方法第一步就是根据 hash 找到键所在的桶位置，<strong>但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的</strong>。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</li></ul></li></ol><h2 id="与-JDK1-7-的主要区别"><a href="#与-JDK1-7-的主要区别" class="headerlink" title="与 JDK1.7 的主要区别"></a>与 JDK1.7 的主要区别</h2><h3 id="链表-amp-红黑树"><a href="#链表-amp-红黑树" class="headerlink" title="链表&amp;红黑树"></a>链表&amp;红黑树</h3><p>JDK1.8 的 HashMap 相比于 JDK1.7，最大的区别肯定是红黑树优化，<strong>在插入元素后，若链表的长度大于阈值且数组长度大于 64 时会将链表树化</strong>。（数组长度不够则优先扩容）</p><p>JDK1.7 插入新结点时使用的是头插法，而 JDK1.8 则是插入到链表尾部。</p><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>JDK1.7 计算元素在新 table 中的索引时都是使用 hash 对长度取模的原始方式；JDK1.8 中则进行了优化，使用链表分组的方式（具体见上文），避免了多次重新计算 hash 值。</p><p>扩容后将旧 table 的元素转移到新 table 时，JDK1.7 依旧是使用头插法，所以一个链表上的元素的相对顺序会颠倒。而 JDK1.8 因为链表分组的方式保存了原来的顺序。（<strong>有啥用勒？</strong>）</p><p>JDK1.8 的扩容逻辑相对较复杂，计算 newThr 和 newCap 时兼顾了 table 未初始化的情况；且转移元素时需要针对链表和红黑树作不同的处理。</p><h3 id="计算hash"><a href="#计算hash" class="headerlink" title="计算hash"></a>计算hash</h3><p>JDK1.7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，且相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>（摘自参考连接）</p><p><strong>JDK 1.7 为了防止因 hash 碰撞引发的拒绝服务攻击，在计算 hash 过程中引入随机种子。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的 hash。而在 JDK 1.8 中，则通过引入红黑树替代了该种方式。从而避免了多次计算 hash 的操作，提高了扩容效率</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>主要参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/">HashMap 源码详细分析(JDK1.8) - 田小波</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap(JDK1.8)%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">JavaGuide - HashMap底层分析</a>  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;HashMap 最早出现在 JDK1.2 ，底层基于哈希表实现，&lt;strong&gt;JDK1.8 之前处理哈希碰撞使用的是拉链法，在 JDK1.</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>包装类总结</title>
    <link href="http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-16T08:37:06.898Z</published>
    <updated>2021-03-20T06:05:44.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java<strong>中</strong>有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型 ：byte、short、int、long、float、double</li><li>1 种字符类型：char</li><li>1 种布尔型：boolean。</li></ul><p>它们占的字节大小：</p><table><thead><tr><th>基本类型</th><th>字节</th></tr></thead><tbody><tr><td>int</td><td>4</td></tr><tr><td>short</td><td>2</td></tr><tr><td>long</td><td>8</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>char</td><td>2</td></tr><tr><td>float</td><td>4</td></tr><tr><td>double</td><td>8</td></tr><tr><td>boolean</td><td></td></tr></tbody></table><p><strong>对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素</strong>。</p><p>&emsp;&emsp;</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>八种基本类型都有对应的包装类分别为：<strong>Byte、Short、Integer、Long、Float、Double、Character、Boolean</strong>。</p><h3 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h3><p>Java 是号称面向对象的语言，所有的类型都是引用类型。但是基本类型如 int 等不是引用类型，也不是继承自 Object，<strong>所以 Java 需要一个这样的包装类来使其具有对象的特性： 比如可以赋值为 null；且Java 集合中也只能放入包装类型，而不支持基本类型；可以创建一些特定的方法等</strong>。</p><p>&emsp;&emsp;</p><h3 id="自动装箱-自动拆箱及其原理"><a href="#自动装箱-自动拆箱及其原理" class="headerlink" title="自动装箱/自动拆箱及其原理"></a>自动装箱/自动拆箱及其原理</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来（转换为对应的包装类）；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>自动装箱/自动拆箱是如何实现的？</p><p>编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">2</span>;<span class="comment">// 装箱</span></span><br><span class="line">        <span class="keyword">int</span> b = a;<span class="comment">// 拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>javap -verbose</code> 指令，查看 main 方法的反编译字节码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> main(java.lang.String[]);</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_2</span><br><span class="line">        <span class="number">1</span>: invokestatic  #<span class="number">2</span>   <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">4</span>: astore_1</span><br><span class="line">        <span class="number">5</span>: aload_1</span><br><span class="line">        <span class="number">6</span>: invokevirtual #<span class="number">3</span>   <span class="comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">        <span class="number">9</span>: istore_2</span><br><span class="line">       <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong style="color:red">可以看到，自动装箱实际上是调用对应包装类的 <code>static valueOf()</code> 方法；而对于自动拆箱，调用的是包装类对象的 <code>xxxValue()</code> ，其中，xxx代表对应的基本数据类型</strong>。 </p><p>&emsp;&emsp;</p><p>Integer 中的这两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean 中，<font color="red">前面 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True Or False</font>。如果超出对应范围仍然会去创建新的对象</strong>。 </p><p><strong style="color:red">对以上包装类调用 <code>valueOf()</code> 方法会首先尝试从 cache 中获取值，若不能命中，则使用 new 创建对象</strong> 。</p><p>如上面所示 Integer 的 <code>valueOf()</code> 方法中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br></pre></td></tr></table></figure><p>其中 cache 的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br></pre></td></tr></table></figure><p>其在 static 静态块中被初始化（摘取部分代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> j = low;<span class="comment">// low 为 -128</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">    cache[k] = <span class="keyword">new</span> Integer(j++);</span><br></pre></td></tr></table></figure><p>对于 Byte,Short,Long,Character 类似。</p><p><strong>对于 Double、Float 的 <code>valueOf()</code> 则是直接使用 new 创建对象返回</strong>。</p><p>&emsp;&emsp;</p><p>一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6)); <span class="comment">//true   </span></span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Double d1 = <span class="number">1.2</span>;</span><br><span class="line">Double d2 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(d1 == d2);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p><strong style="color:red">使用 <code>==</code> 比较时要注意的点</strong>：</p><ul><li><strong>当 “==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象</strong>；</li><li>如果其中有一个操作数是表达式（<strong>即包含算术运算</strong>）或有一边是基本类型，则比较的是数值（<strong>即会触发自动拆箱的过程</strong>）。<strong>例如对于 i4 == i5 + i6，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40，再将 i4 拆箱，即 <code>40==40</code> </strong>。</li></ul><p>&emsp;&emsp;</p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h3><p>所有包装类（<strong>注意是所有</strong>）的 <code>equals()</code> 方法在进行比较时，<strong>都是先判断参数值是不是当前包装类类型</strong>，</p><ul><li><strong>若不是直接返回 false</strong>。</li><li><strong>若是，则比较两者中封装的 value 成员变量值是否相等</strong>。</li></ul><p>例如对于 Integer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Integer i = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(g.equals(i));<span class="comment">// false ，g 和 i 的类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:red">若是 equlas 传入的参数是基本类型，则会转换为对应的包装类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(g.equals(a+b));<span class="comment">// false</span></span><br><span class="line">    System.out.println(g.equals(<span class="number">3</span>));<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_13-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">javaGuide</a> </p><p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析Java中的装箱和拆箱</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;p&gt;Java&lt;strong&gt;中&lt;/strong&gt;有 8 种基本数据类型，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;6 </summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>总结 equals 和 hashCode</title>
    <link href="http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/equals%E5%92%8ChashCode/"/>
    <id>http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/equals%E5%92%8ChashCode/</id>
    <published>2021-03-16T03:26:05.349Z</published>
    <updated>2021-03-20T12:06:15.135Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是总结自： <a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a>  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>hashCode()</code> 的作用是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。</p><blockquote><p><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code> ，则一个 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><p>&emsp;&emsp;</p><p><strong>该方法主要是为了支持如 HashSet 、 HashMap 等基于哈希表实现的集合</strong>。</p><p> 也就是说：<strong>hashCode() 在散列表中才有用，在其它情况下没用。</strong>在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><p>讨论 equals() 和 hashCode() 的关系应该分两种情况进行：</p><h2 id="不会创建“类对应的散列表”"><a href="#不会创建“类对应的散列表”" class="headerlink" title="不会创建“类对应的散列表”"></a>不会创建“类对应的散列表”</h2><p><strong>第一种是不会在 HashSet, Hashtable, HashMap 等基于哈希表实现的数据结构中用到该类</strong>，<strong style="color:red">这种情况下 equals() 和 hashCode() 没有关系，如果要比较对象，只需使用 equals() 来进行比较，而并不需要用到 hashCode() </strong>，**所以重写 equals() 时不需要重写 hashCode()**。</p><p>比如只是要比较两个 Person 对象的 name 是否相同，但没有要将其放到 HashSet 等集合，只需重写 equals() 即可，如：</p><p>（来自参考链接）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否类型相同  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    Person person = (Person)obj;  </span><br><span class="line">    <span class="keyword">return</span> name.equals(person.name);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h2 id="会创建“类对应的散列表”"><a href="#会创建“类对应的散列表”" class="headerlink" title="会创建“类对应的散列表”"></a>会创建“类对应的散列表”</h2><p><strong>第二种情况则是会在 HashSet, Hashtable, HashMap 等基于哈希表实现的数据结构中用到该类</strong>。</p><p>这时需要注意两者的关系：</p><ul><li><p><strong>若是两个对象使用 equals() 比较返回 true，那么使用 hashCode() 应该返回相同的哈希值。否则会出现 “ 两个对象是相同的(equals 返回 true)，但却可以放进同一个哈希表 ”  的情况</strong>。</p><blockquote><p>hashCode() 的 javaDoc ：If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</p></blockquote></li><li><p><strong style="color:red">但如果使用 equals() 比较返回 false ，并不要求 hashCode() 返回不同的值</strong>。因为在哈希表中，即使两个哈希值相同（两个 key 相同），它们的值不一定相同（value 不一定相同），这种情况即哈希碰撞。</p><blockquote><p>hashCode() 的 javaDoc ：It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results</p></blockquote><p>一个要注意的点是：<strong>在 HashSet 、 HashMap 等基于哈希表的集合中，若是两个对象使用 equals() 比较返回 false，但 hashCode() 返回相同的值（即产生哈希碰撞时），还是会将两个对象都放进集合（这时会使用哈希碰撞解决方法，如拉链法，红黑树等）</strong>。</p></li></ul><p>&emsp;&emsp;</p><p><strong>所以若是要在哈希表实现的数据结构中使用到某个类，则需要重写这个类的 equals() 和 hashCode() ，并保证它们满足上述关系</strong>。</p><p>示例：（来自参考链接）</p><p>定义 Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; - &quot;</span> +age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象的 name 的大写相同且年龄相同时，返回相同的哈希值</span></span><br><span class="line">        <span class="keyword">int</span> nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">        <span class="keyword">return</span> nameHash ^ age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一个对象返回true，反之返回false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否类型相同</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// name 相同（区分大小写）且年龄相同返回 true </span></span><br><span class="line">        Person person = (Person)obj;</span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建Person对象，</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line">    Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;EEE&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建HashSet对象</span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    set.add(p3);</span><br><span class="line">    set.add(p4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, </span><br><span class="line">                      p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">    <span class="comment">// 比较p1 和 p4， 并打印它们的hashCode()</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;</span>, </span><br><span class="line">                      p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">    <span class="comment">// p1.equals(p2) : true; p1(68545) p2(68545)</span></span><br><span class="line"><span class="comment">// p1.equals(p4) : false; p1(68545) p4(68545)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印set，可以看到 p1 p4 equals返回 false，但 hashcode 相同，所以都被放进集合</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;set:%s\n&quot;</span>, set);</span><br><span class="line">    <span class="comment">// set:[eee - 100, EEE - 100, aaa - 200]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不重写 hashCode() ，那么 p1、p2 都可以被放进 set 。</p><p>&emsp;&emsp;</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_129-hashcode%e4%b8%8e-equals">hashCode() 与 equals()</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章主要是总结自： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3324958.html&quot;&gt;Java hashCode() 和 equals()的若干问题解答&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://example.com/2021/03/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/"/>
    <id>http://example.com/2021/03/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/</id>
    <published>2021-03-10T16:35:28.790Z</published>
    <updated>2021-04-17T06:23:08.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="i-i–同步问题"><a href="#i-i–同步问题" class="headerlink" title="i++,i–同步问题"></a>i++,i–同步问题</h2><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123; counter++;</span><br><span class="line">    &#125; &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123; counter--;</span><br><span class="line">    &#125; &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两个线程执行完后，结果是不确定的</strong>。</p><p><strong><font color="red">因为 Java 中对静态变量的自增，自减并不是原子操作</font></strong>，假设 i 为静态变量，i++，i– 的字节码如下：</p><p><code>i++</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic<span class="regexp">//</span>获取静态变量</span><br><span class="line">iconst_1<span class="regexp">//</span>准备常量<span class="number">1</span></span><br><span class="line">iadd<span class="regexp">//</span>加操作</span><br><span class="line">putstatic <span class="regexp">//</span>将修改后的值存入静态变量</span><br></pre></td></tr></table></figure><p><code>i--</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic<span class="regexp">//</span>获取静态变量</span><br><span class="line">iconst_1<span class="regexp">//</span>准备常量<span class="number">1</span></span><br><span class="line">isub<span class="regexp">//</span>减操作</span><br><span class="line">putstatic <span class="regexp">//</span>将修改后的值存入静态变量</span><br></pre></td></tr></table></figure><p><strong>两个操作都需要先通过 getstatic 获取值，若一个操作没有等另一个操作完成，则其中一个 putstatic 必定会覆盖掉另一个，不能保证结果为 0 ，会造成丢失修改</strong>。</p><h2 id="synchronized-的内存语义"><a href="#synchronized-的内存语义" class="headerlink" title="synchronized 的内存语义"></a>synchronized 的内存语义</h2><p>synchronized 的这个内存语义就可以解决共享变量内存可见性问题。</p><p>进入和退出 synchronized 块的语义：</p><ul><li><p><strong>进入 synchronized 块</strong>的内存语义是<strong>把在 synchronized 块内使用到的变量从线程的工作内存中清除</strong>， 这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取， 而是直接从主内存中获取。</p></li><li><p><strong>退出 synchronized 块</strong>的内存语义是<strong>把在 synchronized 块内对共享变量的修改刷新到主内存</strong>。</p></li></ul><p><strong>这也是加锁和释放锁的语义</strong>，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁时将本地内存中修改的共享变量刷新到主内存。</p><p>除可以解决共享变量内存可见性问题外， synchronized 经常被用来实现原子性操作。另外要注意，<strong>synchronized关键字会引起线程上下文切换并带来线程调度开销</strong>。</p><h2 id="synchronized-的使用"><a href="#synchronized-的使用" class="headerlink" title="synchronized 的使用"></a>synchronized 的使用</h2><blockquote><p><strong>临界区</strong>指的是一个访问共用资源的程序片段，而这些共用资源又无法同时被多个线程线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待。</p><p>竞态条件（Race Condition）：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件。</p></blockquote><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，它是一种互斥锁，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</p><p>下面是 synchronized 的 3 种使用方式。</p><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;  <span class="comment">//obj为要锁定的资源（对象）</span></span><br><span class="line">    ---<span class="comment">//同步代码块（临界区）  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入临界区需要获取指定对象的锁</strong>。</p><h3 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h3><p><strong>上锁的对象是方法所在对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入临界区需要获取方法所属对象的锁</strong>。</p><h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入临界区需要获取当前类的 class 对象的锁</strong>。</p><blockquote><p>synchronized可以修饰方法、代码块，不能修饰构造器、成员变量。</p></blockquote><p>示例，对上述i++，i–问题：多次执行，可保证结果为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.SimpleDemo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从字节码看-synchronized"><a href="#从字节码看-synchronized" class="headerlink" title="从字节码看 synchronized"></a>从字节码看 synchronized</h2><h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><p>Test类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该类的class文件执行 <code>javap -c</code> （或 <code>javap -verbose</code> ）指令，得到反编译的指令码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   Code:</span><br><span class="line">      0: getstatic     #2                  // （lock引用）进入临界区</span><br><span class="line">      <span class="number">3</span>: dup<span class="comment">// </span></span><br><span class="line">      <span class="number">4</span>: astore_1</span><br><span class="line">      <span class="number">5</span>: monitorenter<span class="comment">// 将lock对象的 MarkWord 置为Monitor指针</span></span><br><span class="line">      6: getstatic     #3                  // Field counter:I</span><br><span class="line">      <span class="number">9</span>: iconst_1</span><br><span class="line">     <span class="number">10</span>: iadd</span><br><span class="line">     11: putstatic     #3                  // Field counter:I</span><br><span class="line">     <span class="number">14</span>: aload_1</span><br><span class="line">     <span class="number">15</span>: monitorexit<span class="comment">// 将lock对象的 MarkWord 重置，唤醒EntryList</span></span><br><span class="line">     <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">     <span class="number">19</span>: astore_2<span class="comment">// 19-23为异常处理指令</span></span><br><span class="line">     <span class="number">20</span>: aload_1</span><br><span class="line">     <span class="number">21</span>: monitorexit <span class="comment">// ----!-----</span></span><br><span class="line">     <span class="number">22</span>: aload_2</span><br><span class="line">     <span class="number">23</span>: athrow</span><br><span class="line">     <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">   Exception table: <span class="comment">//异常表</span></span><br><span class="line">      from    to  target type</span><br><span class="line">          <span class="number">6</span>    <span class="number">16</span>    <span class="number">19</span>   any <span class="comment">// 6-16行的指令发生异常时，调用19行的指令处理异常</span></span><br><span class="line">         <span class="number">19</span>    <span class="number">22</span>    <span class="number">19</span>   any</span><br></pre></td></tr></table></figure><p>monitorenter 和 monitorexit 指令的文档介绍：</p><p><strong>monitorenter</strong> </p><blockquote><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes </p><p>monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p><blockquote><p>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</p><p>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</p><p>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p></blockquote></blockquote><p><strong>monitorexit</strong> </p><blockquote><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</p><p>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></blockquote><p><strong>每个对象都关联一个 monitor ，当且仅当一个 monitor 拥有一个所有者时它是被锁住的（即某个线程获取到了该 monitor 锁）。执行 monitorenter 的线程会尝试获得与 objectref 关联的 monitor 的所有权。执行 monitorexit 指令的线程必须是 objectref 关联的 monitor 的所有者</strong>。</p><p>synchronized 修饰的代码块对应的字节码指令在一对 monitorenter/monitorexit 之间，monitorenter 表示线程对 monitor 对象加锁，monitorexit 则表示释放锁。</p><p>每个 monitor 会有一个 entry count，当该值为 0 ，线程可以获取到锁，若获取成功，则将 count 加 1，成为 monitor 的所有者。若是线程再次获取锁（重入），将 count 自增。</p><p>当线程释放锁时，count 减一，若为 0 ，表示锁被释放，其他线程可以竞争该锁。</p><p>另外，还会<strong>对应有一个异常表，用于当执行临界区代码发生异常时，可以保证锁的释放</strong>（<strong>异常处理指令中有 monitorexit 指令</strong>）。</p><h3 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h3><p>对于 synchronized 方法（包括实例方法和静态方法），其方法字节码中没有 monitorenter 和 monitorexit ，而是使用一个方法标志位： <code>0x0020</code> ，对应 <code>ACC_SYNCHRONIZED</code> 。<strong>JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</strong>。</p><p>例如对于方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Test.info&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其访问标志：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210312193230918.png" alt="image-20210312193230918"></p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>Monitor，又叫管程，监视器。是操作系统的一个概念，其具体含义：</p><blockquote><p>可以利用共享数据构抽象地表示系统中的共享资源并且将对该共享数据结构实施的特定操作定义为一组过程。进程对共享资源的申请、释放和其它操作<strong>必须通过这组过程接地对共享数据结构实现操作</strong>。</p><p>代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，称之为管程。<strong>管程被请求和释放资源的进程所调用</strong>。</p><p><strong>管程相比于信号量等机制，把共享资源的操作统一了起来，更方便管理</strong>。</p></blockquote><p>JVM 中也实现了管程机制。</p><p>使用 synchronized 时，<strong style="color:red">所谓对指定对象上锁实际上是获取该对象对应的 monitor 对象的所有权</strong>。由上文 monitorenter 的文档已知 JVM 中<strong>每个对象会关联一个 monitor 对象</strong>。<strong>当要执行 synchronized 中的代码时，必须先获取 monitor 对象所有权，否则线程被阻塞，直到拥有 monitor 锁的线程释放锁再重新竞争</strong>。</p><p>Hotspot 虚拟机中，monitor 是基于 C++ 实现，<strong>具体的对象是 ObjectMonitor</strong>，其数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL;</span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;</span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<strong>几个关键属性</strong>：</p><ul><li><code>_owner</code>：指向持有 ObjectMonitor 对象的线程。</li><li><code>_WaitSet</code>：处于 wait 状态的线程队列。</li><li><code>_EntryList</code>：处于等待锁 block 状态的线程队列（<strong>竞争不到锁</strong>）。</li><li><code>_count</code>：用来记录该线程获取锁的次数。</li></ul><p>当多个线程同时访问一段同步代码时（<strong>monitorenter</strong>），首先会进入 <code>_EntryList</code> 队列中进行竞争，<strong>竞争成功的线程将 monitor 的 <code>_owner</code> 指向当前线程，同时 <code>_count</code> 变量加 1 。即当前线程获得了对象锁。其他获取不到锁的线程阻塞在 <code>_EntryList</code> 队列</strong>。</p><p><strong>当线程执行完同步代码块并释放锁时（monitorexit），<code>_owner</code> 置为 null，<code>_count</code> 减 1， <code>_EntryList</code> 队列中的线程重新竞争锁</strong>。若是持有 monitor 的线程调用了 <code>wait()</code> 方法（monitor 对应的对象的 wait 方法），则线程释放锁（同样是<code>_owner</code> 置为 null，<code>_count</code> 减 1），并<strong>进入 <code>_WaitSet</code> 队列</strong>，且同样 <code>_EntryList</code> 队列中的线程竞争锁。</p><p><strong>当执行 monitorenter 指令时，实际上是调用 ObjectMonitor 对象的 <code>enter</code> 方法，执行 monitorexit 指令则是调用 <code>exit</code> 方法</strong>。只有在 JDK1.6 之前， <code>synchronized</code> 的实现才会直接调用 <code>enter</code> 和 <code>exit</code>，这种锁被称之为<strong>重量级锁</strong>。JDK 1.6 及之后对 synchronized 进行了优化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://concurrent.redspider.group/article/02/9.html#922-%E5%81%8F%E5%90%91%E9%94%81">synchronized与锁</a> </p><p><a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6 及以上版本对 synchronized 的优化</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">Java并发进阶常见面试题总结</a> </p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650120526&idx=1&sn=21b590e05c72e50167b07c777a7c190a&chksm=f36bbc6fc41c3579275ff8d8ab55585e25f6e5bc94e886089811a108ea2c0a4c27131cd4de7a&scene=21#wechat_redirect">[译]Java虚拟机是如何执行线程同步的</a> </p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650120537&idx=1&sn=f56201217c0ca6fde45ee12965b56296&chksm=f36bbc78c41c356ee363367addcdc0b311afb2f9df86a7ee20d21348b3332fd64f273d6028ca&scene=21#wechat_redirect">Synchronized的实现原理（一）</a> </p><p><a href="https://juejin.cn/post/6844903566822342663">Moniter的实现原理</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;i-i–同步问题&quot;&gt;&lt;a href=&quot;#i-i–同步问题&quot; class=&quot;headerlink&quot; title=&quot;i++,i–同步问题&quot;&gt;&lt;/a&gt;i++,i–同步问题&lt;/h2&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="多线程" scheme="http://example.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java并发" scheme="http://example.com/Tag/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="http://example.com/2021/03/11/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/03/11/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-10T16:33:27.913Z</published>
    <updated>2021-03-10T16:31:11.780Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​        运输层的任务就是<strong>负责向两台主机中进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。由于一台主机可同时运行多个进程，因此运输层有<strong>复用和分用</strong>的功能。<strong>复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程</strong>（<strong>把信息传上去</strong>）。</p><p>​        运输层主要使用以下两种协议：</p><ul><li><strong>传输控制协议TCP</strong>（Transmission Control Protocol） 提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>（segment）。</li><li><strong>用户数据报协议UDP</strong>（User Datagram Protocol）提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是<strong>用户数据报</strong>。</li></ul><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><h3 id="为什么需要运输层"><a href="#为什么需要运输层" class="headerlink" title="为什么需要运输层"></a>为什么需要运输层</h3><p><strong>IP层的IP地址只是标识了两台主机，只能实现两个主机间的通信，而真正进行通信的是两个主机中的实体（进程），运输层通过端口来标识主机中的进程，实现进程间的通信</strong>。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP，User Datagram Protocol，用户数据报协议。</p><p><strong>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能， 这就是复用分用的功能以及差错检测的功能</strong>。UDP的主要特点是：</p><ul><li><strong>无连接</strong>。即发送数据之前不用建立连接。</li><li>UDP使用<strong>尽最大努力交付</strong>。</li><li>UDP是<strong>面向报文</strong>的。即应用层交下来的报文，UDP既不合并，也不拆分，只加上UDP首部后直接发送；相应的，接收时去除首部后直接上交应用层。</li><li><strong>没有拥塞控制</strong>。即网络的拥塞不会使源主机发送速率降低。但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信）</li><li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li>首部开销小，8B。</li></ul><h3 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h3><p>TCP，Transmission Control Protocol，传输控制协议。</p><p>TCP的主要特点：</p><ul><li><strong>面向连接</strong>。即使用tcp之前（通信之前）需要建立可靠连接，通信完毕后释放连接。</li><li>每一个TCP连接<strong>只能有两个端点</strong>。<ul><li>TCP连接的端点叫做<strong>套接字（socket）</strong>，一个套接字<strong>由<code>IP地址:端口号</code>组成</strong>。<strong>一个TCP连接由两个套接字唯一确定</strong>。</li></ul></li><li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据， <strong>无差错、不丢失、不重复，并且按序到达</strong>。</li><li>TCP提供<strong>全双工通信</strong>。TCP允许<strong>通信双方的应用进程在任何时候都能发送数据</strong>。<ul><li><strong style="color:red">TCP连接的两端都设有发送缓存和接收缓存， 用来临时存放双向通信的数据</strong>。<strong>在发送时，应用程序在把数据传送给TCP的缓存后， 就可以做自己的事， 而TCP在合适的时候把数据发送出去。在接收时， TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</strong>。</li></ul></li><li><strong>面向字节流</strong>。<strong style="color:red">TCP中的“流”(stream) 指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块(<strong>大小不等</strong>) ， 但TCP把应用程序交下来的数据<strong>仅仅看成是一连串的无结构的字节流</strong>。TCP并不知道所传送的字节流的含义。TCP<strong>不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</strong>。<strong>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</strong>。</li></ul><h3 id="TCP可靠传输原理"><a href="#TCP可靠传输原理" class="headerlink" title="TCP可靠传输原理"></a>TCP可靠传输原理</h3><p>（来自JavaGuide）</p><p>概述：</p><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待协议的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组</strong>。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 简单</li><li><strong>缺点：</strong> 信道利用率低，等待时间长</li></ul><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就<strong>重传前面发送过的分组</strong>（认为刚才发送过的分组丢失了）。因此<strong>每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些</strong>。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。</p><p><strong>若收到重复分组，就丢弃该分组，但同时还要发送确认</strong>。<strong>连续 ARQ 协议</strong> 可提高信道利用率。</p><p><strong>3) 确认丢失和确认迟到</strong>                   </p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下<strong>两点措施</strong>：<strong>1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。</strong> </li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。<strong>处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1</strong>。</li></ul><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。<strong>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</strong>。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> <strong>不能向发送方反映出接收方已经正确收到的所有分组的信息</strong>。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul><h4 id="滑动窗口实现流量控制"><a href="#滑动窗口实现流量控制" class="headerlink" title="滑动窗口实现流量控制"></a>滑动窗口实现流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率</strong>。将窗口字段设置为 0，则发送方不能发送数据。</p><p>​    </p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫<strong>拥塞</strong>。<strong>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载</strong>。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><blockquote><p>cwnd指拥塞窗口长度</p></blockquote><ul><li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是<strong>先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。<strong>每当出现超时的时候重新开始发送时即使用慢开始</strong>。</p></li><li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是<strong>让拥塞窗口cwnd缓慢增大</strong>，即每经过一个往返时间RTT就把发送放的cwnd加1。</p></li><li><p><strong>快重传与快恢复（fast retransmit and recovery，FRR）</strong>：采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。<strong>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认（这里已收到的报文段是指失序段之前的报文段）</strong>。</p><p>如图（来自《计算机网络》所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3；但却收到了M4。本来接收方可以什么都不做。<strong>但按照快重传算法，接收方必须立即发送对M2的重复确认（注意是M2）</strong>，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送Ms和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M的确认，其中后3个都是重复确认。<strong>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞</strong>。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210307172719911.png" alt="image-20210307172719911"></p><p>相应的，<strong>发送方知道只是丢失个别报文段，重新发送数据时不会启动慢开始，而是执行快恢复算法，即适当调整cwnd大小</strong>（如除以2），并执行拥塞避免。</p></li></ul><h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308171503072.png" alt="image-20210308171503072"></p><p>其中部分字段含义：</p><ul><li>序号（seq）。TCP 是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。<strong>序号字段值指的是本报文段所发送的数据的第一个字节的序号</strong>。</li><li>确认号（ack）。<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为 N ，则标识序号 1 ~ N-1 的字节都已正确收到。</li><li>确认 ACK （控制位） 。<strong>仅当ACK=1时确认号字段才有效</strong>。当ACK=0时， 确认号无效。TCP规定，<strong>在连接建立后所有传送的报文段都必须把ACK置1</strong>。</li><li>同步 SYN （控制位）。<strong>在连接建立时用来同步序号</strong>。<strong>当SYN=1而ACK=0时，表明这是一个连接请求报文段</strong>。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此， <strong>SYN置为1就表示这是一个连接请求或连接接受报文</strong>。</li><li>终止 FIN （控制位）。用来释放一个连接。<strong>当FIN=1时， 表明此报文段的发送方的数据已发送完毕，并要求释放运输连接</strong>。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>《计算机网络 第7版》中称为“三报文握手”。</p><p>图片来自《计算机网络 第7版》</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308162534931.png" alt="image-20210308162534931"></p><p> A 为客户端，B 为服务器端。</p><blockquote><p>ack 指确认号字段，ACK 是6个控制位之一。</p></blockquote><ul><li><strong>首先 B 处于 LISTEN（监听）状态</strong>，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，（同步字段）SYN=1，（ACK=0），<strong>选择一个初始的序号 x</strong>，即 <code>SYN=1, seq=x</code> 。</li><li>B 收到连接请求报文，<strong>如果同意建立连接，则向 A 发送连接确认报文</strong>，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。即 <code>SYN=1, ACK=1, seq=y, ack=x+1</code> 。</li><li><strong>A 收到 B 的连接确认报文后，还要向 B 发出确认</strong>，确认号为 y+1，序号为 x+1。即 <code>ACK=1, ack=y+1, seq=x+1</code> 。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong style="color:red">为什么需要最后一次握手（确认）？</strong> </p><p><strong>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</strong>。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，<strong>如果不进行三次握手</strong>，那么服务器就会打开两个连接。<strong>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，服务器接不到确认也就不会打开连接</strong>。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="E:\TyporaImage\image-20210308164017342.png" alt="image-20210308164017342"></p><ul><li>A 发送连接释放报文，FIN=1，并停止发送数据。 <code>FIN=1, seq=u</code> 。<strong>A进入“终止等待状态1”</strong>。</li><li>B 收到之后发出确认：<code>ACK=1, ack=u+1, seq=v</code> 。<strong>此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</strong>，即从 A -》B 这个方向的连接释放了。<strong>此时 B 进入“关闭等待”状态</strong></li><li>A收到确认后，<strong>进入“终止等待状态2”。等待B的连接释放报文段</strong>。</li><li><strong>B 发出确认后会发送还没发送完的数据</strong>，当 B 已经没有要向 A 发送的数据时，<strong>发送连接释放报文，FIN=1</strong>。 <code>FIN=1, ACK=1, seq=w, ack=u+1</code> 。<strong>B 进入“最后确认”状态</strong>。</li><li>A 收到后发出确认： <code>ACK=1, seq=u+1, ack=w+1</code> ，<strong>进入 TIME-WAIT （时间等待）状态，此时连接还没有释放，A 会等待 2 MSL（Maximum Segment Lifetime，最大报文存活时间）后释放连接</strong>。</li><li><strong>B 收到 A 的确认后释放连接</strong>。</li></ul><p>客户端接收到服务器端的 FIN 报文后还需要等待一个时间计时器设置的时间 2MSL。<strong>这么做有两个理由</strong>：</p><ul><li><strong>确保最后一个确认报文能够到达</strong>。如果 B 没收到 A 发送来的确认报文，会超时重传连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生，这时 A 会重新发送确认报文，<strong>并将计时重新设置为 2 MSL</strong>。</li><li>等待一段时间是为了<strong>让本连接持续时间内所产生的所有报文都从网络中消失使得下一个新的连接不会出现旧的连接请求报文，如已失效的连接请求报文段</strong>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html">运输层</a> </p><p>《计算机网络 第7版》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&lt;/p&gt;
&lt;h2 id=&quot;运输层&quot;&gt;&lt;a href=&quot;#运输层&quot; class=&quot;headerlink&quot; title=&quot;运输层&quot;&gt;&lt;/a&gt;运输层&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/Tag/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://example.com/2021/03/05/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(to%20be..)/"/>
    <id>http://example.com/2021/03/05/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(to%20be..)/</id>
    <published>2021-03-05T06:25:56.673Z</published>
    <updated>2021-03-20T12:07:13.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="class文件结构概述"><a href="#class文件结构概述" class="headerlink" title="class文件结构概述"></a>class文件结构概述</h2><p><strong>Class文件是一组<font color="red">以字节为基础单位</font>的二进制流， 各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</strong>，当遇到需要占用单个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个字节进行存储。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，<strong>这种伪结构中只有两种数据类型</strong>：<strong>“无符号数”和“表”</strong>。</p><ul><li>无符号数属于基本的数据类型，以<strong><font color="red">ul、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数</font></strong>，无符号数<strong>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</strong>。</li><li><strong>表是由多个无符号数或者其他表作为数据项构成的复合数据类型</strong>，表的命名习惯以“info”结尾。表用于描述有层次关系的复合结构的数据。</li></ul><p>整个Class文件本质上也可以视作是一张表， 这张表由下图所示的数据项按严格顺序排列构成。<strong>该格式中的数据项，无论是顺序还是数量，都是被严格限定的</strong>。(【】内表示数量，第一列表示数据类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;【<span class="number">1</span>】 <span class="comment">//Class文件的标志（魔数）</span></span><br><span class="line">    u2             minor_version;【<span class="number">1</span>】<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;【<span class="number">1</span>】<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool【constant_pool_count-<span class="number">1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br><span class="line">    u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;【<span class="number">1</span>】<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;【<span class="number">1</span>】<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;【<span class="number">1</span>】<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces;【interfaces_count】<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;【<span class="number">1</span>】<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields;【fields_count】<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;【<span class="number">1</span>】<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods;【methods_count】<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;【<span class="number">1</span>】<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes;【attributes_count】<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class文件中，<strong>当需要描述同一类型但数量不定的多个数据项时，使用一个前置的容量计数器（u2无符号数，即两个字节）加若干个连续的数据项的形式来表示</strong>。</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure><p>每个Class文件的头4个字节称为魔数，用于<strong>标志这是一个能被JVM接受的class文件</strong>。其值为<code>0xCAFEBABE</code>。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version<span class="comment">;【1】</span></span><br><span class="line">u2             major_version<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure><p><strong>紧接的4个字节是class文件的版本号，第5、6为次版本号（Minor Version），第7、8为主版本号（Major Version）</strong>。</p><p><strong>高版本的 Java 虚拟机可以向下兼容执行低版本编译器生成的 Class 文件</strong>，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p><blockquote><p>jdk1.1对应45（十进制），往上依次递增1。如jdk1.8对应52（0x34）</p></blockquote><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool【constant_pool_count<span class="number">-1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br></pre></td></tr></table></figure><p>紧接着主、次版本号之后的是常量池， <strong>常量池可以比喻为Class文件里的资源仓库， 它是Class文件结构中与其他项目关联最多的数据</strong>。</p><p><strong>常量池中常量的数量是不固定的</strong>。constant_pool_count指定常量数量。<strong>这个容量计数是从1而不是0开始的</strong>，例如，若是0x0018（十进制24），即表示有24-1=23个常量。<strong>将第0项常量空出来的目的在于</strong>：<strong><font color="red">如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义， 可以把索引值设置为0来表示</font></strong>。</p><p>对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。</p><p>常量池中主要存放两大类常量：<strong>字面量和符号引用</strong>。</p><ul><li>字面量比较接近于Java语言层面的常量概念， 如文本字符串、被声明为final的常量值等。</li><li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul><li>被模块导出或者开放的包</li><li><strong>类和接口的全限定名</strong> </li><li>**字段的名称和描述符 ** </li><li><strong>方法的名称和描述符</strong> </li><li>方法句柄和方法类型</li><li>动态调用点和动态常量</li></ul></li></ul><blockquote><p>Java代码在进行Javac编译的时候， 并不像C和C++那样有“连接”这一步骤， 而是<strong>在虚拟机加载Class文件的时候进行动态连接</strong>的 。也就是说， <strong>在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存人口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</strong>。</p></blockquote><p>常量池中每一项常量都是一个表，<strong>截至JDK13</strong>， 常量表中分别有17种不同类型的常量。<strong>这些表都有一个共同的特点， 表结构起始的第一位是个u1类型的标志位</strong>(tag， 见下表标志列)，代表着当前常量属于哪种常量类型。17种类型如下表：</p><table><thead><tr><th>类型</th><th>标志（tag）</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>５</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>６</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>７</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>８</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>９</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MothodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>17</td><td>表示一个动态计算常量</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr><tr><td>CONSTANT_Module_info</td><td>19</td><td>表示一个模块</td></tr><tr><td>CONSTANT_Package_info</td><td>20</td><td>表示一个模块中开发或者导出的包</td></tr></tbody></table><p>常见的11种类型的结构表：（index表示指向第几个常量项）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125112646190.png" alt="image-20210125112646190"></p><blockquote><p>在读取常量池时，只要读取每个项的第一个字节（tag）就可得知其类型，得知其类型后就能知道该项占多少字节，也就可以知道下一项从哪里开始，以此类推。</p></blockquote><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure><p>常量池结束之后紧接着的两个字节代表<strong>访问标志</strong>，这个标志用于识别一些类或者接口层次的访问信息，即一个类或接口使用了哪些访问修饰符（public、abstract等）。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125113620989.png" alt="image-20210125113620989"></p><p>一个类或接口可拥有多个标志，<strong>这时标志值应该为这多个标志值取或</strong>。如 ACC_PUBLIC | ACC_SUPER = 0x0021。</p><h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><pre><code>u2             this_class;【1】//当前类u2             super_class;【1】//父类u2             interfaces_count;【1】//接口数量u2             interfaces;【interfaces_count】//一个类可以实现多个接口</code></pre><p>类索引和父类索引都是一个u2类型的数据， 而接口索引集合是一组u2类型的数据的集合， Class文件中<strong>由这三项数据来确定该类型的继承关系</strong>。</p><ul><li><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名</strong>。Java不允许多继承， 所以父类索引只有一个， 除了java.lang.Object之外， 所有的Java类都有父类， 因此除了java.lang.Object外， 所有Java类的父类索引都不为0。<strong>这是两个索引值，指向常量池的对应项</strong>。</p></li><li><p><strong>接口索引集合</strong>描述这个类实现了哪些接口，集合第一个项是接口计数器，之后是对应数量的接口索引（若计数器为0则不再占用任何字节）。<strong>这些接口索引将按implements关键字（如果该Class文件表示接口， 则是extends）后的接口顺序从左到右排列在接口索引集合中</strong>。</p></li></ul><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><pre><code>u2             fields_count;【1】//Class 文件的字段属性field_info     fields;【fields_count】//一个类会可以有多个字段</code></pre><p>字段表用于描述接口或类中声明的变量。字段<strong>包括类级变量以及实例变量</strong>，但<strong>不包括在方法内部声明的局部变量</strong>。</p><p>一个字段表的结构（来自javaGuide）：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p><p>各字段解释：</p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ，<code>private</code>，<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符），可否被序列化（transient 修饰符），可变性（final），可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> <strong>对常量池的引用</strong>，表示的字段的简单名称；</li><li><strong>descriptor_index:</strong> <strong>对常量池的引用</strong>，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，<strong>适合使用标志位来表示。而字段叫什么名字、字段数据类型都是无法固定的，只能引用常量池中常量来描述</strong>。</p><p><strong>字段表中不会列出继承自父类或父接口的字段</strong>。</p><blockquote><p>关于描述符：描述符用来描述<strong>字段的数据类型</strong>，或方<strong>法的参数列表（包括数量、类型和顺序）和返回值</strong>。基本数据类型以及无返回值void都用一个大写字符表示，对应关系：</p><ul><li>B- byte， C-char， D- double， F- float， I- int， J- long， s- short， z-boolean， v- void， L-对象类型，如Ljava.lang.String</li><li>对于数组，一个维度对应一个 <code>[</code>， + L + 元素类型，如<code>[[I，[[Ljava.lang.String</code>。</li></ul><p>描述符描述方法时，<strong>按照先参数列表后返回值的顺序</strong>，如<code>()V 、(I)Ljava.lang.String</code>。</p></blockquote><p>access_flags表示访问标志，即字段的修饰符，其取值如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150405202.png" alt="image-20210125150405202"></p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><pre><code>u2             methods_count;【1】method_info    methods;【methods_count】</code></pre><p>分别表示方法数量和方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构与字段表一样，如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p><p><strong>Java方法里的代码，经Javac编译成字节码之后，放在方法属性表集合中一个名为“Code”的属性里面</strong>。</p><p>标志位取值：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125173337287.png" alt="image-20210125173337287"></p><blockquote><p>synchronized关键字 的字节码相关： P46</p></blockquote><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="regexp">//</span>此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];<span class="regexp">//</span>属性表集合</span><br></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="一些常见属性"><a href="#一些常见属性" class="headerlink" title="一些常见属性"></a>一些常见属性</h3><p>1.<strong>Code属性</strong> </p><p>结构：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125174146152.png" alt="image-20210125174146152" style="zoom:80%;" /><ul><li><p>attribute_length表示attribute所包含的字节数，不包含 attribute name index和attribute length字段。</p></li><li><p>max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度</p></li><li><p>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量</p></li></ul><p>2.<strong>LineNumberTable</strong>属性</p><p>用于表示Code中的字节码与源码的行号对应关系（一行对应一个指令）</p><p>3.LocalVariableTable</p><p>局部变量表，记录局部变量信息，其中的变量名等会引用常量池中的utf8字符串常量。</p><p><strong>对于实例方法，在class文件中，每个方法内至少会有一个局部变量：this，即所属对象的引用</strong></p><h2 id="To-be-continue"><a href="#To-be-continue" class="headerlink" title="To be continue"></a>To be continue</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>《深入理解JVM》</p><p><a href="https://snailclimb.gitee.io/javaguide/#/?id=java">JavaGuide文档</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;class文件结构概述&quot;&gt;&lt;a href=&quot;#class文件结构概述&quot; class=&quot;headerlink&quot; title=&quot;class文件结构概述&quot;&gt;&lt;/a&gt;class文件结构概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Class文件是一组&lt;font color=&quot;red</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/Tag/JVM/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-03T16:01:09.711Z</published>
    <updated>2021-03-03T16:00:39.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>定义：<strong>在当前进程中，通过单例模式创建的类有且只有一个实例</strong>。</p><p>单例有如下几个特点：</p><ul><li>在Java应用中，单例模式<strong>需要保证在一个JVM中，该对象只有一个实例存在</strong>。</li><li><strong>构造器必须是私有的</strong>，外部类无法通过调用构造器方法创建该实例。</li><li><strong>没有公开的set方法</strong>，外部类无法调用set方法创建该实例。</li><li>提供一个公开的get方法获取唯一的这个实例。</li></ul><p>单例模式的好处：</p><ul><li>某些类创建比较频繁，<strong>对于一些大型的对象，节省很大的系统开销</strong>。</li><li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li><li>系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个，会造成系统混乱。</li><li>避免了对资源的重复占用</li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在<strong>程序启动或单例模式类被首次主动使用的时候</strong>，单例模式实例被创建。<strong>总之，饿汉式体现的是想提前把对象创建好</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式没有线程安全问题，instance是在Singleton类初始化时创建的，JVM可以保证线程安全。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式单例在第一次调用getInstance才创建实例。</p><h3 id="线程不安全实现"><a href="#线程不安全实现" class="headerlink" title="线程不安全实现"></a>线程不安全实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Singleton2.getInstance());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行多次，可以看到获取对象不是同一个。</p><p><strong>应用场景</strong>：如果这个数据是经常访问的热点数据，那我就可以在系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了；反之，数据使用频率较低，则使用懒汉式，避免资源浪费。</p><h3 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h3><p>getInstance加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样能保证线程安全，但是<strong>效率过低，实例被创建后调用getInstance依然需要加锁</strong>。</p><p>通过双检锁（double-checked）做两次判断优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意INSTANCE需要加上<code>volatile</code>关键字，避免指令重排序问题</strong>。<code>INSTANCE = new Singleton();</code>并不是原子操作，JVM可能会先执行赋值操作再执行初始化操作，</p><p>没加volatile时线程不安全的情况：</p><ul><li>A、B同时进入第一个if。</li><li>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</li><li>由于JVM内部的优化机制，JVM可能会<strong style="color:red">先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块</strong>。</li><li>随后B进入synchronized块，由于instance此时不是null，<strong>因此它马上离开了synchronized块并将结果返回给调用该方法的程序</strong>。</li><li>此时若B线程马上使用Singleton实例，<strong>却发现它没有被初始化，于是错误发生了</strong>。</li></ul><p>缺点：<strong>由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高</strong>。</p><p>可以使用静态内部类实现。</p><h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>使用内部类来维护单例的实现，<strong>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的</strong>。</p><h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举来实现单实例控制会更加<strong>简洁，而且JVM从根本上提供保障，绝对防止多次实例化</strong>，是更简洁、高效、安全的实现单例的方式。</p><h2 id="为什么不用静态方法而用单例模式？"><a href="#为什么不用静态方法而用单例模式？" class="headerlink" title="为什么不用静态方法而用单例模式？"></a>为什么不用静态方法而用单例模式？</h2><p>（来自参考连接）</p><p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，<strong>面向对象的代码提供一个更好的编程思想</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>原文：<a href="https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ">设计模式系列 - 单例模式</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;定义：&lt;strong&gt;在当前进程中，通过单例模式创建的类有且只有一个实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;单例有如下几个特点：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML类图六种关系</title>
    <link href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/"/>
    <id>http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/</id>
    <published>2021-03-03T16:01:09.700Z</published>
    <updated>2021-03-03T16:00:56.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UML类图用于<strong>描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</strong>。 </p><p>类之间的关系有：<strong>泛化（继承）、实现、关联、聚合、组合、依赖</strong>。</p><p>六种关系的耦合度大小是：<strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong>。</p><h2 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h2><p>泛化就是指继承关系。</p><p>代码体现：子类继承父类。</p><p>UML符号：<strong>实线+空心箭头，箭头指向父类</strong> </p><p>如图：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022222623274.png" alt="image-20201022222623274"></p><h2 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h2><p>实现关系即实现类实现接口。</p><p>代码体现：A类实现B接口。</p><p>UML符号：<strong>一条虚线+空心箭头</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022224009475.png" alt="image-20201022224009475" style="zoom:67%;" /><h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>关联关系指<strong>类和类之间的联系，如一对一、一对多、多对多。其中有单向关联，双向关联。</strong> </p><p>代码体现：成员变量</p><p>UML符号：<strong>双向关联，一条实线或一条实线+两个箭头；单向关联，一条实线+一个箭头</strong> </p><p>一对一</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225341448.png" alt="image-20201022225341448" style="zoom:67%;" /><p>其他：（图片来自<a href="https://www.zhihu.com/question/419192424/answer/1471808645%EF%BC%89">https://www.zhihu.com/question/419192424/answer/1471808645）</a></p><p><img src="https://pic2.zhimg.com/80/v2-b880e61921fcc252b58a2a8da1baf368_720w.jpg?source=1940ef5c"></p><h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>聚合关系（Aggregation）表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开，即部分能脱离整体而独立存在</strong>。</p><p>代码体现：成员变量</p><p>UML符号：<strong>一条实线+空心菱形</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225828143.png" alt="image-20201022225828143" style="zoom:67%;" /><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>组合也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开，部分不能脱离整体而独立存在</strong>。</p><p>代码体现：成员变量</p><p>UML符号：<strong>一条实线+实心菱形</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230156462.png" alt="image-20201022230156462" style="zoom:67%;" /><h2 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h2><p>是一种使用关系，一个类的实现需要另一个类的协助。即在一个类中使用了另外一个类。<strong>尽量不要使用双向依赖。以上关系都是依赖关系的特例</strong>。</p><p>代码体现：局部变量、方法的参数或者对静态方法的调用。</p><p>UML符号：<strong>一条虚线+箭头</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230737289.png" alt="image-20201022230737289" style="zoom:67%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/vic_/p/8057851.html">https://www.cnblogs.com/vic_/p/8057851.html</a></p><p><a href="https://www.zhihu.com/question/419192424/answer/1471808645">https://www.zhihu.com/question/419192424/answer/1471808645</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;UML类图用于&lt;strong&gt;描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;类之间的关</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式七大基本原则</title>
    <link href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2021-03-03T16:00:06.237Z</published>
    <updated>2021-03-03T15:59:54.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式的七大原则如下：</p><ul><li>单一职责原则 (Single Responsibility Principle)</li><li>接口隔离原则 (Interface Segregation Principle)</li><li>开放-关闭原则 (Open-Closed Principle)</li><li>里氏替换原则 (Liskov Substitution Principle)</li><li>依赖倒转原则 (Dependence Inversion Principle)</li><li>迪米特法则（Law Of Demeter）</li><li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li></ul><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>通俗地说，单一职责原则即<strong>一个类只负责一项职责（不是只有一个方法）</strong>。</p><p>假设某个类 P 负责两个不同的职责：职责 P1 和 职责 P2，那么当职责 P1 需求发生改变而需要修改类 P，有可能会导致原来运行正常的职责 P2 功能发生故障。</p><p>在实际编程中比较难严格的遵守该原则，可以作一些折中处理，比如若是一个类中方法个数比较少，可以在方法级别上遵守该原则（此时在类级别上可能不遵守）。<strong>只有逻辑足够简单，才可以在代码级别上违背单一职责原则</strong>。</p><p>单一职责原则的作用和细节：</p><ul><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ul><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>接口隔离原则指：<strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</strong>：</p><p>被依赖的类实现一个接口，就需要实现接口的所有方法，但这个类在被使用时可能只用到其中部分方法。也就是只要接口中出现的方法，不管依赖于它的类是否需要该方法，实现类都必须去实现这些方法，这就不符合接口隔离原则。可以对接口进行拆分，让实现类只实现需要的接口。</p><p>示例（见来自<a href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89%EF%BC%9A">https://zhuanlan.zhihu.com/p/24614363）：</a></p><img src="https://pic4.zhimg.com/80/v2-ec9b282b367e9c148a7963b5b23c60e7_720w.png" style="zoom:80%;" /><p>类 A 依赖于 接口 I 中的方法 1，2，3 ，类 B 是对类 A 的具体实现。类 C 依赖接口 I 中的方法 1，4，5，类 D 是对类 C 的具体实现。对于类B和类D来说，<strong>虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。</strong> </p><p>用代码表示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line"> <span class="comment">// 类 B 只需要实现方法 1，2, 3，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line"><span class="comment">// 类 D 只需要实现方法 1，4，5，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        A a = <span class="keyword">new</span> A();  </span><br><span class="line">        a.depend1(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());  </span><br><span class="line">          </span><br><span class="line">        C c = <span class="keyword">new</span> C();  </span><br><span class="line">        c.depend1(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend2(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend3(<span class="keyword">new</span> D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对接口根据下图进行拆分：</p><img src="https://pic3.zhimg.com/80/v2-7611098e41bcfbf5113d978b47fc8466_720w.png" style="zoom:80%;" /><p>代码可修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><strong>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</strong>。</li><li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li></ol><h2 id="依赖倒转原则（DIP）"><a href="#依赖倒转原则（DIP）" class="headerlink" title="依赖倒转原则（DIP）"></a>依赖倒转原则（DIP）</h2><p>定义：<strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象</strong>。进一步说，<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。<strong>依赖倒转原则的核心思想就是面向接口编程</strong>。</p><p>依赖倒转原则是基于这样的设计理念：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给实现类去完成。</p><p>示例：（来自<a href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89">https://zhuanlan.zhihu.com/p/24614363）</a></p><p>一个场景：母亲给孩子讲故事，只要给她一本书，她就可照着书给孩子讲故事了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Book book)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(book.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>假如有一天，给的是一份报纸，而不是一本书，让这个母亲讲下报纸上的故事，报纸的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>显然这个母亲完成不了这个任务。只有将Mother类中的Book换成Newspaper才能完成</strong>。但若是以后换成杂志等其他读物，又得进行修改。原因是 Mother 和 Book之间的耦合度太高了。<strong>可以引入一个抽象接口 IReader表示读物，让书和报纸去实现这个接口，那么无论提供什么样的读物，该母亲都能读</strong>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(IReader reader)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(reader.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Mother类代表高层模块，读物相关的类则代表低层模块，在修改示例之前，是高层依赖于低层代码，Mother类要按着Book类来；修改后则符合依赖倒转原则，低层的读物依着高层的Mother来。</p><p><strong>实际情况中，代表高层模块的 Mother 类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒转原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险</strong>。</p><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p><strong>面向对象中继承性的问题</strong>：有一功能 P1, 由类 A 完成，现需要将功能 P1 进行扩展，扩展后的功能为 P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则<strong>子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障</strong>。</p><p>里氏替换原则：</p><ul><li><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li><li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法</strong>。</li><li><strong>子类中尽量不要重写父类的方法</strong>。</li></ul><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而<strong>里氏替换原则就是表达了这一层含义</strong>。</p><p>根据该原则，对于上述的继承性问题：当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能 P2，尽量不要修改父类方法预期的行为。</p><h2 id="开放-关闭原则（OCP）"><a href="#开放-关闭原则（OCP）" class="headerlink" title="开放-关闭原则（OCP）"></a>开放-关闭原则（OCP）</h2><p>**开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改。(Open for extension, close for modification，对扩展开放，对修改关闭)**。</p><p>一个软件满足 OCP 原则后的两项优点：</p><ol><li><strong>能够扩展已存在的系统</strong>，能够提供新的功能满足新的需求，因此该软件有着很强的适应性和灵活性。</li><li>已存在的模块，特别是那些重要的抽象模块，不需要被修改，那么该软件就有很强的稳定性和持久性。</li></ol><p>示例：</p><p>有个生产电脑的公司，根据输入的类型，生产出不同的电脑，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Computer c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;macbook&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Macbook();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;surface&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Surface();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然上面的代码违背了开放 - 关闭原则，<strong>如果需要添加新的电脑产品，需要修改 produceComputer 原本已有的方法</strong>，正确的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Macbook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MSFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Surface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方式应该是将 Factory 抽象成接口，让具体的工厂(如苹果工厂，微软工厂)去实现它，生产它们公司相应的产品，这样写有利于扩展，如果这是需要新增加戴尔工厂生产戴尔电脑，我们仅仅需要创建新的电脑类和新的工厂类，而不需要去修改已经写好的代码。</p><p>总结：</p><ol><li><strong>OCP 可以具有良好的可扩展性，可维护性</strong>。</li><li><strong>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它</strong>。</li></ol><h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><p>迪米特法则又称为<strong>最少知道原则</strong>，它表示<strong>一个对象应该对其它对象保持最少的了解</strong>。**<font color="red">通俗来说就是，只与直接的朋友通信</font>**。</p><p><strong>什么是直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，<strong>称出现在成员变量、方法参数、方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类则不是直接的朋友</strong>。根据迪米特法则，**<font color="red">陌生的类最好不要作为局部变量的形式出现在类的内部</font>**。</p><p><strong>对于被依赖的类来说，无论逻辑多么复杂，都尽量的将逻辑封装在类的内部，对外提供 public 方法，不对泄漏任何信息</strong>。</p><p>示例：</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个 SchoolManager 对象 </span></span><br><span class="line">    SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager(); </span><br><span class="line">    <span class="comment">//输出学院员工id和学校员工id</span></span><br><span class="line">    schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学校员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工管理类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回学院的所有员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;CollegeEmployee&gt; list = newArrayList&lt;CollegeEmployee&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="comment">//这里我们增加了 10 个员工到 </span></span><br><span class="line">            list CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回所有学校员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;Employee&gt; list = newArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">            list Employee emp = <span class="keyword">new</span> Employee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">&#125; </span><br><span class="line">        <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到SchoolManager的printAllEmployee方法中，<strong>CollegeEmployee并不是SchoolManager的直接朋友，不符合迪米特法则</strong>。</p><p>可以将打印CollegeEmployee部分的代码封装进CollegeManager中：</p><p>CollegeManager中添加新的public方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">    List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而可以在SchoolManager中通过CollegeManager调用该方法来打印所有学院员工id，SchoolManager.printAllEmployee方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">sub.printEmployee();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">    List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-聚合复用原则（CRP）"><a href="#组合-聚合复用原则（CRP）" class="headerlink" title="组合/聚合复用原则（CRP）"></a>组合/聚合复用原则（CRP）</h2><p>组合/聚合复用原则指的是<strong>在实际开发设计中，尽量使用组合/聚合，不要使用类继承</strong>。</p><p>在面向对象的设计中，<strong>如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类，如果基类的实现发生了改变，则子类的实现也不得不改变</strong>。</p><ul><li><p>总体说来，组合或者聚合好过于继承。</p></li><li><p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24614363">https://zhuanlan.zhihu.com/p/24614363</a></p><p><a href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;设计模式的七大原则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则 (Single Responsibility Principle)&lt;/li</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
