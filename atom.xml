<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bxxiao</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-21T09:11:27.033Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>bxxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LinkedHashMap-JDK1.8</title>
    <link href="http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedHashMap%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedHashMap%20-%20JDK1.8/</id>
    <published>2021-03-21T09:11:45.718Z</published>
    <updated>2021-03-21T09:11:27.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedHashMap <strong>继承自 HashMap，在 HashMap 的基础上维护了一个双向链表，解决了 HashMap 遍历顺序和插入顺序不一致的问题</strong>。除此之外，LinkedHashMap <strong>对访问顺序也提供了相关支持</strong>。在一些场景下，该特性很有用，比如实现 LRU 缓存。</p><p>在实现上，LinkedHashMap 很多方法直接继承自 HashMap，<strong>仅为维护双向链表覆写了部分方法</strong>。</p><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>先看Entry 继承体系：</p><p>Map 中 Entry 的继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap.TreeNode -&gt; LinkedHashMap.Entry -&gt; HashMap.Node -&gt; Map.Entry</span><br></pre></td></tr></table></figure><p>它们对应的成员变量：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210321152715920.png" alt="image-20210321152715920" style="zoom:80%;" /><p><strong>可以看到 LinkedHashMap.Entry 中的 before 和 after 变量，它们提供了双向链表的特性</strong>。同时 TreeNode 继承自 LinkedHashMap.Entry，所以它也可以作为双向链表的结点。<strong>LinkedHashMap 中使用的就是这两类结点，它在原本的链表、红黑树基础上通过 before、after 引用维护了一个双向链表</strong>，如下图（<strong>图片来自参考链接</strong>）：</p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg"/><blockquote><p>关于 Entry 继承体系更多细节：<a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/#31-entry-%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB">Entry 继承体系</a> </p></blockquote><h2 id="链表建立过程"><a href="#链表建立过程" class="headerlink" title="链表建立过程"></a>链表建立过程</h2><p>LinkedHashMap 中有<strong>两个引用：head、tail</strong>，指向双向链表的头和尾。</p><p><strong>在通过 <code>put</code> 方法加入元素的时候就同时将新增结点链入链表尾部</strong>。但 <strong style="color:red">LinkedHashMap 并没有覆盖 HashMap 的 put 方法，使用的都是父类的 put</strong> 。<strong>其维护双向链表的关键方法在于插入结点时调用的 <code>newNode()</code> 方法</strong>。</p><p>如下（标 ★★ 处）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中的 put 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中的 putVal 方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// ★★</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// ★★</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashMap 覆盖了父类的  <code>newNode()</code> 方法</strong>，它们的区别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建的是 Node 类型结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建的是 LinkedHashMap.Entry 类型结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 将 p 链入双向链表尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap</span></span><br><span class="line"><span class="comment">// 将 p 链入双向链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:red">所以关键点是 LinkedHashMap 覆盖了父类的  <code>newNode()</code> 方法，在创建结点时使用的是这个覆盖方法，在该方法中创建的是 LinkedHashMap.Entry 类型的结点，并将其链入双向链表尾部</strong>。</p><p>通过维护双向链表，在遍历时只要顺着链表遍历就可以保证遍历顺序跟插入顺序一致。</p><p>另外，在 put 方法的最后还有一个 <code>afterNodeInsertion(evict);</code> 方法，在 JDK 1.8 HashMap 的源码中，相关的方法有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>这些方法的用途是<strong>在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中</strong>。即 LinkedHashMap  覆盖了这 3 个回调方法。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>与插入操作一样，LinkedHashMap 的删除操作也是直接使用父类的实现。<strong>在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。<font color="red">LinkedHashMap 删除结点后维护链表的操作是通过上述的回调方法实现的</font></strong>。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);<span class="comment">// ----删除结点后调用回调方法----</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆盖</span></span><br><span class="line"><span class="comment">// 将指定结点从链表中断开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">// 结点向下转型为 LinkedHashMap.Entry </span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="维护访问顺序"><a href="#维护访问顺序" class="headerlink" title="维护访问顺序"></a>维护访问顺序</h2><p>上文讲的是 LinkedHashMap 如何维护插入顺序，而除了插入顺序， LinkedHashMap 还可以维护访问顺序， LinkedHashMap 有一个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p><strong>该变量为 true 时表示启用访问顺序维护</strong>。该值默认为 false ，可通过该构造方法指定为 true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所谓维护访问顺序就是：当调用<code>get/getOrDefault/replace</code>等访问了结点的方法时，将这些方法访问的结点移动到链表的尾部</strong>。</p><p>代码：（<strong>注意 LinkedHashMap 重写了两个 get 方法</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 若 accessOrder 为 true，调用 afterNodeAccess</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 若 accessOrder 为 true 且当前结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 讲 p 从原位置移除</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 讲 p 链入尾部</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h2><p>LinkedHashMap 的最后一个回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 根据条件判断是否移除最近最少被访问的节点（头结点）</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，removeEldestEntry 方法是一个空实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以通过继承 LinkedHashMap ，并重写该方法、自实现判断逻辑来实现 LRU 缓存</strong>。比如根据结点数量或结点存货时间来判断是否要移除。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/">LinkedHashMap 源码详细分析（JDK1.8） - 田小波</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedHashMap &lt;strong&gt;继承自 HashMap，在 HashMap 的基础上维护了一个双向链表，解决了 HashMap </summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HashMap-JDK1.7</title>
    <link href="http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.7/"/>
    <id>http://example.com/2021/03/21/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.7/</id>
    <published>2021-03-21T02:39:00.462Z</published>
    <updated>2021-03-21T02:38:42.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="底层存储结构"><a href="#底层存储结构" class="headerlink" title="底层存储结构"></a>底层存储结构</h2><p>内部<strong>包含了一个 Entry 类型的数组 table。Entry 存储着键值对</strong>。且每个 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。<strong>JDK1.7 的 HashMap 使用拉链法来解决冲突，同一个链表中存放 哈希值和数组取模运算 结果相同（即桶索引相同）的 Entry</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>JDK1.7 的构造方法机制与 JDK1.8 大致相同，都只是先初始化 threshold、loadFactor，存储元素的数组等到第一次插入键值时才根据 threshold、loadFactor 的值创建。</p><h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 key 为 null，作另外处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据 hash 和 table 长度计算桶索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先遍历索引所在的链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 若 hash 相同，且key相同（== 或 equals ），则进行 value 的替换</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 否则使用头插法插入新结点</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>key 为 null 时，因为无法调用其 <code>hashCode()</code> 计算 hash 值，所以 HashMap 把 key 为 null 的值放在 <code>table[0]</code></strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addEntry：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩容检查</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 扩容后重新计算索引</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新结点</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外要注意的是开头的判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 table 为空，说明其还未初始化，调用 inflateTable 方法初始化，<strong>会根据 threshold 找到一个大于它的最小的 2 的幂次方的数作为 table 的长度</strong>。</p><h2 id="确定桶下标"><a href="#确定桶下标" class="headerlink" title="确定桶下标"></a>确定桶下标</h2><p><code>put()</code> 方法中的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 hash</span></span><br><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="comment">// 根据 hash 和 table 长度计算桶索引</span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"><span class="comment">//========================================</span></span><br></pre></td></tr></table></figure><p>hash 方法（<strong>扰动函数</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 h 值进行 4 次扰动，减少哈希碰撞</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexFor 方法：</p><ul><li><strong>若一个正整数 x 是 2 的 n 次方，则对于 任一整数 y，有 <code>y % x = y &amp; (x - 1)</code></strong>。</li><li>所以 indexFor 方法实际上是进行了 <code>%</code> 运算，<strong style="color:red">使用 <code>y &amp; (x - 1)</code> 形式的原因是对于计算机来说，位运算效率更高</strong>。</li><li><strong>HashMap 的容量总是 2 的 n 次方</strong>，所以总是满足该关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容原理"><a href="#扩容原理" class="headerlink" title="扩容原理"></a>扩容原理</h2><p>在添加结点时，会先判断 size 是否到达阈值，到达则扩容，新容量指定为原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩容逻辑在 resize 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原数组的元素转移到新数组</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 重新计算阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据新容量重新计算桶索引</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 头插法插入</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;底层存储结构&quot;&gt;&lt;a href=&quot;#底层存储结构&quot; class=&quot;headerlink&quot; title=&quot;底层存储结构&quot;&gt;&lt;/a&gt;底层存储结构&lt;/h2&gt;&lt;p&gt;内部&lt;strong&gt;包含了一个 Entry 类型的数组 table。Entry 存储着键值对&lt;/strong</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList-JDK1.8</title>
    <link href="http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/ArrayList%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/ArrayList%20-%20JDK1.8/</id>
    <published>2021-03-20T14:20:41.630Z</published>
    <updated>2021-03-20T14:19:59.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些重要成员变量"><a href="#一些重要成员变量" class="headerlink" title="一些重要成员变量"></a>一些重要成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    // 实现了 <span class="title">RandomAccess</span> ，表示具有随机访问的特性</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组最大长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定容量为 0 时 elementData 的初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用无参构造器时 elementData 的初始值（默认大小时）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定长度的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定为 0 时，赋值一个空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造器</span></span><br><span class="line"><span class="comment">// 默认长度是 10，但调用构造器并不会将 elementData 初始化为长度为 10 的数组，</span></span><br><span class="line"><span class="comment">// 而是赋值一个空数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>ArrayList 提供了两个 add 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素插入到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量检查</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">// 将新元素插入序列尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入到 index 位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引合法性</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add(int index, E element)</code> 每次都需要移动元素，时间复杂度是 O(n) ，若是频繁使用会影响效率，应尽量少使用。</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p><strong>调用 <code>add</code> 方法时，插入元素之前都会先进行容量检查，若容量不够，则需要进行扩容</strong>。扩容的新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，大约是旧容量的 1.5 倍。扩容的具体实现在 <code>grow()</code> 方法，<strong>扩容时使用 <code>Arrays.copyOf()</code> ，这个操作代价很高</strong>。</p><p><strong>如果能确定元素个数，则最好在创建 ArrayList 对象时就指定容量大小，减少扩容操作的次数</strong>。</p><p>扩容逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果使用的是默认构造器，elementData 会被赋值为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA（空数组），</span></span><br><span class="line"><span class="comment">// 在第一次添加元素时（没有使用ensureCapacity主动扩容），会将数组扩容到长度为 10（即默认长度 - DEFAULT_CAPACITY）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若指定的最小容量大于 当前数组的长度 ，进行扩容。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若所需最小容量大于当前数组长度，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 扩容的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量，为旧容量的 1.5 倍左右</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="comment">// 如果 1.5 倍新容量小于最小所需容量，将新容量置为 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 若 newCapacity 大于 MAX_ARRAY_SIZE，计算新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 若最小所需容量大于 MAX_ARRAY_SIZE ，返回 Integer.MAX_VALUE ， 否则 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 还提供一个主动扩容的方法，该方法将数组扩容为指定大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少重新分配的次数</strong>。</p><p><strong>若是使用无参构造器创建一个 ArrayList（即默认长度为 10），并不会一开始就将 elementData 初始化为长度为 10 的数组，只是赋值一个空数组</strong>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>会等到第一次添加元素时，才会将数组长度扩容为 10</strong>（会在 calculateCapacity 方法中判断 elementData 是否是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，若是，指定 minCapacity 为 10）。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>ArrayList 有两个 remove 方法：</p><p>它们的操作的时间复杂度为 O(N)，所以 ArrayList 删除元素的代价是非常高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定索引处的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 要删除的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要移动元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从数组的 index+1 位置开始，将 numMoved 个元素依次向前移动一位，覆盖被删除值</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将最后一个元素置空，并将 size 值减1    </span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除所有 null 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速删除，即不用进行索引检查，不返回被删除元素值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize"></a>trimToSize</h3><p>往 ArrayList 插入大量元素后，又删除很多元素，<strong>此时底层数组会空闲出大量的空间。因为 ArrayList 没有自动缩容机制，导致底层数组大量的空闲空间不能被释放，造成浪费</strong>。对于这种情况，ArrayList 也提供了相应的处理方法，即 trimToSize 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果当前元素个数小于数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = </span><br><span class="line">            <span class="comment">// size 为 0 直接赋值为空数组</span></span><br><span class="line">            (size == <span class="number">0</span>)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            <span class="comment">// 否则只保留前 size 个元素</span></span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>ArrayList 实现了 RandomAccess 接口（该接口是个标志性接口），表明它具有随机访问的能力。在遍历 ArrayList 时，使用 for 循环的效率会比使用 foreach 效率要高，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 foreach 会转化为使用迭代器遍历，效率不如使用 for 循环</strong>。</p><h2 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h2><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此<strong>保存元素的数组不一定都会被使用</strong>，那么就<strong>没必要全部进行序列化</strong>。</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><p>ArrayList 实现了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制<strong>只序列化数组中有元素填充那部分内容</strong>。</p><p>序列化时会调用 <code>writeObject()</code> 方法，<strong>该方法在传入的对象存在 <code>writeObject()</code> 方法时会去反射调用该对象的 writeObject() 来实现序列化</strong>。反序列化原理类似。</p><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><p>ArrayList 有一个继承自 AbstractList 的成员变量 <code>modCount</code> ，记录 ArrayList 被改变的次数（添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小时），<strong>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException</strong>。在 <code>writeObject()</code> 方法中有所体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.tianxiaobo.com/2018/01/28/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ArrayList 源码分析 - 田小波</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList%E6%BA%90%E7%A0%81+%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">ArrayList 源码+扩容机制分析 - JavaGuide</a> </p><p><a href="http://www.cyc2018.xyz/Java/Java%20%E5%AE%B9%E5%99%A8.html">Java 容器 - CyC</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些重要成员变量&quot;&gt;&lt;a href=&quot;#一些重要成员变量&quot; class=&quot;headerlink&quot; title=&quot;一些重要成员变量&quot;&gt;&lt;/a&gt;一些重要成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList-JDK1.8</title>
    <link href="http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedList%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/LinkedList%20-%20JDK1.8/</id>
    <published>2021-03-20T14:20:41.629Z</published>
    <updated>2021-03-20T14:04:20.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedList 的继承体系：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320171051562.png" alt="image-20210320171051562" style="zoom:67%;" /><p>LinkedList <strong>底层是基于双向链表实现的，所以 LinkedList 的容量上限是物理内存或 JVM 内存上限，它无需像 ArrayList 般进行扩容，且支持高效的插入和删除操作</strong>，但是<strong>存储元素的节点需要额外的空间存储前驱和后继的引用</strong>，且不支持 O(1) 的随机访问，虽然实现了 List 接口，有 <code>get(int)</code> 方法，但其时间复杂度是 O(n) 。</p><p><strong>LinkedList 中有两个引用 first、last 分别指向头结点和尾结点，所以在链表头部和尾部插入效率比较高，但在其他指定位置进行插入时，效率一般</strong>。因为在指定位置插入<strong>需要先定位到该位置处的节点</strong>，此操作的时间复杂度为 O(n)。另外，LinkedList 是非线程安全的集合类。</p><p>LinkedList 可以作为队列、栈来使用。需要使用栈时应优先使用 LinkedList ，而避免使用 Stack 类。</p><p>关于 AbstractSequentialList 抽象类：AbstractSequentialList 提供了一套基于顺序访问的接口。通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口。<strong>但 LinkedList 并没有直接该类的方法，而是重新实现了一套方法</strong>。</p><p>LinkedList 内的结点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回索引 index 对应的结点（即第 index+1 个结点）</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 根据 index 是否小于 size 的一半决定从 first 还是 last 开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 LinkedList 因为是基于链表实现，索引不能随机访问元素。这里有<strong>一个小优化</strong>：会根据 index 离哪一端近来决定从 first 还是 last 开始遍历。</p><p>此外，LinkedList 还有针对队列和栈的一些方法：<code>getFirst() getLast() poll() pop()</code>  等，都是直接返回头结点或尾结点的值。</p><h2 id="关于遍历的问题"><a href="#关于遍历的问题" class="headerlink" title="关于遍历的问题"></a>关于遍历的问题</h2><p><strong>遍历 LinkedList 应该使用 iterator 或者 foreach 循环（会转换为使用 iterator ）</strong>，应该避免如下形式的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    Integet item = list.get(i);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedList 的 <code>get(int)</code> 方法时间复杂度是 O(n) ，若是集合中的元素数量较大，效率会很低</strong>。</p><p>LinkedList 的迭代器实现：</p><blockquote><p>调用 <code>iterator()</code> 方法时最终会调用 <code>listIterator(0)</code> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定索引开始迭代</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>LinkedList 继承和实现了多个类和接口，有很多插入元素的方法，如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320210837017.png" alt="image-20210320210837017"></p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210320210935569.png" alt="image-20210320210935569"></p><p>针对队列和栈的一些方法大都是在头结点和尾结点操作，逻辑较简单，这里主要分析前 add 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 直接插入到链表尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 先找到 index 位置的结点（node(index)），再把 element 插入到该结点之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// last 后移</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点 </span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 新结点的 prev 指向 succ 的 prev，next 指向 succ</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// succ 的 prev 指向新结点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 若 succ 原本是头结点，则插入新结点后将 first 指向 newNode</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则 pred 的 next 连接 newNode</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些操作都是典型的链表操作，不难理解。</p><p><code>add(index, element)</code> 的逻辑是：</p><ul><li>若 index 等于 size，<strong>表示要插入链表尾部，直接调用 linkLast 即可</strong>；</li><li><strong>否则需要先定位到 index 处的结点，再把新结点插入到该结点之前</strong>。</li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>相对 LinkedList 的插入方法，它也有很多对应的删除方法，这里主要分析 <code>remove(index)</code> 和 <code>remove(obj)</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的元素，返回该元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">// 检查索引</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，删除成功返回 true，否则 false</span></span><br><span class="line"><span class="comment">// 若是有多个相同的值，则只删除找到的第一个（unlink 后立即 return）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// o 为 null 值</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 不为 null。使用 equals 比较</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定节点从链表中移除</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prev 为空表示 x 是头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 first 指向 next 即可</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;<span class="comment">///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似的，判断 x 是不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;<span class="comment">///</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//将 x 的 item 引用置 null</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink 方法的逻辑如下（假设删除的节点既不是头节点，也不是尾节点）：</p><ol><li>将待删除节点 x 的前驱的后继指向 x 的后继</li><li><strong>将待删除节点 x 的前驱引用置空，断开与前驱的链接</strong> </li><li>将待删除节点 x 的后继的前驱指向 x 的前驱</li><li><strong>将待删除节点 x 的后继引用置空，断开与后继的链接</strong> </li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.tianxiaobo.com/2018/01/31/LinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK-1-8">LinkedList 源码分析(JDK 1.8) - 田小波</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedList 的继承体系：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/bxgitee/noteImage/ra</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL概述</title>
    <link href="http://example.com/2021/03/20/MySQL/MySQL%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/03/20/MySQL/MySQL%E6%A6%82%E8%BF%B0/</id>
    <published>2021-03-20T12:57:38.415Z</published>
    <updated>2021-03-20T12:59:33.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        MySQL很牛逼。</p><p><strong><span style="color:red">MySQL是属于C/S架构的软件</span></strong>。</p><p>MySQL的优点：可将数据持久化到本地；可用sql语言进行查询，便于管理。</p><hr><h2 id="MySQL的卸载及安装"><a href="#MySQL的卸载及安装" class="headerlink" title="MySQL的卸载及安装"></a>MySQL的卸载及安装</h2><h3 id="MySQL卸载"><a href="#MySQL卸载" class="headerlink" title="MySQL卸载"></a>MySQL卸载</h3><p>MySQL的卸载：<a href="https://www.bilibili.com/video/BV12b411K7Zu?p=249">https://www.bilibili.com/video/BV12b411K7Zu?p=249</a>  第6集</p><h3 id="MySQL8-0-22的安装"><a href="#MySQL8-0-22的安装" class="headerlink" title="MySQL8.0.22的安装"></a>MySQL8.0.22的安装</h3><p><a href="https://blog.csdn.net/qq_43715354/article/details/109354222">https://blog.csdn.net/qq_43715354/article/details/109354222</a></p><p>按照该教程至第八步。</p><ul><li><p>启动cmd。</p></li><li><p>输入<code>mysql -u root -p</code> </p></li><li><p>输入上述随机生成的密码进入数据库。进入后需要修改密码，因为随机生成的密码在登录后会过期。（这时若不修改密码，执行一切sql语句都会报错，提醒修改密码）</p></li><li><p>修改密码的命令：</p><ul><li><p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;newPassword&#39;;</code> </p></li><li><p><code>flush privileges;</code> </p></li></ul></li></ul><h3 id="my-ini文件"><a href="#my-ini文件" class="headerlink" title="my.ini文件"></a>my.ini文件</h3><p>MySQL的安装目录下的<code>my.ini</code>文件是MySQL的配置文件，在其中可配置相关信息（#开头的为注释），其中的<code>[mysqld]</code>下可配置服务端的相关信息，如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\\Program Files\MySQL\mysql-<span class="number">8.0</span>.<span class="number">22</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\\Program Files\MySQL\mysql-<span class="number">8.0</span>.<span class="number">22</span>\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为utf8mb4</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment">#mysql_native_password</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br></pre></td></tr></table></figure><hr><h2 id="MySQL服务的启动和关闭"><a href="#MySQL服务的启动和关闭" class="headerlink" title="MySQL服务的启动和关闭"></a>MySQL服务的启动和关闭</h2><p>可通过</p><p><strong>【右键我的电脑】-》【管理】-》【服务和应用程序】-》【服务】-》【找到MySQL】-》【双击，选择启动/关闭】</strong> </p><p>或者：</p><p><strong>以【管理员身份运行命令行】-》【输入命令<code>net stop/start mysqlServerName</code>】</strong> </p><hr><h2 id="登录MySQL及环境变量"><a href="#登录MySQL及环境变量" class="headerlink" title="登录MySQL及环境变量"></a>登录MySQL及环境变量</h2><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><p>​        可通过MySQL自带的命令行（只能登录root用户）。</p><p>​        也可通过命令行：</p><p>​        <code>mysql -h localhost -P 3306 -u root -p </code> </p><p>​        <code>mysql -h localhost -P 3306 -u root -padmin</code> （<strong>用于连接远程</strong>）</p><p>​        <code>mysql -u root -pPassword</code> （<strong>连接本地MySQL</strong>）</p><h3 id="MySQL环境变量"><a href="#MySQL环境变量" class="headerlink" title="MySQL环境变量"></a>MySQL环境变量</h3><p>​        若以上命令不可用，可能原因是没有配置环境变量（<strong>若是使用msi安装包安装则MySQL会自动配置</strong>）。</p><p>​        手动配置过程：在<code>Path</code>环境变量中添加MySQL的安装目录中的bin目录路径即可。</p><hr><h2 id="MySQL语法规范及常用命令"><a href="#MySQL语法规范及常用命令" class="headerlink" title="MySQL语法规范及常用命令"></a>MySQL语法规范及常用命令</h2><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ul><li>MySQL中的<strong>命令以<code>;</code>或<code>\g</code>结束</strong>。</li><li>MySQL命令不区分大小写。</li><li>注释<ul><li>单行注释：<code>#注释</code>或<code>-- 注释</code>(空格必需)</li><li>多行注释：<code>/* 注释 */</code> </li></ul></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>进入MySQL后，可使用以下相关命令：</p><p>显示所有数据库：<strong><code>show databases;</code></strong> </p><p><code>----------------------------------</code> </p><p>使用指定数据库：<strong><code>use dababaseName;</code> </strong></p><p><code>----------------------------------</code>   </p><p>显示当前数据库中的所有表：<strong><code>show tables;</code> </strong></p><p><code>----------------------------------</code> </p><p>显示指定数据库的所有表（<strong>使用该命令后，当前数据库位置不变</strong>）：<strong><code>show tables from databaseName</code> </strong></p><p><code>----------------------------------</code> </p><p>查看表结构：<strong><code>desc tableName</code> </strong> </p><p><code>----------------------------------</code> </p><p>查看MySQL版本：</p><p>在MySQL中：<strong><code>select version();</code> </strong> </p><p>在MySQL外：<strong><code>mysql --version</code>或<code>mysql -V</code> </strong> </p><p><code>----------------------------------</code> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        MySQL很牛逼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;MySQL是属于C/S架</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="http://example.com/2021/03/20/MySQL/%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/03/20/MySQL/%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-03-20T12:55:23.154Z</published>
    <updated>2021-03-20T12:59:41.520Z</updated>
    
    <content type="html"><![CDATA[<p>（以下部分内容摘抄自<a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL" target="_blank">javaGuide博客文档</a>）</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​        <strong>事务是逻辑上的一组操作，即一个或多个SQL语句，要么都执行，要么都不执行</strong>。<strong>如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚</strong>。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功， 则事物被顺利执行。</p><p>​        事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200716162156.png"></p><ol><li><p><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p><ul><li><p><strong>ACID里的AID都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个C,实际上它依赖于应用层,也就是依赖于开发者.这里的一致性是指<font color="red">系统从一个正确的状态,迁移到另一个正确的状态</font>.什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性</strong>。</p><p>（来自<a href="https://www.zhihu.com/question/31346392/answer/362597203">https://www.zhihu.com/question/31346392/answer/362597203</a> 作者：孟波）</p></li></ul></li><li><p><strong>隔离性（Isolation）：</strong> 并发访问数据库时，<strong>一个用户的事务不被其他事务所干扰</strong>，各并发事务之间是独立的；</p></li><li><p><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ol><h3 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h3><p>​        事务可分为隐式事务和显式事务。隐式事务如DML语言（insert、update、delete），每一个语句都是一个事务；而显式事务通过sql语句开启事务跟关闭事务，一个事务可有多条语句。</p><p>​        <strong>msyql默认关闭事务，通过<code>SHOW VARIABLES LIKE &#39;%autocommit%&#39;;</code>命令可看到``autocommit=ON`，即自动提交默认开启。创建事务前需关闭自动提交</strong>。<strong><span style="color:red;">事务中不能包括DDL语句</span></strong>。</p><p>显示事务的创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.开启事务</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> TRASACTION; <span class="comment">#可选</span></span><br><span class="line"><span class="comment">--编写事务语句</span></span><br><span class="line">语句1</span><br><span class="line">语句2</span><br><span class="line">...</span><br><span class="line"><span class="comment">--结束事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>一个转账的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>(</span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">money <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">account</span> <span class="keyword">VALUES</span>(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">1000</span>),(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#转账例子</span></span><br><span class="line"><span class="comment">#开启事务（关闭事务自动提交）</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">#事务语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money=<span class="number">1500</span> <span class="keyword">WHERE</span> username=<span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line"><span class="comment">#提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h4 id="回滚点SAVEPOINT"><a href="#回滚点SAVEPOINT" class="headerlink" title="回滚点SAVEPOINT"></a>回滚点SAVEPOINT</h4><p>​        回滚点跟<code>ROLLBACK</code>搭配使用，其作用是设置一个保存点，当执行<code>ROLLBACK</code>时回滚到保存点。</p><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> a;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> a;</span><br></pre></td></tr></table></figure><p>执行以上语句后查询account表，可发现只删除了id为2的记录。</p><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p>​        在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（<strong>多个用户对同一数据进行操作</strong>）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><p><strong>脏读（Dirty read）:</strong> <strong>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的</strong>，比如可能出现错误而回滚事务，导致修改后的数据没有存入数据库。</p></li><li><p><strong>丢失修改（Lost to modify）:</strong> <strong>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改</strong>。 例如：</p><ul><li><p>事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。（<strong>即结果应该是A=18，但因为事务2的修改覆盖了事务1的修改，使事务1丢失</strong>）</p></li><li><p>考虑飞机订票系统中的一个活动序列: </p><ol><li>甲售票点（甲事务）读出某航班的机票余额A,设A=16. </li><li>乙售票点（乙事务）读出同一航班的机票余额A,也为16. </li><li>甲售票点卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库. </li><li>乙售票点也卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库. </li></ol><p><strong><span style="color:red">结果明明卖出两张机票，数据库中机票余额只减少1</span></strong>。 </p></li></ul></li><li><p><strong>不可重复读（Unrepeatableread）:</strong> <strong>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的结果可能不一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读</strong>。（事务1读数据的过程中，事务2把数据给改了，导致事务1两次读的数据不同）</p></li><li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，<strong>第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</strong>。（<strong>在同一事务下，连续执行两次同样的SQL语句第二次的SQL语句可能返回之前不存在的行</strong>）</p></li></ul><p><strong><span style="color:red">不可重复读和幻读区别</span></strong>： </p><p><strong>不可重复读的重点是数据的值被修改，比如多次读取一条记录发现其中某些列的值被修改</strong>，幻读的重点在于<strong>新增或者删除比如多次读取一条记录发现记录增多或减少了</strong>。</p><h3 id="MySQL的事务隔离级别"><a href="#MySQL的事务隔离级别" class="headerlink" title="MySQL的事务隔离级别"></a>MySQL的事务隔离级别</h3><p><strong><span style="color:red">SQL 标准定义了四个隔离级别：</span></strong> </p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong><span style="color:red">可能会导致脏读、幻读或不可重复读</span></strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong><span style="color:red">可以阻止脏读，但是幻读或不可重复读仍有可能发生</span></strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> <strong>对同一字段的多次读取结果都是一致的</strong>，除非数据是被本身事务自己所修改，<span style="color:red"><strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></span>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> <strong>最高的隔离级别，完全服从ACID的隔离级别</strong>。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但效率极低。该标准类似于线程锁。</li></ul><p>可总结为下表（<strong>打勾表示可能发生</strong>）</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>MySQL <strong>InnoDB 存储引擎</strong>的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。可以<strong>通过<code>SELECT @@tx_isolation;</code>命令</strong>来查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure><p>​        <strong><span style="color:red">这里需要注意的是</span></strong>：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是<strong>Next-Key Lock 锁算法</strong>，因此<strong><span style="color:red">可以避免幻读的产生</span></strong>，这与其他数据库系统(如 SQL Server) 是不同的。所以说<strong><span style="color:red">InnoDB 存储引擎的默认支持的隔离级别已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别</span></strong>。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，<strong>但是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读），<span style="color:red"> 并不会有任何性能损失</span></strong>。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><p>设置事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span>/<span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> </span><br><span class="line"><span class="keyword">read</span> uncommitted | <span class="keyword">read</span> committed | repeatable <span class="keyword">read</span>(默认) | <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure><h3 id="锁机制与InnoDB锁算法（to-be-continue）"><a href="#锁机制与InnoDB锁算法（to-be-continue）" class="headerlink" title="锁机制与InnoDB锁算法（to be continue）"></a>锁机制与InnoDB锁算法（to be continue）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（以下部分内容摘抄自&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL&quot; target=&quot;_blank&quot;&gt;javaGuide博客文档&lt;/a&gt;）&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/Tag/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HashMap-JDK1.8</title>
    <link href="http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.8/"/>
    <id>http://example.com/2021/03/20/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap%20-%20JDK1.8/</id>
    <published>2021-03-20T04:12:49.715Z</published>
    <updated>2021-03-21T02:38:11.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashMap 最早出现在 JDK1.2 ，底层基于哈希表实现，<strong>JDK1.8 之前处理哈希碰撞使用的是拉链法，在 JDK1.8 引入了红黑树优化，即当链表过长时会转换为红黑树，提高查询效率</strong>。HashMap 允许 null 键和 null 值，null 键对应的哈希值是 0。<strong>HashMap 不保证键值对的顺序，在某些操作后，键值对的顺序会改变</strong>（比如扩容时）。</p><p>HashMap <strong>不是线程安全集合</strong>。</p><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>HashMap 使用拉链法哈希算法，<strong>在 JDK1.8 引入红黑树来优化过长链表</strong>。</p><p>HashMap 定位元素的过程是：</p><ul><li>计算桶索引。</li><li>在桶所在链表（或红黑树）查找元素。</li></ul><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，只执行 <code>resize()</code> 方法对数组扩容。</p><h2 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h2><p>HashMap 的 4 个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">// 默认装载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">// 默认初始容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了第 3 个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 以上皆是参数检查</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>构造方法只是初始化一些重要变量，而其他数据结构是延迟到插入键值对时再进行初始化</strong>。</p><h3 id="初始容量、负载因子、阈值"><a href="#初始容量、负载因子、阈值" class="headerlink" title="初始容量、负载因子、阈值"></a>初始容量、负载因子、阈值</h3><table><thead><tr><th align="left">名称</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">initialCapacity</td><td align="left">HashMap 初始容量</td></tr><tr><td align="left">loadFactor</td><td align="left">负载因子</td></tr><tr><td align="left">threshold</td><td align="left">当前 HashMap 所能容纳键值对数量的最大值（阈值），超过这个值，则需扩容</td></tr></tbody></table><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The load factor used when none specified in constructor. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The next size value at which to resize (capacity * load factor). */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>HashMap 中并没有定义 capacity 这个属性，它只是构造方法中用一次，没必要定义一个变量保存。</p><p>其中，<code>threshold=capacity*loadFactor</code>，这里要注意的一个点是，<strong>上面的 tableSizeFor 方法并不是这么初始化 threshold 的值的</strong>。</p><p>在构造方法 3 中，可以看到使用了 tableSizeFor 方法来初始化 threshold 值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 cap 减 1</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 进行 5 次移位、或运算</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 最后 + 1</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的<strong>目的是找到大于或等于 cap 的最小的 2 的幂次方的数</strong>，将该值赋值给 threshold  。<strong style="color:red">这里其实不是计算 threshold ，而是根据指定的 cap 计算 table 的容量，只是将值暂存在 threshold </strong>。</p><p>负载因子的作用是规定了可使用的容量比例，通过调节负载因子，可使 HashMap 时间和空间复杂度上有不同的表现：</p><ul><li>将负载因子调小，即所能容纳的数据表少，但相应的会减少键之间的哈希碰撞，链表长度减少，使得增删查改效率变高，<strong>这就是典型的拿空间换时间</strong>；</li><li>反之，将负载因子调大，能提高空间利用率，但哈希碰撞概率增大，性能相对下降。</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>get 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// (n - 1) &amp; hash 计算得出 key 对应的桶索引</span></span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断桶第一个元素是不是目标</span></span><br><span class="line">        <span class="comment">// hash 值相同</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            <span class="comment">// 且通过 == 比较相同或 equals 比较相同</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 第一个元素不是目标</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若是红黑树，在红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则在链表中查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 总结一下查找 key 的过程（省略一些 null 检查）：</span></span><br><span class="line"><span class="comment">// 1. 先计算 key 对应的桶索引</span></span><br><span class="line"><span class="comment">// 2. 获取桶的第一个结点，判断该结点是否是目标，</span></span><br><span class="line"><span class="comment">//    其中，判断标准是：hash 相同且使用 == 或 equals 比较相同</span></span><br><span class="line"><span class="comment">// 3. 否则再根据 first 是红黑树还是链表进行查找，判断标准跟上同</span></span><br></pre></td></tr></table></figure><h3 id="计算桶索引"><a href="#计算桶索引" class="headerlink" title="计算桶索引"></a>计算桶索引</h3><p>分析其中计算桶索引的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first = tab[(n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p><strong>HashMap 中桶数组的大小 length 保证总是 2 的 n 次幂</strong>，<strong style="color:red">此时，<code>(n - 1) &amp; hash</code> 等价于 hash 值对 length 取余，即计算桶索引实质上是 hash 值对桶数组取模，使用位运算计算方式的原因是对于计算机来说，位运算效率更高</strong>。</p><blockquote><p><strong>若一个正整数 x 是 2 的 n 次方，则对于 任一整数 y，有 <code>y % x = y &amp; (x - 1)</code></strong> 。</p></blockquote><p>再看看计算 hash 值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<strong>并不是直接使用 key 的 hashCode() 方法返回值，而是会再进行一次异或操作</strong>。</p><p><code>&gt;&gt;&gt;</code> 是右移补零操作符，int 类型值是 4 个字节，即 32 位，通过 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 的方式可以让高 16 位值与低 16 位值进行异或，<strong>即让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中，加大 hash 值的复杂度</strong>。</p><p><strong style="color:red">重新计算 hash 可以增加 hash 的复杂度，当覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因</strong>。</p><p>还要注意的一个点是：HashMap 是允许 key 为 null 的，<strong>当 key 为 null 时，由 hash 方法可看出返回的是 0 ，则 key 为 null 的键值对总是对应桶索引 0</strong> 。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>核心逻辑在 putVal 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 若 table 为空或长度为 0 ，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算对应的桶索引，若索引处为空，直接插入键值对即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶索引处已有键值对</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 先判断第一个键值对，若 hash 相同，且 == 或 equals 比较相等，将 e 指向 p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶中引用类型是 TreeNode，则调用红黑树的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 链表中不包含要插入的键值对，将该结点插入到链表最后</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 若链表长度到达树化阈值，则进行树化操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  hash 相同，且 == 或 equals 比较相等，停止循环（此时 e 指向 p.next）</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要插入的键值对是否存在 HashMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span></span><br><span class="line">            <span class="comment">// 通过 put(k, v) 调用该方法时，onlyIfAbsent 为 false ，所以只要 e 不为 null 就会更新</span></span><br><span class="line">            <span class="comment">// 若 onlyIfAbsent 为 true，则 oldValue 为 null 才指向更新</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// HashMap 中该方法为空方法</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 插入后若 size 到达阈值，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// HashMap 中该方法为空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal 方法总结：</p><ul><li><p><strong style="color:red">当桶数组 table 为空时，通过扩容的方式初始化 table</strong>（初始化 HashMap 后第一次插入值就会通过扩容初始化 table）。</p></li><li><p>计算桶索引，若对应的桶为 null，直接插入即可。</p></li><li><p>若桶已存有值（<strong>每次都是先比较第一个结点</strong>）</p><ul><li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值。<strong>“存在”的判断标准是两个 key 的 hash 相同且通过 <code>==</code> 或 <code>equals()</code> 比较返回 true</strong> 。<strong>HashMap 中可以存在两个 hash 相同，但 key 通过 equals 比较不相同的键值对</strong>。</li><li>如果不存在，<strong>则将键值对插入红黑树或链入链表中</strong>，且<strong style="color:red">链入链表后根据链表长度决定是否将链表转为红黑树</strong>。</li></ul></li><li><p><strong>插入新键值对后判断键值对数量是否大于阈值，大于的话则进行扩容操作</strong>。</p></li></ul><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>扩容逻辑位于 resize 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// table 不为空，已经初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">        <span class="comment">// 将阈值置为 Integer.MAX_VALUE ，直接返回 oldTab</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试按旧容量和阈值的 2 倍计算新容量和阈值的大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// table 为空，且 oldThr 大于 0</span></span><br><span class="line">    <span class="comment">// 调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况</span></span><br><span class="line">    <span class="comment">// 此时 threshold 存的是 capacity</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// table 为空，且 oldThr 也为 0，对应调用 HashMap() 的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 置为默认容量大小</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// threshold = capacity * loadfactor</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按阈值计算公式进行计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">///=============================</span></span><br><span class="line">    <span class="comment">// 创建新 table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 旧 table 不为空，则需要将其中的元素重新映射到新 table</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 当前桶只有一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 当前桶存的是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>resize 方法的逻辑概括</strong>：</p><ul><li>计算新桶数组的容量 newCap 和新阈值 newThr。</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li><li><strong>将键值对节点重新映射到新的桶数组里</strong>。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。    </li></ul><h3 id="计算-newCap-和-newThr-逻辑分析"><a href="#计算-newCap-和-newThr-逻辑分析" class="headerlink" title="计算 newCap 和 newThr 逻辑分析"></a>计算 newCap 和 newThr 逻辑分析</h3><p>分析计算 newCap 和 newThr 的两个分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个条件分支</span></span><br><span class="line"><span class="keyword">if</span> ( oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 嵌套条件分支</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;...&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个条件分支</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>分支一：</p><ul><li><p>oldCap &gt; 0：桶数组 table 已经被初始化。</p><ul><li>oldCap &gt;= 2<sup>30</sup>：这时如果旧容量到达 MAXIMUM_CAPACITY(2<sup>30</sup>) ，则将阈值置为Integer.MAX_VALUE，即 2<sup>31</sup>-1，<strong>且这时不进行扩容，直接返回旧 table</strong>。</li><li>newCap &lt; 2<sup>30</sup> &amp;&amp; oldCap &gt; 16：这时会先将 newCap x 2，若满足条件，将新阈值 newThr = oldThr &lt;&lt; 1，<strong>这时若是传入的 loadFactor 的值（<code>HashMap(int, float) </code>构造方法）大于 8 且为 2 的幂次方，则此操作可能造成溢出，这时 newThr 为 0</strong> 。</li></ul></li><li><p>(oldCap==0 &amp;&amp;)oldThr &gt; 0：threshold &gt; 0，且桶数组未被初始化</p><ul><li>调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，<strong>这种情况下 threshold 存的并不是阈值，而是暂存容量（<code>this.threshold = tableSizeFor(initialCapacity);</code>）</strong>，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出。</li></ul></li><li><p>oldCap == 0 &amp;&amp; oldThr == 0：桶数组未被初始化，且 threshold 为 0</p><ul><li>调用 HashMap() 构造方法会产生这种情况。该构造方法中只是初始化了 loadFacotr 变量。这时使用默认值计算 newCap 和 newThr 。（即默认容量 16， 默认负载因子 0.75）</li></ul></li></ul><p>分支二：分支一中 oldCap &gt; 0 时 newThr 出现溢出，或 (oldCap==0 &amp;&amp;)oldThr &gt; 0时，newThr 会为 0，根据容量和装在因子计算。</p><h3 id="映射到新-table-链表"><a href="#映射到新-table-链表" class="headerlink" title="映射到新 table(链表)"></a>映射到新 table(链表)</h3><p>若旧 table 不为空，需要将键值对映射到新 table 中，对旧 table 进行遍历，若桶不为空，有 3 种情况：</p><ul><li>桶中只有一个元素，直接将该元素映射到新 table 。（<code>e.hash &amp; (newCap - 1)</code>）</li><li>桶类型是红黑树，则拆分红黑树。</li><li>桶类型是链表，遍历链表，<strong>并将链表节点按原顺序进行分组再映射到新 table，注意映射到新 table 后结点的相对顺序没变</strong>。</li></ul><p><strong>这里分析第 3 种情况</strong>。</p><p>往底层数据结构中插入节点时，一般都是先通过模运算计算桶位置，接着把节点放入桶中即可。事实上可以把重新映射看做插入操作。在 JDK 1.7 中，也确实是这样做的。<strong>但在 JDK 1.8 中，则对这个过程进行了一定的优化，逻辑上要稍微复杂一些</strong>。</p><p><strong>优化逻辑分析见参考链接</strong>。</p><p><strong>总的来说就是</strong>：</p><ul><li><strong style="color:red">若 <code>e.hash &amp; oldCap</code> 的值为 0 ，则 e 在新 table 的桶索引跟在旧 table 中的一样</strong>。</li><li><strong style="color:red">若不为 0 ，则在新 table 的桶索引为 <code>旧索引 + oldCap</code> </strong>。</li></ul><p><strong>这样就不用使用 <code>e.hash &amp; (newCap - 1)</code> 来计算桶索引，效率更高</strong>。</p><p><strong>resize 中根据这个逻辑把链表分成两个队列，将两个队列分别插入新 table 对应的桶</strong>。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">    <span class="comment">// 两个队列（链表）</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入 lo 队列</span></span><br><span class="line">            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则插入 hi 链队列</span></span><br><span class="line">            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 将整个 lo 链表插入到新 table 的 j 桶即可</span></span><br><span class="line">    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j] = loHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入到 j + oldCap 桶</span></span><br><span class="line">    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j + oldCap] = hiHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 1.8 版本下 HashMap 扩容效率要高于之前版本。比如相对于 JDK1.7 ，JDK 1.7 为了防止因 hash 碰撞引发的拒绝服务攻击，在<strong>计算 hash 过程中引入随机种子</strong>。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的 hash。而在 JDK 1.8 中，则通过引入红黑树替代了该种方式。从而避免了多次计算 hash 的操作，提高了扩容效率。</p><h2 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h2><p>树结点内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeNode 的继承关系是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode -&gt; LinkedHashMap.Entry -&gt; HashMap.Node -&gt; Map.Entry</span><br></pre></td></tr></table></figure><p>HashMap.Node 即链表类型结点。</p><h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><p>在将键值对插入链表后，会判断是否需要树化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====== putVal 中的代码片段</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">// =======================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 若 table 为空或长度不到 MIN_TREEIFY_CAPACITY，则优先扩容，不进行树化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// hd 为头节点（head），tl 为尾节点（tail）</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 按顺序将普通链表转成 树形节点链表（注意还不是红黑树）</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将普通节点替换成树形节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// p 接入尾部</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 先将树型链表赋值到 index 处的桶</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 将树形链表转换成红黑树</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>treeifyBin 中并不是直接将链表树化，<strong>要树化要满足两个条件</strong>：</p><ol><li>链表长度大于等于 TREEIFY_THRESHOLD（在 putVal 方法中判断）</li><li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY</li></ol><p><strong style="color:red">即链表长度到达 8 ，且桶数组容量大于等于 64 时才会进行树化，若只是链表长度到 8 ，则优先进行扩容</strong>。</p><p><strong>优先进行扩容的原因</strong>：（来自参考链接）</p><p>当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。<strong>毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程</strong>。同时，<strong>桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事</strong>。</p><p>另外，<strong>树化前会先将链表转为树型链表，TreeNode 继承自 Node 类，所以 TreeNode 仍然包含 next 引用，在这个过程中<font color="red">原链表的节点顺序最终通过 next 引用被保存下来</font></strong>。</p><p>树化的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（摘自参考链接）</p><p>HashMap 在设计之初，并没有考虑到以后会引入红黑树进行优化。所以并没有像 TreeMap 那样，要求键类实现 comparable 接口或提供相应的比较器。但由于<strong>树化过程需要比较两个键对象的大小</strong>，在键类没有实现 comparable 接口的情况下，怎么比较键与键之间的大小了就成了一个棘手的问题。为了解决这个问题，HashMap 是做了三步处理，确保可以比较出两个键的大小，如下：</p><ol><li>比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较</li><li>检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较</li><li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 （大家自己看源码吧）</li></ol><p><strong style="color:red">链表转成红黑树后，原链表的顺序通过 next 引用被保留了（红黑树的根节点会被移动到链表的第一位），仍然可以按遍历链表的方式去遍历上面的红黑树。这样的结构为后面红黑树的切分以及红黑树转成链表做好了铺垫</strong>。</p><h3 id="红黑树拆分"><a href="#红黑树拆分" class="headerlink" title="红黑树拆分"></a>红黑树拆分</h3><p>扩容后需要将旧 table 中的键值对映射到新 table，<strong>若是存在红黑树结点，需要进行拆分重新映射</strong>。</p><p>拆分红黑树按照一般思路，可以先将红黑树转换为链表，再将链表<strong>按 resize() 方法中分组的方式进行重新映射</strong>。<strong style="color:red">由上已知红黑树中通过 next 引用仍然保留着原来链表的顺序，所以对红黑树进行重新映射时，直接按照映射链表的方式进行即可</strong>，不用先转换为链表，无形中提高了效率。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// == resize() 中代码片段</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"><span class="comment">// ==================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 tab 是 newTab </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 两个队列</span></span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。</span></span><br><span class="line"><span class="comment">     * 下面的循环是对红黑树节点进行分组，与 resize 中类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 loHead 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 链表长度小于等于 6(UNTREEIFY_THRESHOLD)，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 否则需要树化</span></span><br><span class="line"><span class="comment">             * hiHead == null 时，表明扩容后，</span></span><br><span class="line"><span class="comment">             * 所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新映射红黑树<strong>逻辑总结</strong>：</p><ul><li>与映射链表的逻辑基本一致（红黑树中保存了原链表的顺序）</li><li>不同的地方在于，重新映射后，<strong>会将红黑树拆分成两条由 TreeNode 组成的链表</strong>。<strong>这时若是链表的长度小于等于UNTREEIFY_THRESHOLD，则需要将 TreeNode 链表转换为 Node 链表</strong>（见下一小节）。</li><li><strong>否则根据条件还需要将 TreeNode 链表树化</strong>。</li></ul><p>也就是说，<strong>红黑树拆分是<font color="red">先将树拆成两个链</font>，再根据条件判断是否需要树化</strong>。</p><h3 id="红黑树链化"><a href="#红黑树链化" class="headerlink" title="红黑树链化"></a>红黑树链化</h3><p>红黑树链化的方法是 <code>untreeify()</code> ，<strong>因为红黑树中仍然保留了原链表节点顺序，所以只需将 TreeNode 结点转换为 Node 结点即可</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历 TreeNode 链表，并用 Node 替换</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// 替换节点类型</span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchValue 表示是否 value 相同才删除，若是使用 remove(key) 方法时，是要删除指定 key 的键值对，所以</span></span><br><span class="line"><span class="comment">// matchValue 指定为 false；若是使用 remove(key, value)，则指定为 true（需要同时匹配 value）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 定位桶位置</span></span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果 key 与第一个结点相同，将 node 指向第一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是 TreeNode 类型，调用红黑树的查找逻辑定位待删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链表，则遍历找到指定 key</span></span><br><span class="line">            <span class="comment">// 找到结点时，node 指向待删除结点， p 指向 node 的前驱结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除结点（若找不到则 node 为 null）</span></span><br><span class="line">        <span class="comment">// 对于 remove(key,value) 方法，matchValue 为 true，所以需要匹配 value 值</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 删除树结点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// node 是桶的第一个结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// node 指向待删除结点， p 指向 node 的前驱结点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transient-table"><a href="#transient-table" class="headerlink" title="transient table"></a>transient table</h2><p><a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#%E8%A2%AB-transient-%E6%89%80%E4%BF%AE%E9%A5%B0-table-%E5%8F%98%E9%87%8F"> 被 transient 所修饰 table 变量</a> </p><p>HashMap 中 table 数组被 transient 修饰，表示 table 不会被默认的序列化机制序列化。HashMap 通过实现<code>readObject/writeObject</code>两个方法自定义了序列化的内容。</p><p>为什么不直接将整个 table 序列化即可？</p><ol><li><strong>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</strong>。</li><li><strong style="color:red">同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误</strong>。<ul><li>HashMap 的 <code>get/put/remove</code> 等方法第一步就是根据 hash 找到键所在的桶位置，<strong>但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的</strong>。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</li></ul></li></ol><h2 id="与-JDK1-7-的主要区别"><a href="#与-JDK1-7-的主要区别" class="headerlink" title="与 JDK1.7 的主要区别"></a>与 JDK1.7 的主要区别</h2><h3 id="链表-amp-红黑树"><a href="#链表-amp-红黑树" class="headerlink" title="链表&amp;红黑树"></a>链表&amp;红黑树</h3><p>JDK1.8 的 HashMap 相比于 JDK1.7，最大的区别肯定是红黑树优化，<strong>在插入元素后，若链表的长度大于阈值且数组长度大于 64 时会将链表树化</strong>。（数组长度不够则优先扩容）</p><p>JDK1.7 插入新结点时使用的是头插法，而 JDK1.8 则是插入到链表尾部。</p><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>JDK1.7 计算元素在新 table 中的索引时都是使用 hash 对长度取模的原始方式；JDK1.8 中则进行了优化，使用链表分组的方式（具体见上文），避免了多次重新计算 hash 值。</p><p>扩容后将旧 table 的元素转移到新 table 时，JDK1.7 依旧是使用头插法，所以一个链表上的元素的相对顺序会颠倒。而 JDK1.8 因为链表分组的方式保存了原来的顺序。（<strong>有啥用勒？</strong>）</p><p>JDK1.8 的扩容逻辑相对较复杂，计算 newThr 和 newCap 时兼顾了 table 未初始化的情况；且转移元素时需要针对链表和红黑树作不同的处理。</p><h3 id="计算hash"><a href="#计算hash" class="headerlink" title="计算hash"></a>计算hash</h3><p>JDK1.7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，且相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>（摘自参考连接）</p><p><strong>JDK 1.7 为了防止因 hash 碰撞引发的拒绝服务攻击，在计算 hash 过程中引入随机种子。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的 hash。而在 JDK 1.8 中，则通过引入红黑树替代了该种方式。从而避免了多次计算 hash 的操作，提高了扩容效率</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>主要参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/">HashMap 源码详细分析(JDK1.8) - 田小波</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap(JDK1.8)%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">JavaGuide - HashMap底层分析</a>  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;HashMap 最早出现在 JDK1.2 ，底层基于哈希表实现，&lt;strong&gt;JDK1.8 之前处理哈希碰撞使用的是拉链法，在 JDK1.</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="集合源码" scheme="http://example.com/categories/Java/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>包装类总结</title>
    <link href="http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-16T08:37:06.898Z</published>
    <updated>2021-03-20T06:05:44.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java<strong>中</strong>有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型 ：byte、short、int、long、float、double</li><li>1 种字符类型：char</li><li>1 种布尔型：boolean。</li></ul><p>它们占的字节大小：</p><table><thead><tr><th>基本类型</th><th>字节</th></tr></thead><tbody><tr><td>int</td><td>4</td></tr><tr><td>short</td><td>2</td></tr><tr><td>long</td><td>8</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>char</td><td>2</td></tr><tr><td>float</td><td>4</td></tr><tr><td>double</td><td>8</td></tr><tr><td>boolean</td><td></td></tr></tbody></table><p><strong>对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素</strong>。</p><p>&emsp;&emsp;</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>八种基本类型都有对应的包装类分别为：<strong>Byte、Short、Integer、Long、Float、Double、Character、Boolean</strong>。</p><h3 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h3><p>Java 是号称面向对象的语言，所有的类型都是引用类型。但是基本类型如 int 等不是引用类型，也不是继承自 Object，<strong>所以 Java 需要一个这样的包装类来使其具有对象的特性： 比如可以赋值为 null；且Java 集合中也只能放入包装类型，而不支持基本类型；可以创建一些特定的方法等</strong>。</p><p>&emsp;&emsp;</p><h3 id="自动装箱-自动拆箱及其原理"><a href="#自动装箱-自动拆箱及其原理" class="headerlink" title="自动装箱/自动拆箱及其原理"></a>自动装箱/自动拆箱及其原理</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来（转换为对应的包装类）；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>自动装箱/自动拆箱是如何实现的？</p><p>编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">2</span>;<span class="comment">// 装箱</span></span><br><span class="line">        <span class="keyword">int</span> b = a;<span class="comment">// 拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>javap -verbose</code> 指令，查看 main 方法的反编译字节码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> main(java.lang.String[]);</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_2</span><br><span class="line">        <span class="number">1</span>: invokestatic  #<span class="number">2</span>   <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">4</span>: astore_1</span><br><span class="line">        <span class="number">5</span>: aload_1</span><br><span class="line">        <span class="number">6</span>: invokevirtual #<span class="number">3</span>   <span class="comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">        <span class="number">9</span>: istore_2</span><br><span class="line">       <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong style="color:red">可以看到，自动装箱实际上是调用对应包装类的 <code>static valueOf()</code> 方法；而对于自动拆箱，调用的是包装类对象的 <code>xxxValue()</code> ，其中，xxx代表对应的基本数据类型</strong>。 </p><p>&emsp;&emsp;</p><p>Integer 中的这两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean 中，<font color="red">前面 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True Or False</font>。如果超出对应范围仍然会去创建新的对象</strong>。 </p><p><strong style="color:red">对以上包装类调用 <code>valueOf()</code> 方法会首先尝试从 cache 中获取值，若不能命中，则使用 new 创建对象</strong> 。</p><p>如上面所示 Integer 的 <code>valueOf()</code> 方法中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br></pre></td></tr></table></figure><p>其中 cache 的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br></pre></td></tr></table></figure><p>其在 static 静态块中被初始化（摘取部分代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> j = low;<span class="comment">// low 为 -128</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">    cache[k] = <span class="keyword">new</span> Integer(j++);</span><br></pre></td></tr></table></figure><p>对于 Byte,Short,Long,Character 类似。</p><p><strong>对于 Double、Float 的 <code>valueOf()</code> 则是直接使用 new 创建对象返回</strong>。</p><p>&emsp;&emsp;</p><p>一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6)); <span class="comment">//true   </span></span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Double d1 = <span class="number">1.2</span>;</span><br><span class="line">Double d2 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(d1 == d2);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p><strong style="color:red">使用 <code>==</code> 比较时要注意的点</strong>：</p><ul><li><strong>当 “==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象</strong>；</li><li>如果其中有一个操作数是表达式（<strong>即包含算术运算</strong>）或有一边是基本类型，则比较的是数值（<strong>即会触发自动拆箱的过程</strong>）。<strong>例如对于 i4 == i5 + i6，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40，再将 i4 拆箱，即 <code>40==40</code> </strong>。</li></ul><p>&emsp;&emsp;</p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h3><p>所有包装类（<strong>注意是所有</strong>）的 <code>equals()</code> 方法在进行比较时，<strong>都是先判断参数值是不是当前包装类类型</strong>，</p><ul><li><strong>若不是直接返回 false</strong>。</li><li><strong>若是，则比较两者中封装的 value 成员变量值是否相等</strong>。</li></ul><p>例如对于 Integer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Integer i = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(g.equals(i));<span class="comment">// false ，g 和 i 的类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:red">若是 equlas 传入的参数是基本类型，则会转换为对应的包装类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(g.equals(a+b));<span class="comment">// false</span></span><br><span class="line">    System.out.println(g.equals(<span class="number">3</span>));<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_13-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">javaGuide</a> </p><p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析Java中的装箱和拆箱</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;p&gt;Java&lt;strong&gt;中&lt;/strong&gt;有 8 种基本数据类型，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;6 </summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>总结 equals 和 hashCode</title>
    <link href="http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/equals%E5%92%8ChashCode/"/>
    <id>http://example.com/2021/03/16/Java/%E5%9F%BA%E7%A1%80/equals%E5%92%8ChashCode/</id>
    <published>2021-03-16T03:26:05.349Z</published>
    <updated>2021-03-20T12:06:15.135Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是总结自： <a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a>  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>hashCode()</code> 的作用是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。</p><blockquote><p><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code> ，则一个 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><p>&emsp;&emsp;</p><p><strong>该方法主要是为了支持如 HashSet 、 HashMap 等基于哈希表实现的集合</strong>。</p><p> 也就是说：<strong>hashCode() 在散列表中才有用，在其它情况下没用。</strong>在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><p>讨论 equals() 和 hashCode() 的关系应该分两种情况进行：</p><h2 id="不会创建“类对应的散列表”"><a href="#不会创建“类对应的散列表”" class="headerlink" title="不会创建“类对应的散列表”"></a>不会创建“类对应的散列表”</h2><p><strong>第一种是不会在 HashSet, Hashtable, HashMap 等基于哈希表实现的数据结构中用到该类</strong>，<strong style="color:red">这种情况下 equals() 和 hashCode() 没有关系，如果要比较对象，只需使用 equals() 来进行比较，而并不需要用到 hashCode() </strong>，**所以重写 equals() 时不需要重写 hashCode()**。</p><p>比如只是要比较两个 Person 对象的 name 是否相同，但没有要将其放到 HashSet 等集合，只需重写 equals() 即可，如：</p><p>（来自参考链接）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否类型相同  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    Person person = (Person)obj;  </span><br><span class="line">    <span class="keyword">return</span> name.equals(person.name);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h2 id="会创建“类对应的散列表”"><a href="#会创建“类对应的散列表”" class="headerlink" title="会创建“类对应的散列表”"></a>会创建“类对应的散列表”</h2><p><strong>第二种情况则是会在 HashSet, Hashtable, HashMap 等基于哈希表实现的数据结构中用到该类</strong>。</p><p>这时需要注意两者的关系：</p><ul><li><p><strong>若是两个对象使用 equals() 比较返回 true，那么使用 hashCode() 应该返回相同的哈希值。否则会出现 “ 两个对象是相同的(equals 返回 true)，但却可以放进同一个哈希表 ”  的情况</strong>。</p><blockquote><p>hashCode() 的 javaDoc ：If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</p></blockquote></li><li><p><strong style="color:red">但如果使用 equals() 比较返回 false ，并不要求 hashCode() 返回不同的值</strong>。因为在哈希表中，即使两个哈希值相同（两个 key 相同），它们的值不一定相同（value 不一定相同），这种情况即哈希碰撞。</p><blockquote><p>hashCode() 的 javaDoc ：It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results</p></blockquote><p>一个要注意的点是：<strong>在 HashSet 、 HashMap 等基于哈希表的集合中，若是两个对象使用 equals() 比较返回 false，但 hashCode() 返回相同的值（即产生哈希碰撞时），还是会将两个对象都放进集合（这时会使用哈希碰撞解决方法，如拉链法，红黑树等）</strong>。</p></li></ul><p>&emsp;&emsp;</p><p><strong>所以若是要在哈希表实现的数据结构中使用到某个类，则需要重写这个类的 equals() 和 hashCode() ，并保证它们满足上述关系</strong>。</p><p>示例：（来自参考链接）</p><p>定义 Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; - &quot;</span> +age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象的 name 的大写相同且年龄相同时，返回相同的哈希值</span></span><br><span class="line">        <span class="keyword">int</span> nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">        <span class="keyword">return</span> nameHash ^ age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一个对象返回true，反之返回false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否类型相同</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// name 相同（区分大小写）且年龄相同返回 true </span></span><br><span class="line">        Person person = (Person)obj;</span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建Person对象，</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line">    Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;EEE&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建HashSet对象</span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    set.add(p3);</span><br><span class="line">    set.add(p4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, </span><br><span class="line">                      p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">    <span class="comment">// 比较p1 和 p4， 并打印它们的hashCode()</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;</span>, </span><br><span class="line">                      p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">    <span class="comment">// p1.equals(p2) : true; p1(68545) p2(68545)</span></span><br><span class="line"><span class="comment">// p1.equals(p4) : false; p1(68545) p4(68545)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印set，可以看到 p1 p4 equals返回 false，但 hashcode 相同，所以都被放进集合</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;set:%s\n&quot;</span>, set);</span><br><span class="line">    <span class="comment">// set:[eee - 100, EEE - 100, aaa - 200]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不重写 hashCode() ，那么 p1、p2 都可以被放进 set 。</p><p>&emsp;&emsp;</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_129-hashcode%e4%b8%8e-equals">hashCode() 与 equals()</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章主要是总结自： &lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3324958.html&quot;&gt;Java hashCode() 和 equals()的若干问题解答&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="基础" scheme="http://example.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://example.com/Tag/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://example.com/2021/03/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/"/>
    <id>http://example.com/2021/03/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/</id>
    <published>2021-03-10T16:35:28.790Z</published>
    <updated>2021-03-20T12:06:36.806Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;</p><h2 id="i-i–同步问题"><a href="#i-i–同步问题" class="headerlink" title="i++,i–同步问题"></a>i++,i–同步问题</h2><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123; counter++;</span><br><span class="line">    &#125; &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123; counter--;</span><br><span class="line">    &#125; &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两个线程执行完后，结果是不确定的</strong>。</p><p><strong><font color="red">因为 Java 中对静态变量的自增，自减并不是原子操作</font></strong>，假设i为静态变量，i++，i– 的字节码如下：</p><p>i++：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic<span class="regexp">//</span>获取静态变量</span><br><span class="line">iconst_1<span class="regexp">//</span>准备常量<span class="number">1</span></span><br><span class="line">iadd<span class="regexp">//</span>加操作</span><br><span class="line">putstatic <span class="regexp">//</span>将修改后的值存入静态变量</span><br></pre></td></tr></table></figure><p>i–：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic<span class="regexp">//</span>获取静态变量</span><br><span class="line">iconst_1<span class="regexp">//</span>准备常量<span class="number">1</span></span><br><span class="line">isub<span class="regexp">//</span>减操作</span><br><span class="line">putstatic <span class="regexp">//</span>将修改后的值存入静态变量</span><br></pre></td></tr></table></figure><p><strong>若这 8 条指令不能按顺序执行，则不能保证结果为 0 ，会造成丢失修改，即一个 putstatic 会覆盖掉另一个 putstatic 的结果</strong>。</p><p>&emsp;&emsp;</p><h2 id="synchronized关键字概述"><a href="#synchronized关键字概述" class="headerlink" title="synchronized关键字概述"></a>synchronized关键字概述</h2><blockquote><p><strong>临界区</strong>指的是一个访问共用资源的程序片段，而这些共用资源又无法同时被多个线程线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待。</p><p>竞态条件（Race Condition）：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件。</p></blockquote><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，它是一种互斥锁，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</p><p>&emsp;&emsp;</p><h2 id="synchronized-的内存语义"><a href="#synchronized-的内存语义" class="headerlink" title="synchronized 的内存语义"></a>synchronized 的内存语义</h2><p>synchronized 的这个内存语义就可以解决共享变量内存可见性问题。</p><p>进入和退出 synchronized 块的语义：</p><ul><li><p><strong>进入 synchronized 块</strong>的内存语义是<strong>把在 synchronized 块内使用到的变量从线程的工作内存中清除</strong>， 这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取， 而是直接从主内存中获取。</p></li><li><p><strong>退出 synchronized 块</strong>的内存语义是<strong>把在 synchronized 块内对共享变量的修改刷新到主内存</strong>。</p></li></ul><p><strong>这也是加锁和释放锁的语义</strong>，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁时将本地内存中修改的共享变量刷新到主内存。</p><p>除可以解决共享变量内存可见性问题外， synchronized 经常被用来实现原子性操作。另外要注意，<strong>synchronized关键字会引起线程上下文切换并带来线程调度开销</strong>。</p><p>&emsp;&emsp;</p><h2 id="synchronized-的使用"><a href="#synchronized-的使用" class="headerlink" title="synchronized 的使用"></a>synchronized 的使用</h2><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;  <span class="comment">//obj为要锁定的资源（对象）</span></span><br><span class="line">    ---<span class="comment">//同步代码块（临界区）  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入临界区需要获取指定对象的锁</strong>。</p><h3 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入临界区需要获取方法所属对象的锁</strong>。</p><h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入临界区需要获取当前类的 class 对象的锁</strong>。</p><blockquote><p>synchronized可以修饰方法、代码块，不能修饰构造器、成员变量。</p></blockquote><p>&emsp;&emsp;</p><p>示例，对上述i++，i–问题：多次执行，可保证结果为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.SimpleDemo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h2 id="从字节码看synchronized"><a href="#从字节码看synchronized" class="headerlink" title="从字节码看synchronized"></a>从字节码看synchronized</h2><h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><p>Test类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该类的class文件执行<code>javap -c</code>指令，得到反编译的指令码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   Code:</span><br><span class="line">      0: getstatic     #2                  // （lock引用）进入临界区</span><br><span class="line">      <span class="number">3</span>: dup<span class="comment">// </span></span><br><span class="line">      <span class="number">4</span>: astore_1</span><br><span class="line">      <span class="number">5</span>: monitorenter<span class="comment">// 将lock对象的 MarkWord 置为Monitor指针</span></span><br><span class="line">      6: getstatic     #3                  // Field counter:I</span><br><span class="line">      <span class="number">9</span>: iconst_1</span><br><span class="line">     <span class="number">10</span>: iadd</span><br><span class="line">     11: putstatic     #3                  // Field counter:I</span><br><span class="line">     <span class="number">14</span>: aload_1</span><br><span class="line">     <span class="number">15</span>: monitorexit<span class="comment">// 将lock对象的 MarkWord 重置，唤醒EntryList</span></span><br><span class="line">     <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">     <span class="number">19</span>: astore_2<span class="comment">// 19-23为异常处理指令</span></span><br><span class="line">     <span class="number">20</span>: aload_1</span><br><span class="line">     <span class="number">21</span>: monitorexit <span class="comment">// ----!-----</span></span><br><span class="line">     <span class="number">22</span>: aload_2</span><br><span class="line">     <span class="number">23</span>: athrow</span><br><span class="line">     <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">   Exception table: <span class="comment">//异常表</span></span><br><span class="line">      from    to  target type</span><br><span class="line">          <span class="number">6</span>    <span class="number">16</span>    <span class="number">19</span>   any <span class="comment">// 6-16行的指令发生异常时，调用19行的指令处理异常</span></span><br><span class="line">         <span class="number">19</span>    <span class="number">22</span>    <span class="number">19</span>   any</span><br></pre></td></tr></table></figure><ul><li>synchronized关键字后的临界区代码在字节码中<strong>放在monitorenter和monitorexit之间，对应获取锁，释放锁</strong>。</li><li>且会<strong>对应有一个异常表，用于当执行临界区代码发生异常时，可以保证锁的释放</strong>（异常处理指令中有monitorexit指令）。</li></ul><blockquote><p>方法级别的 synchronized 不会在字节码指令中有所体现</p></blockquote><p>&emsp;&emsp;</p><h3 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h3><p>对于 synchronized 方法（包括实例方法和静态方法），其方法字节码中没有 monitorenter 和 monitorexit ，而是使用一个标志位： <code>0x0020</code> - 对应 <code>ACC_SYNCHRONIZED</code> 。<strong>JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用</strong>。</p><p>例如对于方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Test.info&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其访问标志：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210312193230918.png" alt="image-20210312193230918"></p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>Monitor称为监视器或管程。使用monitor加锁又叫<strong>重量级锁</strong>。</p><blockquote><p>操作系统本身并不支持 monitor 机制，实际上，monitor 是属于编程语言的范畴。</p><p>monitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区，这使得 monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 monitor 临界区的 进程/线程，它们应该被阻塞，并且在必要的时候会被唤醒。</p></blockquote><p>&emsp;&emsp;</p><p>多线程并发状态下，synchronized关键字对对象加锁实际上是将线程关联一个Monitor对象（<strong>Mark Word中包含指向monitor对象的指针</strong>），<strong>只有获取monitor对象的拥有权才能对对象进入临界区（monitor对象的owner指向当前线程）</strong>。</p><p>monitor对象的数据结构如图所示：</p><ul><li><strong>owner</strong>为当前锁拥有者</li><li><strong>EntryList</strong>是阻塞队列，即正在等待锁的进程，线程处于BLOCKED状态。</li><li><strong>WaitSet</strong>中的线程是本来拥有锁的进程，但因一些条件不满足不得已暂停，进入WaitSet，其状态是WAITING。（如调用<code>wait()</code>方法）</li><li>WaitSet的进程由owner进程调用<code>notify()</code>或<code>notifyAll()</code>方法唤醒，<strong>唤醒后进入EntyList参加锁的竞争</strong>。</li><li><strong>WAITING、BLOCKED状态的线程都不会占用cpu</strong>。</li></ul><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210215132033013.png" alt="image-20210215132033013"></p><ul><li>刚开始 Monitor 中 owner为null</li><li>当 Thread-2执行 synchronized(obj)就会将 Monitor的所有者owner置为Thread-2, Monitor中只能有一个Owner</li><li>在 Thread-2上锁的过程中,如果 Thread-3, Thread-4, Thread-5也来执行 synchronized(obj),就会进入<strong>Entrylist BLOCKED（阻塞队列）</strong>。</li><li>Thread-2执行完同步代码块的内容，然后唤醒 Entry List中等待的线程来竟争锁，竞争时是非公平的。</li></ul><p>&emsp;&emsp;</p><blockquote><p>to be done….</p><p><a href="https://www.php.cn/java-article-410323.html">Java中的monitor</a> </p><p><a href="https://blog.csdn.net/wayne566/article/details/107845947#281b3bab-47e9-7ef5-34cb-f8364ca8e376">https://blog.csdn.net/wayne566/article/details/107845947#281b3bab-47e9-7ef5-34cb-f8364ca8e376</a></p></blockquote><p>&emsp;&emsp;</p><h2 id="对象头中的Mark-Word字段"><a href="#对象头中的Mark-Word字段" class="headerlink" title="对象头中的Mark Word字段"></a>对象头中的Mark Word字段</h2><p>HotSpot 虚拟机对象的对象头包含两部分。<strong>第一部分是用于存储对象自身的运行时数据</strong>， 如哈希码(HashCode) 、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（<strong>未开启压缩指针</strong>）中分别为32个比特和64个比特， 官方称它为“<strong>Mark Word</strong>”；<strong>第二部分是类型指针</strong>，指向当前对象所属类的元数据。</p><p>如果是数组对象的话, 对象头还有一部分是存储数组的长度。</p><p>对象需要存储的运行时数据很多，考虑到虚拟机的空间效率， <strong>Mark Word被设计成一个有着动态定义的数据结构，以便根据对象的状态复用自己的存储空间</strong>。</p><p>不同状态的数据结构如下：</p><p>32位JVM的Mark Word不同状态下的结构：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210215171435678.png" alt="image-20210215171435678"></p><p>64位：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210215171452314.png" alt="image-20210215171452314"></p><p>当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p><p>&emsp;&emsp;</p><h2 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h2><p>Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。<strong>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</strong>。</p><blockquote><p>monitor 的实现需要依赖操纵系统，即获得锁、释放锁需要与 OS 交互，效率相对低下。</p></blockquote><p>Java 6 为了减少获得锁和释放锁带来的性能消耗，<strong>引入了“偏向锁”和“轻量级锁“</strong>。在Java 6 以前，所有的锁都是”重量级“锁。所以在 Java 6 及其以后，一<strong>个对象其实有四种锁状态，它们级别由低到高依次是</strong>：</p><ol><li>无锁状态。无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它。</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><blockquote><p>一些文章说是锁可以升级, 但不能降级。在 <a href="http://concurrent.redspider.group/article/02/9.html#922-%E5%81%8F%E5%90%91%E9%94%81">synchronized与锁</a> 中的观点是锁可以降级（Hotspot 支持锁降级）。</p></blockquote><p><strong>几种锁会随着竞争情况逐渐升级</strong>。</p><p>具体见： <a href="http://concurrent.redspider.group/article/02/9.html#922-%E5%81%8F%E5%90%91%E9%94%81">synchronized与锁</a> </p><p>&emsp;&emsp;</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://concurrent.redspider.group/article/02/9.html#922-%E5%81%8F%E5%90%91%E9%94%81">synchronized与锁</a> </p><p><a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">Java6 及以上版本对 synchronized 的优化</a> </p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">Java并发进阶常见面试题总结</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&lt;/p&gt;
&lt;h2 id=&quot;i-i–同步问题&quot;&gt;&lt;a href=&quot;#i-i–同步问题&quot; class=&quot;headerlink&quot; title=&quot;i++,i–同步问题&quot;&gt;&lt;/a&gt;i++,i–同步问题&lt;/h2&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="多线程" scheme="http://example.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java并发" scheme="http://example.com/Tag/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="http://example.com/2021/03/11/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/03/11/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-10T16:33:27.913Z</published>
    <updated>2021-03-10T16:31:11.780Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​        运输层的任务就是<strong>负责向两台主机中进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。由于一台主机可同时运行多个进程，因此运输层有<strong>复用和分用</strong>的功能。<strong>复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程</strong>（<strong>把信息传上去</strong>）。</p><p>​        运输层主要使用以下两种协议：</p><ul><li><strong>传输控制协议TCP</strong>（Transmission Control Protocol） 提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>（segment）。</li><li><strong>用户数据报协议UDP</strong>（User Datagram Protocol）提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是<strong>用户数据报</strong>。</li></ul><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><h3 id="为什么需要运输层"><a href="#为什么需要运输层" class="headerlink" title="为什么需要运输层"></a>为什么需要运输层</h3><p><strong>IP层的IP地址只是标识了两台主机，只能实现两个主机间的通信，而真正进行通信的是两个主机中的实体（进程），运输层通过端口来标识主机中的进程，实现进程间的通信</strong>。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP，User Datagram Protocol，用户数据报协议。</p><p><strong>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能， 这就是复用分用的功能以及差错检测的功能</strong>。UDP的主要特点是：</p><ul><li><strong>无连接</strong>。即发送数据之前不用建立连接。</li><li>UDP使用<strong>尽最大努力交付</strong>。</li><li>UDP是<strong>面向报文</strong>的。即应用层交下来的报文，UDP既不合并，也不拆分，只加上UDP首部后直接发送；相应的，接收时去除首部后直接上交应用层。</li><li><strong>没有拥塞控制</strong>。即网络的拥塞不会使源主机发送速率降低。但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信）</li><li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li>首部开销小，8B。</li></ul><h3 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h3><p>TCP，Transmission Control Protocol，传输控制协议。</p><p>TCP的主要特点：</p><ul><li><strong>面向连接</strong>。即使用tcp之前（通信之前）需要建立可靠连接，通信完毕后释放连接。</li><li>每一个TCP连接<strong>只能有两个端点</strong>。<ul><li>TCP连接的端点叫做<strong>套接字（socket）</strong>，一个套接字<strong>由<code>IP地址:端口号</code>组成</strong>。<strong>一个TCP连接由两个套接字唯一确定</strong>。</li></ul></li><li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据， <strong>无差错、不丢失、不重复，并且按序到达</strong>。</li><li>TCP提供<strong>全双工通信</strong>。TCP允许<strong>通信双方的应用进程在任何时候都能发送数据</strong>。<ul><li><strong style="color:red">TCP连接的两端都设有发送缓存和接收缓存， 用来临时存放双向通信的数据</strong>。<strong>在发送时，应用程序在把数据传送给TCP的缓存后， 就可以做自己的事， 而TCP在合适的时候把数据发送出去。在接收时， TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</strong>。</li></ul></li><li><strong>面向字节流</strong>。<strong style="color:red">TCP中的“流”(stream) 指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块(<strong>大小不等</strong>) ， 但TCP把应用程序交下来的数据<strong>仅仅看成是一连串的无结构的字节流</strong>。TCP并不知道所传送的字节流的含义。TCP<strong>不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</strong>。<strong>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</strong>。</li></ul><h3 id="TCP可靠传输原理"><a href="#TCP可靠传输原理" class="headerlink" title="TCP可靠传输原理"></a>TCP可靠传输原理</h3><p>（来自JavaGuide）</p><p>概述：</p><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待协议的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组</strong>。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 简单</li><li><strong>缺点：</strong> 信道利用率低，等待时间长</li></ul><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就<strong>重传前面发送过的分组</strong>（认为刚才发送过的分组丢失了）。因此<strong>每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些</strong>。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。</p><p><strong>若收到重复分组，就丢弃该分组，但同时还要发送确认</strong>。<strong>连续 ARQ 协议</strong> 可提高信道利用率。</p><p><strong>3) 确认丢失和确认迟到</strong>                   </p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下<strong>两点措施</strong>：<strong>1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。</strong> </li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。<strong>处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1</strong>。</li></ul><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。<strong>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</strong>。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> <strong>不能向发送方反映出接收方已经正确收到的所有分组的信息</strong>。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul><h4 id="滑动窗口实现流量控制"><a href="#滑动窗口实现流量控制" class="headerlink" title="滑动窗口实现流量控制"></a>滑动窗口实现流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率</strong>。将窗口字段设置为 0，则发送方不能发送数据。</p><p>​    </p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫<strong>拥塞</strong>。<strong>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载</strong>。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><blockquote><p>cwnd指拥塞窗口长度</p></blockquote><ul><li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是<strong>先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。<strong>每当出现超时的时候重新开始发送时即使用慢开始</strong>。</p></li><li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是<strong>让拥塞窗口cwnd缓慢增大</strong>，即每经过一个往返时间RTT就把发送放的cwnd加1。</p></li><li><p><strong>快重传与快恢复（fast retransmit and recovery，FRR）</strong>：采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。<strong>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认（这里已收到的报文段是指失序段之前的报文段）</strong>。</p><p>如图（来自《计算机网络》所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3；但却收到了M4。本来接收方可以什么都不做。<strong>但按照快重传算法，接收方必须立即发送对M2的重复确认（注意是M2）</strong>，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送Ms和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M的确认，其中后3个都是重复确认。<strong>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞</strong>。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210307172719911.png" alt="image-20210307172719911"></p><p>相应的，<strong>发送方知道只是丢失个别报文段，重新发送数据时不会启动慢开始，而是执行快恢复算法，即适当调整cwnd大小</strong>（如除以2），并执行拥塞避免。</p></li></ul><h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308171503072.png" alt="image-20210308171503072"></p><p>其中部分字段含义：</p><ul><li>序号（seq）。TCP 是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。<strong>序号字段值指的是本报文段所发送的数据的第一个字节的序号</strong>。</li><li>确认号（ack）。<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为 N ，则标识序号 1 ~ N-1 的字节都已正确收到。</li><li>确认 ACK （控制位） 。<strong>仅当ACK=1时确认号字段才有效</strong>。当ACK=0时， 确认号无效。TCP规定，<strong>在连接建立后所有传送的报文段都必须把ACK置1</strong>。</li><li>同步 SYN （控制位）。<strong>在连接建立时用来同步序号</strong>。<strong>当SYN=1而ACK=0时，表明这是一个连接请求报文段</strong>。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此， <strong>SYN置为1就表示这是一个连接请求或连接接受报文</strong>。</li><li>终止 FIN （控制位）。用来释放一个连接。<strong>当FIN=1时， 表明此报文段的发送方的数据已发送完毕，并要求释放运输连接</strong>。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>《计算机网络 第7版》中称为“三报文握手”。</p><p>图片来自《计算机网络 第7版》</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308162534931.png" alt="image-20210308162534931"></p><p> A 为客户端，B 为服务器端。</p><blockquote><p>ack 指确认号字段，ACK 是6个控制位之一。</p></blockquote><ul><li><strong>首先 B 处于 LISTEN（监听）状态</strong>，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，（同步字段）SYN=1，（ACK=0），<strong>选择一个初始的序号 x</strong>，即 <code>SYN=1, seq=x</code> 。</li><li>B 收到连接请求报文，<strong>如果同意建立连接，则向 A 发送连接确认报文</strong>，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。即 <code>SYN=1, ACK=1, seq=y, ack=x+1</code> 。</li><li><strong>A 收到 B 的连接确认报文后，还要向 B 发出确认</strong>，确认号为 y+1，序号为 x+1。即 <code>ACK=1, ack=y+1, seq=x+1</code> 。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong style="color:red">为什么需要最后一次握手（确认）？</strong> </p><p><strong>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</strong>。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，<strong>如果不进行三次握手</strong>，那么服务器就会打开两个连接。<strong>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，服务器接不到确认也就不会打开连接</strong>。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="E:\TyporaImage\image-20210308164017342.png" alt="image-20210308164017342"></p><ul><li>A 发送连接释放报文，FIN=1，并停止发送数据。 <code>FIN=1, seq=u</code> 。<strong>A进入“终止等待状态1”</strong>。</li><li>B 收到之后发出确认：<code>ACK=1, ack=u+1, seq=v</code> 。<strong>此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</strong>，即从 A -》B 这个方向的连接释放了。<strong>此时 B 进入“关闭等待”状态</strong></li><li>A收到确认后，<strong>进入“终止等待状态2”。等待B的连接释放报文段</strong>。</li><li><strong>B 发出确认后会发送还没发送完的数据</strong>，当 B 已经没有要向 A 发送的数据时，<strong>发送连接释放报文，FIN=1</strong>。 <code>FIN=1, ACK=1, seq=w, ack=u+1</code> 。<strong>B 进入“最后确认”状态</strong>。</li><li>A 收到后发出确认： <code>ACK=1, seq=u+1, ack=w+1</code> ，<strong>进入 TIME-WAIT （时间等待）状态，此时连接还没有释放，A 会等待 2 MSL（Maximum Segment Lifetime，最大报文存活时间）后释放连接</strong>。</li><li><strong>B 收到 A 的确认后释放连接</strong>。</li></ul><p>客户端接收到服务器端的 FIN 报文后还需要等待一个时间计时器设置的时间 2MSL。<strong>这么做有两个理由</strong>：</p><ul><li><strong>确保最后一个确认报文能够到达</strong>。如果 B 没收到 A 发送来的确认报文，会超时重传连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生，这时 A 会重新发送确认报文，<strong>并将计时重新设置为 2 MSL</strong>。</li><li>等待一段时间是为了<strong>让本连接持续时间内所产生的所有报文都从网络中消失使得下一个新的连接不会出现旧的连接请求报文，如已失效的连接请求报文段</strong>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html">运输层</a> </p><p>《计算机网络 第7版》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&lt;/p&gt;
&lt;h2 id=&quot;运输层&quot;&gt;&lt;a href=&quot;#运输层&quot; class=&quot;headerlink&quot; title=&quot;运输层&quot;&gt;&lt;/a&gt;运输层&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/Tag/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://example.com/2021/03/05/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(to%20be..)/"/>
    <id>http://example.com/2021/03/05/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(to%20be..)/</id>
    <published>2021-03-05T06:25:56.673Z</published>
    <updated>2021-03-20T12:07:13.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="class文件结构概述"><a href="#class文件结构概述" class="headerlink" title="class文件结构概述"></a>class文件结构概述</h2><p><strong>Class文件是一组<font color="red">以字节为基础单位</font>的二进制流， 各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</strong>，当遇到需要占用单个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个字节进行存储。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，<strong>这种伪结构中只有两种数据类型</strong>：<strong>“无符号数”和“表”</strong>。</p><ul><li>无符号数属于基本的数据类型，以<strong><font color="red">ul、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数</font></strong>，无符号数<strong>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</strong>。</li><li><strong>表是由多个无符号数或者其他表作为数据项构成的复合数据类型</strong>，表的命名习惯以“info”结尾。表用于描述有层次关系的复合结构的数据。</li></ul><p>整个Class文件本质上也可以视作是一张表， 这张表由下图所示的数据项按严格顺序排列构成。<strong>该格式中的数据项，无论是顺序还是数量，都是被严格限定的</strong>。(【】内表示数量，第一列表示数据类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;【<span class="number">1</span>】 <span class="comment">//Class文件的标志（魔数）</span></span><br><span class="line">    u2             minor_version;【<span class="number">1</span>】<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;【<span class="number">1</span>】<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool【constant_pool_count-<span class="number">1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br><span class="line">    u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;【<span class="number">1</span>】<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;【<span class="number">1</span>】<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;【<span class="number">1</span>】<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces;【interfaces_count】<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;【<span class="number">1</span>】<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields;【fields_count】<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;【<span class="number">1</span>】<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods;【methods_count】<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;【<span class="number">1</span>】<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes;【attributes_count】<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class文件中，<strong>当需要描述同一类型但数量不定的多个数据项时，使用一个前置的容量计数器（u2无符号数，即两个字节）加若干个连续的数据项的形式来表示</strong>。</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure><p>每个Class文件的头4个字节称为魔数，用于<strong>标志这是一个能被JVM接受的class文件</strong>。其值为<code>0xCAFEBABE</code>。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version<span class="comment">;【1】</span></span><br><span class="line">u2             major_version<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure><p><strong>紧接的4个字节是class文件的版本号，第5、6为次版本号（Minor Version），第7、8为主版本号（Major Version）</strong>。</p><p><strong>高版本的 Java 虚拟机可以向下兼容执行低版本编译器生成的 Class 文件</strong>，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p><blockquote><p>jdk1.1对应45（十进制），往上依次递增1。如jdk1.8对应52（0x34）</p></blockquote><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool【constant_pool_count<span class="number">-1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br></pre></td></tr></table></figure><p>紧接着主、次版本号之后的是常量池， <strong>常量池可以比喻为Class文件里的资源仓库， 它是Class文件结构中与其他项目关联最多的数据</strong>。</p><p><strong>常量池中常量的数量是不固定的</strong>。constant_pool_count指定常量数量。<strong>这个容量计数是从1而不是0开始的</strong>，例如，若是0x0018（十进制24），即表示有24-1=23个常量。<strong>将第0项常量空出来的目的在于</strong>：<strong><font color="red">如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义， 可以把索引值设置为0来表示</font></strong>。</p><p>对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。</p><p>常量池中主要存放两大类常量：<strong>字面量和符号引用</strong>。</p><ul><li>字面量比较接近于Java语言层面的常量概念， 如文本字符串、被声明为final的常量值等。</li><li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul><li>被模块导出或者开放的包</li><li><strong>类和接口的全限定名</strong> </li><li>**字段的名称和描述符 ** </li><li><strong>方法的名称和描述符</strong> </li><li>方法句柄和方法类型</li><li>动态调用点和动态常量</li></ul></li></ul><blockquote><p>Java代码在进行Javac编译的时候， 并不像C和C++那样有“连接”这一步骤， 而是<strong>在虚拟机加载Class文件的时候进行动态连接</strong>的 。也就是说， <strong>在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存人口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</strong>。</p></blockquote><p>常量池中每一项常量都是一个表，<strong>截至JDK13</strong>， 常量表中分别有17种不同类型的常量。<strong>这些表都有一个共同的特点， 表结构起始的第一位是个u1类型的标志位</strong>(tag， 见下表标志列)，代表着当前常量属于哪种常量类型。17种类型如下表：</p><table><thead><tr><th>类型</th><th>标志（tag）</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>５</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>６</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>７</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>８</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>９</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MothodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>17</td><td>表示一个动态计算常量</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr><tr><td>CONSTANT_Module_info</td><td>19</td><td>表示一个模块</td></tr><tr><td>CONSTANT_Package_info</td><td>20</td><td>表示一个模块中开发或者导出的包</td></tr></tbody></table><p>常见的11种类型的结构表：（index表示指向第几个常量项）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125112646190.png" alt="image-20210125112646190"></p><blockquote><p>在读取常量池时，只要读取每个项的第一个字节（tag）就可得知其类型，得知其类型后就能知道该项占多少字节，也就可以知道下一项从哪里开始，以此类推。</p></blockquote><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure><p>常量池结束之后紧接着的两个字节代表<strong>访问标志</strong>，这个标志用于识别一些类或者接口层次的访问信息，即一个类或接口使用了哪些访问修饰符（public、abstract等）。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125113620989.png" alt="image-20210125113620989"></p><p>一个类或接口可拥有多个标志，<strong>这时标志值应该为这多个标志值取或</strong>。如 ACC_PUBLIC | ACC_SUPER = 0x0021。</p><h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><pre><code>u2             this_class;【1】//当前类u2             super_class;【1】//父类u2             interfaces_count;【1】//接口数量u2             interfaces;【interfaces_count】//一个类可以实现多个接口</code></pre><p>类索引和父类索引都是一个u2类型的数据， 而接口索引集合是一组u2类型的数据的集合， Class文件中<strong>由这三项数据来确定该类型的继承关系</strong>。</p><ul><li><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名</strong>。Java不允许多继承， 所以父类索引只有一个， 除了java.lang.Object之外， 所有的Java类都有父类， 因此除了java.lang.Object外， 所有Java类的父类索引都不为0。<strong>这是两个索引值，指向常量池的对应项</strong>。</p></li><li><p><strong>接口索引集合</strong>描述这个类实现了哪些接口，集合第一个项是接口计数器，之后是对应数量的接口索引（若计数器为0则不再占用任何字节）。<strong>这些接口索引将按implements关键字（如果该Class文件表示接口， 则是extends）后的接口顺序从左到右排列在接口索引集合中</strong>。</p></li></ul><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><pre><code>u2             fields_count;【1】//Class 文件的字段属性field_info     fields;【fields_count】//一个类会可以有多个字段</code></pre><p>字段表用于描述接口或类中声明的变量。字段<strong>包括类级变量以及实例变量</strong>，但<strong>不包括在方法内部声明的局部变量</strong>。</p><p>一个字段表的结构（来自javaGuide）：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p><p>各字段解释：</p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ，<code>private</code>，<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符），可否被序列化（transient 修饰符），可变性（final），可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> <strong>对常量池的引用</strong>，表示的字段的简单名称；</li><li><strong>descriptor_index:</strong> <strong>对常量池的引用</strong>，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，<strong>适合使用标志位来表示。而字段叫什么名字、字段数据类型都是无法固定的，只能引用常量池中常量来描述</strong>。</p><p><strong>字段表中不会列出继承自父类或父接口的字段</strong>。</p><blockquote><p>关于描述符：描述符用来描述<strong>字段的数据类型</strong>，或方<strong>法的参数列表（包括数量、类型和顺序）和返回值</strong>。基本数据类型以及无返回值void都用一个大写字符表示，对应关系：</p><ul><li>B- byte， C-char， D- double， F- float， I- int， J- long， s- short， z-boolean， v- void， L-对象类型，如Ljava.lang.String</li><li>对于数组，一个维度对应一个 <code>[</code>， + L + 元素类型，如<code>[[I，[[Ljava.lang.String</code>。</li></ul><p>描述符描述方法时，<strong>按照先参数列表后返回值的顺序</strong>，如<code>()V 、(I)Ljava.lang.String</code>。</p></blockquote><p>access_flags表示访问标志，即字段的修饰符，其取值如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150405202.png" alt="image-20210125150405202"></p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><pre><code>u2             methods_count;【1】method_info    methods;【methods_count】</code></pre><p>分别表示方法数量和方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构与字段表一样，如下：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p><p><strong>Java方法里的代码，经Javac编译成字节码之后，放在方法属性表集合中一个名为“Code”的属性里面</strong>。</p><p>标志位取值：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125173337287.png" alt="image-20210125173337287"></p><blockquote><p>synchronized关键字 的字节码相关： P46</p></blockquote><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="regexp">//</span>此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];<span class="regexp">//</span>属性表集合</span><br></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="一些常见属性"><a href="#一些常见属性" class="headerlink" title="一些常见属性"></a>一些常见属性</h3><p>1.<strong>Code属性</strong> </p><p>结构：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125174146152.png" alt="image-20210125174146152" style="zoom:80%;" /><ul><li><p>attribute_length表示attribute所包含的字节数，不包含 attribute name index和attribute length字段。</p></li><li><p>max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度</p></li><li><p>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量</p></li></ul><p>2.<strong>LineNumberTable</strong>属性</p><p>用于表示Code中的字节码与源码的行号对应关系（一行对应一个指令）</p><p>3.LocalVariableTable</p><p>局部变量表，记录局部变量信息，其中的变量名等会引用常量池中的utf8字符串常量。</p><p><strong>对于实例方法，在class文件中，每个方法内至少会有一个局部变量：this，即所属对象的引用</strong></p><h2 id="To-be-continue"><a href="#To-be-continue" class="headerlink" title="To be continue"></a>To be continue</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>《深入理解JVM》</p><p><a href="https://snailclimb.gitee.io/javaguide/#/?id=java">JavaGuide文档</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;class文件结构概述&quot;&gt;&lt;a href=&quot;#class文件结构概述&quot; class=&quot;headerlink&quot; title=&quot;class文件结构概述&quot;&gt;&lt;/a&gt;class文件结构概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Class文件是一组&lt;font color=&quot;red</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/Tag/JVM/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-03T16:01:09.711Z</published>
    <updated>2021-03-03T16:00:39.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>定义：<strong>在当前进程中，通过单例模式创建的类有且只有一个实例</strong>。</p><p>单例有如下几个特点：</p><ul><li>在Java应用中，单例模式<strong>需要保证在一个JVM中，该对象只有一个实例存在</strong>。</li><li><strong>构造器必须是私有的</strong>，外部类无法通过调用构造器方法创建该实例。</li><li><strong>没有公开的set方法</strong>，外部类无法调用set方法创建该实例。</li><li>提供一个公开的get方法获取唯一的这个实例。</li></ul><p>单例模式的好处：</p><ul><li>某些类创建比较频繁，<strong>对于一些大型的对象，节省很大的系统开销</strong>。</li><li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li><li>系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个，会造成系统混乱。</li><li>避免了对资源的重复占用</li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在<strong>程序启动或单例模式类被首次主动使用的时候</strong>，单例模式实例被创建。<strong>总之，饿汉式体现的是想提前把对象创建好</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式没有线程安全问题，instance是在Singleton类初始化时创建的，JVM可以保证线程安全。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式单例在第一次调用getInstance才创建实例。</p><h3 id="线程不安全实现"><a href="#线程不安全实现" class="headerlink" title="线程不安全实现"></a>线程不安全实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Singleton2.getInstance());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行多次，可以看到获取对象不是同一个。</p><p><strong>应用场景</strong>：如果这个数据是经常访问的热点数据，那我就可以在系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了；反之，数据使用频率较低，则使用懒汉式，避免资源浪费。</p><h3 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h3><p>getInstance加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样能保证线程安全，但是<strong>效率过低，实例被创建后调用getInstance依然需要加锁</strong>。</p><p>通过双检锁（double-checked）做两次判断优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意INSTANCE需要加上<code>volatile</code>关键字，避免指令重排序问题</strong>。<code>INSTANCE = new Singleton();</code>并不是原子操作，JVM可能会先执行赋值操作再执行初始化操作，</p><p>没加volatile时线程不安全的情况：</p><ul><li>A、B同时进入第一个if。</li><li>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</li><li>由于JVM内部的优化机制，JVM可能会<strong style="color:red">先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块</strong>。</li><li>随后B进入synchronized块，由于instance此时不是null，<strong>因此它马上离开了synchronized块并将结果返回给调用该方法的程序</strong>。</li><li>此时若B线程马上使用Singleton实例，<strong>却发现它没有被初始化，于是错误发生了</strong>。</li></ul><p>缺点：<strong>由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高</strong>。</p><p>可以使用静态内部类实现。</p><h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>使用内部类来维护单例的实现，<strong>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的</strong>。</p><h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举来实现单实例控制会更加<strong>简洁，而且JVM从根本上提供保障，绝对防止多次实例化</strong>，是更简洁、高效、安全的实现单例的方式。</p><h2 id="为什么不用静态方法而用单例模式？"><a href="#为什么不用静态方法而用单例模式？" class="headerlink" title="为什么不用静态方法而用单例模式？"></a>为什么不用静态方法而用单例模式？</h2><p>（来自参考连接）</p><p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，<strong>面向对象的代码提供一个更好的编程思想</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>原文：<a href="https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ">设计模式系列 - 单例模式</a> </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;定义：&lt;strong&gt;在当前进程中，通过单例模式创建的类有且只有一个实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;单例有如下几个特点：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML类图六种关系</title>
    <link href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/"/>
    <id>http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/</id>
    <published>2021-03-03T16:01:09.700Z</published>
    <updated>2021-03-03T16:00:56.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UML类图用于<strong>描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</strong>。 </p><p>类之间的关系有：<strong>泛化（继承）、实现、关联、聚合、组合、依赖</strong>。</p><p>六种关系的耦合度大小是：<strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong>。</p><h2 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h2><p>泛化就是指继承关系。</p><p>代码体现：子类继承父类。</p><p>UML符号：<strong>实线+空心箭头，箭头指向父类</strong> </p><p>如图：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022222623274.png" alt="image-20201022222623274"></p><h2 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h2><p>实现关系即实现类实现接口。</p><p>代码体现：A类实现B接口。</p><p>UML符号：<strong>一条虚线+空心箭头</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022224009475.png" alt="image-20201022224009475" style="zoom:67%;" /><h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>关联关系指<strong>类和类之间的联系，如一对一、一对多、多对多。其中有单向关联，双向关联。</strong> </p><p>代码体现：成员变量</p><p>UML符号：<strong>双向关联，一条实线或一条实线+两个箭头；单向关联，一条实线+一个箭头</strong> </p><p>一对一</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225341448.png" alt="image-20201022225341448" style="zoom:67%;" /><p>其他：（图片来自<a href="https://www.zhihu.com/question/419192424/answer/1471808645%EF%BC%89">https://www.zhihu.com/question/419192424/answer/1471808645）</a></p><p><img src="https://pic2.zhimg.com/80/v2-b880e61921fcc252b58a2a8da1baf368_720w.jpg?source=1940ef5c"></p><h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>聚合关系（Aggregation）表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开，即部分能脱离整体而独立存在</strong>。</p><p>代码体现：成员变量</p><p>UML符号：<strong>一条实线+空心菱形</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225828143.png" alt="image-20201022225828143" style="zoom:67%;" /><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>组合也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开，部分不能脱离整体而独立存在</strong>。</p><p>代码体现：成员变量</p><p>UML符号：<strong>一条实线+实心菱形</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230156462.png" alt="image-20201022230156462" style="zoom:67%;" /><h2 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h2><p>是一种使用关系，一个类的实现需要另一个类的协助。即在一个类中使用了另外一个类。<strong>尽量不要使用双向依赖。以上关系都是依赖关系的特例</strong>。</p><p>代码体现：局部变量、方法的参数或者对静态方法的调用。</p><p>UML符号：<strong>一条虚线+箭头</strong> </p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230737289.png" alt="image-20201022230737289" style="zoom:67%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/vic_/p/8057851.html">https://www.cnblogs.com/vic_/p/8057851.html</a></p><p><a href="https://www.zhihu.com/question/419192424/answer/1471808645">https://www.zhihu.com/question/419192424/answer/1471808645</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;UML类图用于&lt;strong&gt;描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;类之间的关</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式七大基本原则</title>
    <link href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2021-03-03T16:00:06.237Z</published>
    <updated>2021-03-03T15:59:54.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式的七大原则如下：</p><ul><li>单一职责原则 (Single Responsibility Principle)</li><li>接口隔离原则 (Interface Segregation Principle)</li><li>开放-关闭原则 (Open-Closed Principle)</li><li>里氏替换原则 (Liskov Substitution Principle)</li><li>依赖倒转原则 (Dependence Inversion Principle)</li><li>迪米特法则（Law Of Demeter）</li><li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li></ul><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>通俗地说，单一职责原则即<strong>一个类只负责一项职责（不是只有一个方法）</strong>。</p><p>假设某个类 P 负责两个不同的职责：职责 P1 和 职责 P2，那么当职责 P1 需求发生改变而需要修改类 P，有可能会导致原来运行正常的职责 P2 功能发生故障。</p><p>在实际编程中比较难严格的遵守该原则，可以作一些折中处理，比如若是一个类中方法个数比较少，可以在方法级别上遵守该原则（此时在类级别上可能不遵守）。<strong>只有逻辑足够简单，才可以在代码级别上违背单一职责原则</strong>。</p><p>单一职责原则的作用和细节：</p><ul><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ul><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>接口隔离原则指：<strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</strong>：</p><p>被依赖的类实现一个接口，就需要实现接口的所有方法，但这个类在被使用时可能只用到其中部分方法。也就是只要接口中出现的方法，不管依赖于它的类是否需要该方法，实现类都必须去实现这些方法，这就不符合接口隔离原则。可以对接口进行拆分，让实现类只实现需要的接口。</p><p>示例（见来自<a href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89%EF%BC%9A">https://zhuanlan.zhihu.com/p/24614363）：</a></p><img src="https://pic4.zhimg.com/80/v2-ec9b282b367e9c148a7963b5b23c60e7_720w.png" style="zoom:80%;" /><p>类 A 依赖于 接口 I 中的方法 1，2，3 ，类 B 是对类 A 的具体实现。类 C 依赖接口 I 中的方法 1，4，5，类 D 是对类 C 的具体实现。对于类B和类D来说，<strong>虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。</strong> </p><p>用代码表示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line"> <span class="comment">// 类 B 只需要实现方法 1，2, 3，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line"><span class="comment">// 类 D 只需要实现方法 1，4，5，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        A a = <span class="keyword">new</span> A();  </span><br><span class="line">        a.depend1(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());  </span><br><span class="line">          </span><br><span class="line">        C c = <span class="keyword">new</span> C();  </span><br><span class="line">        c.depend1(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend2(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend3(<span class="keyword">new</span> D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对接口根据下图进行拆分：</p><img src="https://pic3.zhimg.com/80/v2-7611098e41bcfbf5113d978b47fc8466_720w.png" style="zoom:80%;" /><p>代码可修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><strong>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</strong>。</li><li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li></ol><h2 id="依赖倒转原则（DIP）"><a href="#依赖倒转原则（DIP）" class="headerlink" title="依赖倒转原则（DIP）"></a>依赖倒转原则（DIP）</h2><p>定义：<strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象</strong>。进一步说，<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。<strong>依赖倒转原则的核心思想就是面向接口编程</strong>。</p><p>依赖倒转原则是基于这样的设计理念：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给实现类去完成。</p><p>示例：（来自<a href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89">https://zhuanlan.zhihu.com/p/24614363）</a></p><p>一个场景：母亲给孩子讲故事，只要给她一本书，她就可照着书给孩子讲故事了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Book book)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(book.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>假如有一天，给的是一份报纸，而不是一本书，让这个母亲讲下报纸上的故事，报纸的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>显然这个母亲完成不了这个任务。只有将Mother类中的Book换成Newspaper才能完成</strong>。但若是以后换成杂志等其他读物，又得进行修改。原因是 Mother 和 Book之间的耦合度太高了。<strong>可以引入一个抽象接口 IReader表示读物，让书和报纸去实现这个接口，那么无论提供什么样的读物，该母亲都能读</strong>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(IReader reader)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(reader.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Mother类代表高层模块，读物相关的类则代表低层模块，在修改示例之前，是高层依赖于低层代码，Mother类要按着Book类来；修改后则符合依赖倒转原则，低层的读物依着高层的Mother来。</p><p><strong>实际情况中，代表高层模块的 Mother 类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒转原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险</strong>。</p><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p><strong>面向对象中继承性的问题</strong>：有一功能 P1, 由类 A 完成，现需要将功能 P1 进行扩展，扩展后的功能为 P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则<strong>子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障</strong>。</p><p>里氏替换原则：</p><ul><li><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li><li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法</strong>。</li><li><strong>子类中尽量不要重写父类的方法</strong>。</li></ul><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而<strong>里氏替换原则就是表达了这一层含义</strong>。</p><p>根据该原则，对于上述的继承性问题：当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能 P2，尽量不要修改父类方法预期的行为。</p><h2 id="开放-关闭原则（OCP）"><a href="#开放-关闭原则（OCP）" class="headerlink" title="开放-关闭原则（OCP）"></a>开放-关闭原则（OCP）</h2><p>**开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改。(Open for extension, close for modification，对扩展开放，对修改关闭)**。</p><p>一个软件满足 OCP 原则后的两项优点：</p><ol><li><strong>能够扩展已存在的系统</strong>，能够提供新的功能满足新的需求，因此该软件有着很强的适应性和灵活性。</li><li>已存在的模块，特别是那些重要的抽象模块，不需要被修改，那么该软件就有很强的稳定性和持久性。</li></ol><p>示例：</p><p>有个生产电脑的公司，根据输入的类型，生产出不同的电脑，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Computer c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;macbook&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Macbook();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;surface&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Surface();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然上面的代码违背了开放 - 关闭原则，<strong>如果需要添加新的电脑产品，需要修改 produceComputer 原本已有的方法</strong>，正确的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Macbook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MSFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Surface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方式应该是将 Factory 抽象成接口，让具体的工厂(如苹果工厂，微软工厂)去实现它，生产它们公司相应的产品，这样写有利于扩展，如果这是需要新增加戴尔工厂生产戴尔电脑，我们仅仅需要创建新的电脑类和新的工厂类，而不需要去修改已经写好的代码。</p><p>总结：</p><ol><li><strong>OCP 可以具有良好的可扩展性，可维护性</strong>。</li><li><strong>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它</strong>。</li></ol><h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><p>迪米特法则又称为<strong>最少知道原则</strong>，它表示<strong>一个对象应该对其它对象保持最少的了解</strong>。**<font color="red">通俗来说就是，只与直接的朋友通信</font>**。</p><p><strong>什么是直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，<strong>称出现在成员变量、方法参数、方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类则不是直接的朋友</strong>。根据迪米特法则，**<font color="red">陌生的类最好不要作为局部变量的形式出现在类的内部</font>**。</p><p><strong>对于被依赖的类来说，无论逻辑多么复杂，都尽量的将逻辑封装在类的内部，对外提供 public 方法，不对泄漏任何信息</strong>。</p><p>示例：</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个 SchoolManager 对象 </span></span><br><span class="line">    SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager(); </span><br><span class="line">    <span class="comment">//输出学院员工id和学校员工id</span></span><br><span class="line">    schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学校员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工管理类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回学院的所有员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;CollegeEmployee&gt; list = newArrayList&lt;CollegeEmployee&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="comment">//这里我们增加了 10 个员工到 </span></span><br><span class="line">            list CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回所有学校员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;Employee&gt; list = newArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">            list Employee emp = <span class="keyword">new</span> Employee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">&#125; </span><br><span class="line">        <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到SchoolManager的printAllEmployee方法中，<strong>CollegeEmployee并不是SchoolManager的直接朋友，不符合迪米特法则</strong>。</p><p>可以将打印CollegeEmployee部分的代码封装进CollegeManager中：</p><p>CollegeManager中添加新的public方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">    List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而可以在SchoolManager中通过CollegeManager调用该方法来打印所有学院员工id，SchoolManager.printAllEmployee方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">sub.printEmployee();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">    List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-聚合复用原则（CRP）"><a href="#组合-聚合复用原则（CRP）" class="headerlink" title="组合/聚合复用原则（CRP）"></a>组合/聚合复用原则（CRP）</h2><p>组合/聚合复用原则指的是<strong>在实际开发设计中，尽量使用组合/聚合，不要使用类继承</strong>。</p><p>在面向对象的设计中，<strong>如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类，如果基类的实现发生了改变，则子类的实现也不得不改变</strong>。</p><ul><li><p>总体说来，组合或者聚合好过于继承。</p></li><li><p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24614363">https://zhuanlan.zhihu.com/p/24614363</a></p><p><a href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;设计模式的七大原则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则 (Single Responsibility Principle)&lt;/li</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/Tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷键大全</title>
    <link href="http://example.com/2021/02/25/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>http://example.com/2021/02/25/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</id>
    <published>2021-02-24T16:26:06.369Z</published>
    <updated>2021-02-24T16:28:01.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下绝大部分copy自：<a href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p></blockquote><h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><strong><span style="color:red;">Ctrl + F</span></strong></td><td align="left">在当前文件进行文本查找 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + R</td><td align="left">在当前文件进行文本替换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Z</td><td align="left">撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Y</td><td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + X</td><td align="left">剪切光标所在行 或 剪切选择内容</td></tr><tr><td align="left">Ctrl + C</td><td align="left">复制光标所在行 或 复制选择内容</td></tr><tr><td align="left">Ctrl + D</td><td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + W</td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + E</td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left">Ctrl + N</td><td align="left">根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td align="left">Ctrl + G</td><td align="left">在当前文件跳转到指定行处</td></tr><tr><td align="left">Ctrl + J</td><td align="left">插入自定义动态代码模板</td></tr><tr><td align="left">Ctrl + P</td><td align="left">方法参数提示显示</td></tr><tr><td align="left">Ctrl + Q</td><td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td align="left">Ctrl + U</td><td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td align="left">Ctrl + B</td><td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td align="left">Ctrl + K</td><td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + T</td><td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left"><strong>Ctrl + H</strong></td><td align="left"><strong>显示当前类的层次结构</strong></td></tr><tr><td align="left">Ctrl + O</td><td align="left">选择可重写的方法</td></tr><tr><td align="left">Ctrl + I</td><td align="left">选择可继承的方法</td></tr><tr><td align="left">Ctrl + +</td><td align="left">展开代码</td></tr><tr><td align="left">Ctrl + -</td><td align="left">折叠代码</td></tr><tr><td align="left">Ctrl + /</td><td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + [</td><td align="left">移动光标到当前所在代码的花括号开始位置</td></tr><tr><td align="left">Ctrl + ]</td><td align="left">移动光标到当前所在代码的花括号结束位置</td></tr><tr><td align="left">Ctrl + F1</td><td align="left">在光标所在的错误代码出显示错误信息</td></tr><tr><td align="left">Ctrl + F3</td><td align="left">调转到所选中的词的下一个引用位置</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭当前编辑文件</td></tr><tr><td align="left">Ctrl + F8</td><td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td align="left">Ctrl + F9</td><td align="left">执行 Make Project 操作</td></tr><tr><td align="left">Ctrl + F11</td><td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td align="left">Ctrl + F12</td><td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td align="left">Ctrl + Enter</td><td align="left">智能分隔行</td></tr><tr><td align="left">Ctrl + End</td><td align="left">跳到文件尾</td></tr><tr><td align="left">Ctrl + Home</td><td align="left">跳到文件头</td></tr><tr><td align="left">Ctrl + Space</td><td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Delete</td><td align="left">删除光标后面的单词或是中文句</td></tr><tr><td align="left">Ctrl + BackSpace</td><td align="left">删除光标前面的单词或是中文句</td></tr><tr><td align="left">Ctrl + 1,2,3…9</td><td align="left">定位到对应数值的书签位置</td></tr><tr><td align="left">Ctrl + 左键单击</td><td align="left">在打开的文件标题上，弹出该文件路径</td></tr><tr><td align="left">Ctrl + 光标定位</td><td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td align="left">Ctrl + 左方向键</td><td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td align="left">Ctrl + 右方向键</td><td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td align="left">Ctrl + 前方向键</td><td align="left">等效于鼠标滚轮向前效果</td></tr><tr><td align="left">Ctrl + 后方向键</td><td align="left">等效于鼠标滚轮向后效果</td></tr></tbody></table><h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + `</td><td align="left">显示版本控制常用操作菜单弹出层</td></tr><tr><td align="left">Alt + Q</td><td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td align="left">Alt + F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left">Alt + F2</td><td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td align="left">Alt + F3</td><td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td align="left">Alt + F7</td><td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td align="left">Alt + F8</td><td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td align="left">Alt + Home</td><td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td></tr><tr><td align="left">Alt + Enter</td><td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td></tr><tr><td align="left">Alt + Insert</td><td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td align="left">Alt + 左方向键</td><td align="left">按左方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 右方向键</td><td align="left">按右方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 前方向键</td><td align="left">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td align="left">Alt + 后方向键</td><td align="left">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td align="left">Alt + 1,2,3…9</td><td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Shift + F1</td><td align="left">如果有外部文档可以连接外部文档</td></tr><tr><td align="left">Shift + F2</td><td align="left">跳转到上一个高亮错误 或 警告位置</td></tr><tr><td align="left">Shift + F3</td><td align="left">在查找模式下，查找匹配上一个</td></tr><tr><td align="left">Shift + F4</td><td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td align="left">Shift + F6</td><td align="left">对文件 / 文件夹 重命名</td></tr><tr><td align="left">Shift + F7</td><td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">Shift + F8</td><td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td></tr><tr><td align="left">Shift + F9</td><td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td></tr><tr><td align="left">Shift + F10</td><td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td></tr><tr><td align="left">Shift + F11</td><td align="left">弹出书签显示层</td></tr><tr><td align="left">Shift + Tab</td><td align="left">取消缩进</td></tr><tr><td align="left">Shift + ESC</td><td align="left">隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td align="left">Shift + End</td><td align="left">选中光标到当前行尾位置</td></tr><tr><td align="left">Shift + Home</td><td align="left">选中光标到当前行头位置</td></tr><tr><td align="left">Shift + Enter</td><td align="left">在当前行的下一行另起新行</td></tr><tr><td align="left">Shift+Alt+Enter</td><td align="left">在当前行的上一行另起新行</td></tr><tr><td align="left">Shift + 左键单击</td><td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr><tr><td align="left">Shift + 滚轮前后滚动</td><td align="left">当前文件的横向滚动轴滚动</td></tr></tbody></table><h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left"><strong><span style="color:red;">Ctrl + Alt + L</span></strong></td><td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + O</td><td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + I</td><td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td align="left">Ctrl + Alt + T</td><td align="left">对选中的代码弹出环绕选项弹出层</td></tr><tr><td align="left">Ctrl + Alt + J</td><td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td></tr><tr><td align="left">Ctrl + Alt + H</td><td align="left">调用层次</td></tr><tr><td align="left">Ctrl + Alt + B</td><td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td align="left">Ctrl + Alt + V</td><td align="left">快速引进变量</td></tr><tr><td align="left">Ctrl + Alt + Y</td><td align="left">同步、刷新</td></tr><tr><td align="left">Ctrl + Alt + S</td><td align="left">打开 IntelliJ IDEA 系统设置</td></tr><tr><td align="left">Ctrl + Alt + F7</td><td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td align="left">Ctrl + Alt + F11</td><td align="left">切换全屏模式</td></tr><tr><td align="left">Ctrl + Alt + Enter</td><td align="left">光标所在行上空出一行，光标定位到新行</td></tr><tr><td align="left">Ctrl + Alt + Home</td><td align="left">弹出跟当前文件有关联的文件弹出层</td></tr><tr><td align="left">Ctrl + Alt + Space</td><td align="left">类名自动完成</td></tr><tr><td align="left">Ctrl + Alt + 左方向键</td><td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 右方向键</td><td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 前方向键</td><td align="left">在查找模式下，跳到上个查找的文件</td></tr><tr><td align="left">Ctrl + Alt + 后方向键</td><td align="left">在查找模式下，跳到下个查找的文件</td></tr></tbody></table><h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + F</td><td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + R</td><td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + J</td><td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Z</td><td align="left">取消撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + W</td><td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + N</td><td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + U</td><td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + T</td><td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td align="left">Ctrl + Shift + C</td><td align="left">复制当前文件磁盘路径到剪贴板</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">显示最近修改的文件列表的弹出层</td></tr><tr><td align="left">Ctrl + Shift + H</td><td align="left">显示方法层次结构</td></tr><tr><td align="left">Ctrl + Shift + B</td><td align="left">跳转到类型声明处</td></tr><tr><td align="left">Ctrl + Shift + I</td><td align="left">快速查看光标所在的方法 或 类的定义</td></tr><tr><td align="left">Ctrl + Shift + A</td><td align="left">查找动作 / 设置</td></tr><tr><td align="left">Ctrl + Shift + /</td><td align="left">代码块注释 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + [</td><td align="left">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + ]</td><td align="left">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + +</td><td align="left">展开所有代码</td></tr><tr><td align="left">Ctrl + Shift + -</td><td align="left">折叠所有代码</td></tr><tr><td align="left">Ctrl + Shift + F7</td><td align="left">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td align="left">Ctrl + Shift + F8</td><td align="left">在 Debug 模式下，指定断点进入条件</td></tr><tr><td align="left">Ctrl + Shift + F9</td><td align="left">编译选中的文件 / 包 / Module</td></tr><tr><td align="left">Ctrl + Shift + F12</td><td align="left">编辑器最大化</td></tr><tr><td align="left">Ctrl + Shift + Space</td><td align="left">智能代码提示</td></tr><tr><td align="left">Ctrl + Shift + Enter</td><td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Backspace</td><td align="left">退回到上次修改的地方</td></tr><tr><td align="left">Ctrl + Shift + 1,2,3…9</td><td align="left">快速添加指定数值的书签</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 前方向键</td><td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td align="left">Ctrl + Shift + 后方向键</td><td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + Shift + N</td><td align="left">选择 / 添加 task</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">显示添加到收藏夹弹出层</td></tr><tr><td align="left">Alt + Shift + C</td><td align="left">查看最近操作项目的变化情况列表</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">添加到收藏夹</td></tr><tr><td align="left">Alt + Shift + I</td><td align="left">查看项目当前文件</td></tr><tr><td align="left">Alt + Shift + F7</td><td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td align="left">Alt + Shift + F9</td><td align="left">弹出 <code>Debug</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + F10</td><td align="left">弹出 <code>Run</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + 左键双击</td><td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td align="left">Alt + Shift + 前方向键</td><td align="left">移动光标所在行向上移动</td></tr><tr><td align="left">Alt + Shift + 后方向键</td><td align="left">移动光标所在行向下移动</td></tr></tbody></table><h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + Alt + V</td><td align="left">无格式黏贴</td></tr><tr><td align="left">Ctrl + Shift + Alt + N</td><td align="left">前往指定的变量 / 方法</td></tr><tr><td align="left">Ctrl + Shift + Alt + S</td><td align="left">打开当前项目设置</td></tr><tr><td align="left">Ctrl + Shift + Alt + C</td><td align="left">复制参考信息</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">F2</td><td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td></tr><tr><td align="left">F3</td><td align="left">在查找模式下，定位到下一个匹配处</td></tr><tr><td align="left">F4</td><td align="left">编辑源</td></tr><tr><td align="left">F7</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">F8</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">F9</td><td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">F11</td><td align="left">添加书签</td></tr><tr><td align="left">F12</td><td align="left">回到前一个工具窗口</td></tr><tr><td align="left">Tab</td><td align="left">缩进</td></tr><tr><td align="left">ESC</td><td align="left">从工具窗口进入代码文件窗口</td></tr><tr><td align="left">连按两次Shift</td><td align="left">弹出 <code>Search Everywhere</code> 弹出层</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以下绝大部分copy自：&lt;a href=&quot;https://blog.csdn.net/qq_38963960/article/details/89552704&quot;&gt;https://blog.csdn.net/qq_38963960/article/d</summary>
      
    
    
    
    <category term="IDEA" scheme="http://example.com/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="http://example.com/Tag/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA常用快捷键&amp;操作</title>
    <link href="http://example.com/2021/02/25/idea%E5%B8%B8%E7%94%A8/"/>
    <id>http://example.com/2021/02/25/idea%E5%B8%B8%E7%94%A8/</id>
    <published>2021-02-24T16:26:06.368Z</published>
    <updated>2021-03-05T16:17:23.700Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;</p><ul><li>ctrl+w：逐渐向外层选中</li><li>CTRL+shift+上下：当前行上下移</li><li>SHIFT+F10：运行main</li><li>CTRL+F2：停止运行</li><li>shift+esc：关闭下方窗口</li><li>CTRL+shift+左右：跳转至上/下一个方法（上/下一个历史光标位置）</li><li>CTRL+F12：弹出窗口形式查看当前类的所有方法</li><li>Alt+7：左边小窗口查看当前类所有方法</li><li>SHIFT + F2：定位到报错处（红线）</li><li>CTRL + R：替换指定文本。</li><li>SHIFT + F6：批量修改变量、方法名。</li><li>CTRL + ALT + V：抽取变量（<strong>已改为ALT + X</strong>）</li><li>CTRL + ALT + B/左键：方法具体实现</li><li>CTRL + ALT + M：将选中代码提取为方法</li><li>CTRL + ALT + P：抽取为方法参数，并修改方法被引用的地方</li><li>ALT + 1：打开Project 窗口。</li><li>CTRL + E：最近文件窗口。</li><li>CTRL + P：方法、构造器参数提示。</li><li>ALT + F7：查看指定方法/变量等被引用的次数和位置。</li></ul><p>&emsp;&emsp;</p><ul><li><p>debug时，下方的Frames窗口对应虚拟机栈，其中每个项就是一个栈帧（对应一个方法），右边的Variables对应该栈帧的局部变量表。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209202217531.png" alt="image-20210209202217531"></p></li><li><p>多个线程下调试时，右键断电，选择Thread</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212458998.png" alt="image-20210209212458998"></p><p>此时在此时选择线程：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212821981.png" alt="image-20210209212821981"></p></li><li><p>debug过程可以修改变量的值：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210222235056874.png" alt="image-20210222235056874"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ctrl+w：逐渐向外层选中&lt;/li&gt;
&lt;li&gt;CTRL+shift+上下：当前行上下移&lt;/li&gt;
&lt;li&gt;SHIFT+F10：运行main&lt;/li&gt;
&lt;li&gt;CTRL+F2：停止运行&lt;/li&gt;
&lt;li&gt;shift+esc</summary>
      
    
    
    
    <category term="IDEA" scheme="http://example.com/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="http://example.com/Tag/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA的一些使用技巧</title>
    <link href="http://example.com/2021/02/25/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2021/02/25/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-02-24T16:23:26.053Z</published>
    <updated>2021-02-24T16:27:24.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该笔记基于IDEA-2019版本</p></blockquote><h2 id="提高运行速度"><a href="#提高运行速度" class="headerlink" title="提高运行速度"></a>提高运行速度</h2><p>在idea安装目录的bin目录下的idea.exe.vmoptions文件，调整<code>Xms</code>跟<code>Xmx</code>两个参数的值可提高运行速度，但要注意电脑的运行内存是否足够。</p><h2 id="恢复默认设置"><a href="#恢复默认设置" class="headerlink" title="恢复默认设置"></a>恢复默认设置</h2><p>在用户目录中，有一个<code>.IntelliJIdea2019.3</code>目录，该目录下有个<code>config</code>跟一个<code>system</code>目录，前者存放关于IDEA一些设置相关的配置文件。可以通过将这两个目录删除来实现恢复默认设置（在重启idea时会自动创建这两个文件，但之前设置的快捷键、模板等将被重置）。</p><h2 id="工具条"><a href="#工具条" class="headerlink" title="工具条"></a>工具条</h2><p>【View】-》【Appearance】-》【选中Tool Bar】，打开工具条。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200814222041.png"></p><h2 id="IDEA中的Project和Module"><a href="#IDEA中的Project和Module" class="headerlink" title="IDEA中的Project和Module"></a>IDEA中的Project和Module</h2><p>参考链接：</p><blockquote><p><a href="https://blog.csdn.net/qq_35246620/article/details/65448689">https://blog.csdn.net/qq_35246620/article/details/65448689</a> </p></blockquote><p>在 IntelliJ IDEA 中<code>Project</code>是最顶级的结构单元，然后就是<code>Module</code>，一个<code>Project</code>可以有多个<code>Module</code>。</p><p>一个<code>Project</code>是由一个或多个<code>Module</code>组成，</p><ul><li>当为单<code>Module</code>项目的时候，这个单独的<code>Module</code>实际上就是一个<code>Project</code>；</li><li>当为多<code>Module</code>项目的时候，多个模块处于同一个<code>Project</code>之中，此时彼此之间具有互相依赖的关联关系。</li></ul><p>此外， IntelliJ IDEA 的<code>Project</code>是一个不具备任何编码设置、构建等开发功能的概念，其主要作用就是起到一个项目定义、范围约束、规范类型的效果，这个目录在命名上应该有其代表性的意义。在缺省情况下，IntelliJ IDEA 是默认单<code>Project</code>单<code>Module</code>的，这时<code>Project</code>和<code>Module</code>合二为一。</p><p>要删除Module时，需要进入<code>Project Structure</code>，在左边选择<code>Modules</code>，右边视图中选中要删除的Module，点击上方的<code>-</code>（或右键delete）即可。此时在项目中移除了对应Module，但在磁盘中没有删除Module对应目录，需手动删除。</p><p><strong>在一个Module中，可以通过在本Module的imi文件中配置引入其他Module的内容</strong>。可以使用<code>Alt+Enter</code>的提示功能自动配置。</p><h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><h3 id="鼠标悬停显示文档"><a href="#鼠标悬停显示文档" class="headerlink" title="鼠标悬停显示文档"></a>鼠标悬停显示文档</h3><p>【Settings】-》【Editor】-》【General】-》【视图右边滑到最下面，勾上<code>show quik documentation on mouse move</code>】</p><p>下方的Tooltip delay设置延迟时间。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145751019.png" alt="image-20200815145751019" style="zoom:67%;" /><h3 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135642.png" style="zoom:67%;" /><h3 id="显示方法间的分隔符"><a href="#显示方法间的分隔符" class="headerlink" title="显示方法间的分隔符"></a>显示方法间的分隔符</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135936.png"></p><h3 id="忽略大小写提示的差别"><a href="#忽略大小写提示的差别" class="headerlink" title="忽略大小写提示的差别"></a>忽略大小写提示的差别</h3><p>如图取消勾选即可。</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815140939775.png" alt="image-20200815140939775"></p><p>效果：输入S跟s的提示将变的一样。</p><h3 id="多个文件的标签多行显示"><a href="#多个文件的标签多行显示" class="headerlink" title="多个文件的标签多行显示"></a>多个文件的标签多行显示</h3><p>打开多个文件时，让多个文件的标签分成多行显示。如图，取消勾选。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141445072.png" alt="image-20200815141445072" style="zoom:80%;" /><h3 id="设置代码编辑区各部分样式"><a href="#设置代码编辑区各部分样式" class="headerlink" title="设置代码编辑区各部分样式"></a>设置代码编辑区各部分样式</h3><p>设置如单行注释、多行注释、方法等字体的样式。在框框内点击不同位置可自动跳转到对应的设置。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141938283.png" alt="image-20200815141938283" style="zoom: 67%;" /><h3 id="当导入同一个包的类超过多少时使用"><a href="#当导入同一个包的类超过多少时使用" class="headerlink" title="当导入同一个包的类超过多少时使用*"></a>当导入同一个包的类超过多少时使用<code>*</code></h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815142453764.png" alt="image-20200815142453764" style="zoom: 67%;" /><h3 id="设置类的头部信息"><a href="#设置类的头部信息" class="headerlink" title="设置类的头部信息"></a>设置类的头部信息</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143009247.png" alt="image-20200815143009247" style="zoom:67%;" /><h3 id="设置编码（全局）"><a href="#设置编码（全局）" class="headerlink" title="设置编码（全局）"></a>设置编码（全局）</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143239051.png" alt="image-20200815143239051" style="zoom:67%;" /><h3 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h3><p>也可同时勾上框框第二项，启动多模块并行编译。但会占用更多内存。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815144738928.png" alt="image-20200815144738928" style="zoom:67%;" /><h3 id="多个代码文件垂直-水平显示"><a href="#多个代码文件垂直-水平显示" class="headerlink" title="多个代码文件垂直/水平显示"></a>多个代码文件垂直/水平显示</h3><p>右键标签页，如图：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145150886.png" alt="image-20200815145150886" style="zoom: 80%;" /><p>效果：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145304470.png" alt="image-20200815145304470" style="zoom: 67%;" /><h3 id="CTRL-插入注释时带缩进"><a href="#CTRL-插入注释时带缩进" class="headerlink" title="CTRL+/ 插入注释时带缩进"></a><code>CTRL+/</code> 插入注释时带缩进</h3><p>设置Java文件：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135428506.png" alt="image-20200818135428506" style="zoom:67%;" /><p>XML文件同理：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135625076.png" alt="image-20200818135625076" style="zoom:67%;" /><blockquote><p>参考：<a href="https://blog.csdn.net/VariatioZbw/article/details/105626147">https://blog.csdn.net/VariatioZbw/article/details/105626147</a></p></blockquote><h3 id="为main方法传递参数"><a href="#为main方法传递参数" class="headerlink" title="为main方法传递参数"></a>为main方法传递参数</h3><blockquote><p>参考：<a href="https://blog.csdn.net/u013713294/article/details/53020293">https://blog.csdn.net/u013713294/article/details/53020293</a></p></blockquote><p>有时需要使用main方法的args参数，而为args参数赋值一般在命令行中，如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java <span class="comment">//编译</span></span><br><span class="line">java Test para<span class="name">m1</span> para<span class="name">m2</span> para<span class="name">m3</span> ... <span class="comment">//运行Test类，param是传递给main方法的参数</span></span><br></pre></td></tr></table></figure><p>在idea中可以设置参数，在main方法运行时把这些参数传递给它，步骤如下：</p><ol><li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213818332.png" style="zoom:80%;" /><p>或</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213902857.png" style="zoom:80%;" /></li><li><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924214508649.png" alt="image-20200924214508649"></p><p>点击OK，运行main方法时即会传入设置的参数。</p></li></ol><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815152625644.png" alt="image-20200815152625644" style="zoom: 80%;" /><p>查看/修改快捷键：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815233545855.png" alt="image-20200815233545855" style="zoom: 67%;" /><p><strong>快捷键大全</strong>：</p><blockquote><p>以下大部分来自：<a href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p></blockquote><h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + F</td><td align="left">在当前文件进行文本查找 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + R</td><td align="left">在当前文件进行文本替换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Z</td><td align="left">撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Y</td><td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + X</td><td align="left">剪切光标所在行 或 剪切选择内容</td></tr><tr><td align="left">Ctrl + C</td><td align="left">复制光标所在行 或 复制选择内容</td></tr><tr><td align="left">Ctrl + D</td><td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + W</td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + E</td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left">Ctrl + N</td><td align="left">根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td align="left">Ctrl + G</td><td align="left">在当前文件跳转到指定行处</td></tr><tr><td align="left">Ctrl + J</td><td align="left">插入自定义动态代码模板</td></tr><tr><td align="left">Ctrl + P</td><td align="left">方法参数提示显示</td></tr><tr><td align="left">Ctrl + Q</td><td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td align="left">Ctrl + U</td><td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td align="left">Ctrl + B</td><td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td align="left">Ctrl + K</td><td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + T</td><td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + H</td><td align="left">显示当前类的层次结构</td></tr><tr><td align="left">Ctrl + O</td><td align="left">选择可重写的方法</td></tr><tr><td align="left">Ctrl + I</td><td align="left">选择可继承的方法</td></tr><tr><td align="left">Ctrl + +</td><td align="left">展开代码</td></tr><tr><td align="left">Ctrl + -</td><td align="left">折叠代码</td></tr><tr><td align="left">Ctrl + /</td><td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + [</td><td align="left">移动光标到当前所在代码的花括号开始位置</td></tr><tr><td align="left">Ctrl + ]</td><td align="left">移动光标到当前所在代码的花括号结束位置</td></tr><tr><td align="left">Ctrl + F1</td><td align="left">在光标所在的错误代码出显示错误信息</td></tr><tr><td align="left">Ctrl + F3</td><td align="left">调转到所选中的词的下一个引用位置</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭当前编辑文件</td></tr><tr><td align="left">Ctrl + F8</td><td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td align="left">Ctrl + F9</td><td align="left">执行 Make Project 操作</td></tr><tr><td align="left">Ctrl + F11</td><td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td align="left">Ctrl + F12</td><td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td align="left">Ctrl + Enter</td><td align="left">智能分隔行</td></tr><tr><td align="left">Ctrl + End</td><td align="left">跳到文件尾</td></tr><tr><td align="left">Ctrl + Home</td><td align="left">跳到文件头</td></tr><tr><td align="left">Ctrl + Space</td><td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Delete</td><td align="left">删除光标后面的单词或是中文句</td></tr><tr><td align="left">Ctrl + BackSpace</td><td align="left">删除光标前面的单词或是中文句</td></tr><tr><td align="left">Ctrl + 1,2,3…9</td><td align="left">定位到对应数值的书签位置</td></tr><tr><td align="left">Ctrl + 左键单击</td><td align="left">在打开的文件标题上，弹出该文件路径</td></tr><tr><td align="left">Ctrl + 光标定位</td><td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td align="left">Ctrl + 左方向键</td><td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td align="left">Ctrl + 右方向键</td><td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td align="left">Ctrl + 前方向键</td><td align="left">等效于鼠标滚轮向前效果</td></tr><tr><td align="left">Ctrl + 后方向键</td><td align="left">等效于鼠标滚轮向后效果</td></tr></tbody></table><h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + `</td><td align="left">显示版本控制常用操作菜单弹出层</td></tr><tr><td align="left">Alt + Q</td><td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td align="left">Alt + F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left">Alt + F2</td><td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td align="left">Alt + F3</td><td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td align="left">Alt + F7</td><td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td align="left">Alt + F8</td><td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td align="left">Alt + Home</td><td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td></tr><tr><td align="left">Alt + Enter</td><td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td></tr><tr><td align="left">Alt + Insert</td><td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td align="left">Alt + 左方向键</td><td align="left">按左方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 右方向键</td><td align="left">按右方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 前方向键</td><td align="left">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td align="left">Alt + 后方向键</td><td align="left">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td align="left">Alt + 1,2,3…9</td><td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr><tr><td align="left">Alt + 7</td><td align="left">显示当前类的所有方法、成员变量等</td></tr></tbody></table><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Shift + F1</td><td align="left">如果有外部文档可以连接外部文档</td></tr><tr><td align="left">Shift + F2</td><td align="left">跳转到上一个高亮错误 或 警告位置</td></tr><tr><td align="left">Shift + F3</td><td align="left">在查找模式下，查找匹配上一个</td></tr><tr><td align="left">Shift + F4</td><td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td align="left">Shift + F6</td><td align="left">对文件 / 文件夹 重命名</td></tr><tr><td align="left">Shift + F7</td><td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">Shift + F8</td><td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td></tr><tr><td align="left">Shift + F9</td><td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td></tr><tr><td align="left">Shift + F10</td><td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td></tr><tr><td align="left">Shift + F11</td><td align="left">弹出书签显示层</td></tr><tr><td align="left">Shift + Tab</td><td align="left">取消缩进</td></tr><tr><td align="left">Shift + ESC</td><td align="left">隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td align="left">Shift + End</td><td align="left">选中光标到当前行尾位置</td></tr><tr><td align="left">Shift + Home</td><td align="left">选中光标到当前行头位置</td></tr><tr><td align="left">Shift + Enter</td><td align="left">在当前行的下一行另起新行</td></tr><tr><td align="left">Shift+Alt+Enter</td><td align="left">在当前行的上一行另起新行</td></tr><tr><td align="left">Shift + 左键单击</td><td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr><tr><td align="left">Shift + 滚轮前后滚动</td><td align="left">当前文件的横向滚动轴滚动</td></tr></tbody></table><h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Alt + L</td><td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + O</td><td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Alt + I</td><td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td align="left">Ctrl + Alt + T</td><td align="left">对选中的代码弹出环绕选项弹出层</td></tr><tr><td align="left">Ctrl + Alt + J</td><td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td></tr><tr><td align="left">Ctrl + Alt + H</td><td align="left">调用层次</td></tr><tr><td align="left">Ctrl + Alt + B</td><td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td align="left">Ctrl + Alt + V</td><td align="left">快速引进变量</td></tr><tr><td align="left">Ctrl + Alt + Y</td><td align="left">同步、刷新</td></tr><tr><td align="left">Ctrl + Alt + S</td><td align="left">打开 IntelliJ IDEA 系统设置</td></tr><tr><td align="left">Ctrl + Alt + F7</td><td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td align="left">Ctrl + Alt + F11</td><td align="left">切换全屏模式</td></tr><tr><td align="left">Ctrl + Alt + Enter</td><td align="left">光标所在行上空出一行，光标定位到新行</td></tr><tr><td align="left">Ctrl + Alt + Home</td><td align="left">弹出跟当前文件有关联的文件弹出层</td></tr><tr><td align="left">Ctrl + Alt + Space</td><td align="left">类名自动完成</td></tr><tr><td align="left">Ctrl + Alt + 左方向键</td><td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 右方向键</td><td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td align="left">Ctrl + Alt + 前方向键</td><td align="left">在查找模式下，跳到上个查找的文件</td></tr><tr><td align="left">Ctrl + Alt + 后方向键</td><td align="left">在查找模式下，跳到下个查找的文件</td></tr></tbody></table><h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + F</td><td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + R</td><td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + J</td><td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Z</td><td align="left">取消撤销 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + W</td><td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + N</td><td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + U</td><td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + T</td><td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td align="left">Ctrl + Shift + C</td><td align="left">复制当前文件磁盘路径到剪贴板</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">显示最近修改的文件列表的弹出层</td></tr><tr><td align="left">Ctrl + Shift + H</td><td align="left">显示方法层次结构</td></tr><tr><td align="left">Ctrl + Shift + B</td><td align="left">跳转到类型声明处</td></tr><tr><td align="left">Ctrl + Shift + I</td><td align="left">快速查看光标所在的方法 或 类的定义</td></tr><tr><td align="left">Ctrl + Shift + A</td><td align="left">查找动作 / 设置</td></tr><tr><td align="left">Ctrl + Shift + /</td><td align="left">代码块注释 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + [</td><td align="left">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + ]</td><td align="left">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + +</td><td align="left">展开所有代码</td></tr><tr><td align="left">Ctrl + Shift + -</td><td align="left">折叠所有代码</td></tr><tr><td align="left">Ctrl + Shift + F7</td><td align="left">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td align="left">Ctrl + Shift + F8</td><td align="left">在 Debug 模式下，指定断点进入条件</td></tr><tr><td align="left">Ctrl + Shift + F9</td><td align="left">编译选中的文件 / 包 / Module</td></tr><tr><td align="left">Ctrl + Shift + F12</td><td align="left">编辑器最大化</td></tr><tr><td align="left">Ctrl + Shift + Space</td><td align="left">智能代码提示</td></tr><tr><td align="left">Ctrl + Shift + Enter</td><td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td></tr><tr><td align="left">Ctrl + Shift + Backspace</td><td align="left">退回到上次修改的地方</td></tr><tr><td align="left">Ctrl + Shift + 1,2,3…9</td><td align="left">快速添加指定数值的书签</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 前方向键</td><td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td align="left">Ctrl + Shift + 后方向键</td><td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + Shift + N</td><td align="left">选择 / 添加 task</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">显示添加到收藏夹弹出层</td></tr><tr><td align="left">Alt + Shift + C</td><td align="left">查看最近操作项目的变化情况列表</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">添加到收藏夹</td></tr><tr><td align="left">Alt + Shift + I</td><td align="left">查看项目当前文件</td></tr><tr><td align="left">Alt + Shift + F7</td><td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td align="left">Alt + Shift + F9</td><td align="left">弹出 <code>Debug</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + F10</td><td align="left">弹出 <code>Run</code> 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + 左键双击</td><td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td align="left">Alt + Shift + 前方向键</td><td align="left">移动光标所在行向上移动</td></tr><tr><td align="left">Alt + Shift + 后方向键</td><td align="left">移动光标所在行向下移动</td></tr></tbody></table><h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + Alt + V</td><td align="left">无格式黏贴</td></tr><tr><td align="left">Ctrl + Shift + Alt + N</td><td align="left">前往指定的变量 / 方法</td></tr><tr><td align="left">Ctrl + Shift + Alt + S</td><td align="left">打开当前项目设置</td></tr><tr><td align="left">Ctrl + Shift + Alt + C</td><td align="left">复制参考信息</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">F2</td><td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td></tr><tr><td align="left">F3</td><td align="left">在查找模式下，定位到下一个匹配处</td></tr><tr><td align="left">F4</td><td align="left">编辑源</td></tr><tr><td align="left">F7</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">F8</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">F9</td><td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">F11</td><td align="left">添加书签</td></tr><tr><td align="left">F12</td><td align="left">回到前一个工具窗口</td></tr><tr><td align="left">Tab</td><td align="left">缩进</td></tr><tr><td align="left">ESC</td><td align="left">从工具窗口进入代码文件窗口</td></tr><tr><td align="left">连按两次Shift</td><td align="left">弹出 <code>Search Everywhere</code> 弹出层</td></tr></tbody></table><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>查看/设置模板：</p><p>Live Templates中可以查看、<strong>编辑、添加以及删除</strong>模板：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142838850.png" alt="image-20200816142838850" style="zoom:80%;" /><p>Postfix Completion中只能查看、禁用。下图的Before框表示模板的预定义形式，After表示输出效果。比如下图的例子，输入<code>foo.forr</code>，摁下enter。将输出after框的模板。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142928743.png" alt="image-20200816142928743" style="zoom:67%;" /><h3 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816153643738.png" alt="image-20200816153643738" style="zoom: 80%;" /><p>如上图操作，输入模板组名，确定。选中创建的模板组，点击<code>+</code>，点击<code>Live Template</code>在组中添加新模板。</p><p>设置新模板：</p><ul><li>1处填写模板缩写</li><li>2处填写模板的描述</li><li>3处定义模板内容。<strong>例子中模板的意义：</strong>输入test按下enter出现模板后，光标会跳至<code>$var1$</code>位置，输入完成后按enter，光标跳至<code>$var2$</code>处。</li></ul><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154245765.png" alt="image-20200816154245765"></p><p>下一步，点击define，选择java：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154543995.png" alt="image-20200816154543995" style="zoom:67%;" /><p>点击OK即可。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200821195633214.png" alt="image-20200821195633214" style="zoom:67%;" /><h3 id="idea自带模板"><a href="#idea自带模板" class="headerlink" title="idea自带模板"></a>idea自带模板</h3><table><thead><tr><th>Before</th><th align="left">After</th><th align="left">备注</th></tr></thead><tbody><tr><td><code>psvm</code></td><td align="left"><code>public static void main(String[] args) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>sout</code></td><td align="left"><code>System.out.println();</code></td><td align="left"></td></tr><tr><td><code>soutm</code></td><td align="left"><code>System.out.println(&quot;当前方法的全限定名&quot;);</code></td><td align="left"></td></tr><tr><td><code>soutp</code></td><td align="left"><code>System.out.println(&quot;c = &quot; + c);</code></td><td align="left">以<code>valueName=value</code><br>的形式输出</td></tr><tr><td><code>soutv</code></td><td align="left">与上同</td><td align="left">输出某一变量</td></tr><tr><td><code>variable.sout</code></td><td align="left"><code>System.out.println(variable);</code></td><td align="left"></td></tr><tr><td><code>fori</code> （<strong>递增</strong>）</td><td align="left"><code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></td><td align="left">输入完成后光标跳至第一个i后<br>可改变变量名；按enter光标跳至&lt;后<br>再按enter跳至<code>&#123;&#125;</code>中</td></tr><tr><td><code>arrs/List/Set.fori</code></td><td align="left"><code>for (int i = 0; i &lt; xxx.size(); i++) &#123;&#125;</code></td><td align="left">可对数组、集合使用。</td></tr><tr><td><code>forr</code>（递减）</td><td align="left">与上同理</td><td align="left"></td></tr><tr><td><code>arrs/List/Set.forr</code></td><td align="left"></td><td align="left"></td></tr><tr><td><code>iter</code></td><td align="left"><code>for (T t : arrs) &#123;&#125;</code></td><td align="left">对某一数组使用forEach循环</td></tr><tr><td><code>arrs.iter</code></td><td align="left">同上</td><td align="left">对指定数组使用forEach循环</td></tr><tr><td><code>itar</code></td><td align="left"><code>for (int i = 0; i &lt; arr.length; i++) &#123;int i1 =arr[i];&#125;</code></td><td align="left">对代码中上一个数组使用普通for循环</td></tr><tr><td><code>ifn</code></td><td align="left"><code>if (xxx == null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>value.null</code></td><td align="left"><code>if (value == null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>inn</code> （if not null）</td><td align="left"><code>if (st != null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>value.nn</code></td><td align="left"><code>if (value == null) &#123;&#125;</code></td><td align="left"></td></tr><tr><td><code>prsf</code></td><td align="left"><code>private static final</code></td><td align="left"></td></tr><tr><td><code>psfi</code></td><td align="left"><code>public static final int</code></td><td align="left"></td></tr><tr><td><code>psfs</code></td><td align="left"><code>public static final String</code></td><td align="left"></td></tr><tr><td><code>psf</code></td><td align="left"><code>public static final</code></td><td align="left"></td></tr><tr><td></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="快捷创建Mybatis主配置文件"><a href="#快捷创建Mybatis主配置文件" class="headerlink" title="快捷创建Mybatis主配置文件"></a>快捷创建Mybatis主配置文件</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130058653.png" alt="image-20200914130058653" style="zoom: 80%;" /><p>填写Name以及文件类型（Extension），并在方框内写入初始代码：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130320437.png" alt="image-20200914130320437"></p><p>Apply，即完成模板设置。</p><p>右键New创建文件时，即可看到创建的模板：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130454583.png" alt="image-20200914130454583" style="zoom:80%;" /><h2 id="版本控制（git）"><a href="#版本控制（git）" class="headerlink" title="版本控制（git）"></a>版本控制（git）</h2><h3 id="克隆GitHub的项目到idea中"><a href="#克隆GitHub的项目到idea中" class="headerlink" title="克隆GitHub的项目到idea中"></a>克隆GitHub的项目到idea中</h3><p>1.先在idea中配置好git安装目录：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817131825434.png" style="zoom: 67%;" /><p>2.添加GitHub账户</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817132350071.png" alt="image-20200817132350071" style="zoom: 67%;" /><p>3.从GitHub上clone仓库：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134058705.png" alt="image-20200817134058705" style="zoom:80%;" /><p>或者：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134723950.png" alt="image-20200817134723950" style="zoom:80%;" /><p>4.填写仓库信息</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134256096.png" alt="image-20200817134256096" style="zoom:80%;" /><p>5.是否为clone的仓库创建新项目，选择yes：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134413600.png" alt="image-20200817134413600" style="zoom:67%;" /><p>后面是创建项目的一些选项，此处省略。</p><p>完成。</p><p>6.clone后，在idea中左侧的项目框右键：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135922566.png" alt="image-20200817135922566" style="zoom:67%;" /><p>即可看到git的各种操作。</p><p>没有add的文件在idea中会显示为红色。</p><h3 id="将本地项目Share到GitHub"><a href="#将本地项目Share到GitHub" class="headerlink" title="将本地项目Share到GitHub"></a>将本地项目Share到GitHub</h3><p>这种方式将会在GitHub创建一个仓库，并将项目push到该仓库。</p><p>步骤：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135325861.png" alt="image-20200817135325861" style="zoom:80%;" /><p>后续步骤简单，省略。</p><h2 id="Idea自带的文件修改历史功能"><a href="#Idea自带的文件修改历史功能" class="headerlink" title="Idea自带的文件修改历史功能"></a>Idea自带的文件修改历史功能</h2><p>右键一个文件-》【Local History】=》【show History】，即可看到文件的修改历史。</p><p>本地历史的相关信息保存在<code>C:\User\.IntelliJIdea2019.3\system\LocalHistory</code>下。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>调试的界面和各种按钮，<strong>鼠标悬停在按钮上可查看快捷键信息</strong>：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141152314.png" alt="image-20200817141152314" style="zoom:80%;" /><p><strong>各种操作的含义</strong>：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817140516654.png" alt="image-20200817140516654" style="zoom: 67%;" /><h3 id="为断点添加条件"><a href="#为断点添加条件" class="headerlink" title="为断点添加条件"></a>为断点添加条件</h3><p>即在该断点停止的条件是满足设置的条件。</p><p>例子：</p><p>创建一个for循环，并在输出语句添加断点：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141741524.png" alt="image-20200817141741524" style="zoom:80%;" /><p>右键断点，在condition中设置条件：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141829128.png" alt="image-20200817141829128" style="zoom:80%;" /><p>启动Debug，停止时i的值是60：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817142010635.png" alt="image-20200817142010635" style="zoom:67%;" /><h3 id="调试过程中查看变量的值"><a href="#调试过程中查看变量的值" class="headerlink" title="调试过程中查看变量的值"></a>调试过程中查看变量的值</h3><p>基本数据类型的值可直接在界面上查看，如上述例子。对于引用类型变量，若要查看具体的属性信息，可将鼠标悬停在变量上，点击<code>+</code>即可查看。</p><h2 id="创建Javadoc文档"><a href="#创建Javadoc文档" class="headerlink" title="创建Javadoc文档"></a>创建Javadoc文档</h2><p>步骤：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817150847896.png" alt="image-20200817150847896" style="zoom:80%;" /><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817151557958.png" alt="image-20200817151557958" style="zoom:67%;" /><p><strong>PS</strong>：命令行参数中，指定的字符集要和项目的字符集一致。</p><h2 id="清除缓存和索引"><a href="#清除缓存和索引" class="headerlink" title="清除缓存和索引"></a>清除缓存和索引</h2><p>IDEA首次加载项目时会创建索引。</p><p>IntelliJ IDEA的缓存和索引<strong>主要是用来加快文件查询， 从而加快各种查找、代码提示等操作的速度</strong>。但是， IntelliJ IDEA的索引和缓存并不是一直会良好地支持IntelliJ IDEA的，某些特殊条件下， IntelliJ IDEA的缓存和索引文件也是会损坏的， 比如：断电、蓝屏引起的强制关机， 当你重新打开IntelliJ IDEA， 很可能Intell IDEA会报各种莫名其妙错误。这种情况可以清理下缓存和索引。如下：</p><p>【File】-》【Invalidate cache/Restart】，选择invalidate and restart。</p><p>或者将<code>C:\User\.IntelliJIdea2019.3\system</code>文件删除（需要idea先关闭），并再次启动idea，等待其重新创建索引即可。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="下载maven导入jar包的源码和依赖"><a href="#下载maven导入jar包的源码和依赖" class="headerlink" title="下载maven导入jar包的源码和依赖"></a>下载maven导入jar包的源码和依赖</h3><p>点击右侧边栏的maven，如图：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215147737.png" alt="image-20200820215147737" style="zoom:80%;" /><p>选择<code>Download Sources</code>下载源码的jar包；选择<code>Download Documentation</code>下载说明文档（javadoc文件）；或者两者都下载。</p><p>打开maven的仓库目录，按下图找到对应目录：</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215358815.png" alt="image-20200820215358815" style="zoom: 80%;" /><p>如该图中到仓库下的<code>com\google\protobuf\protobuf-java\3.11.4</code>目录下，可看见下载的javadoc和sources的jar包。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215629801.png" alt="image-20200820215629801" style="zoom: 80%;" /><h3 id="maven项目构建可执行jar包（包含导入的依赖）"><a href="#maven项目构建可执行jar包（包含导入的依赖）" class="headerlink" title="maven项目构建可执行jar包（包含导入的依赖）"></a>maven项目构建可执行jar包（包含导入的依赖）</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/dzblog/p/6913809.html">https://www.cnblogs.com/dzblog/p/6913809.html</a></p></blockquote><ol><li><p>pom.xml文件中配置插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此处指定main方法入口的class --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>包含main方法的入口类全限定名<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>执行package命令：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924215425450.png" alt="image-20200924215425450"></p></li><li><p>在target目录下即可看见项目的包含依赖的可执行jar包。</p></li></ol><blockquote><p>不包含依赖、包含部分依赖的打包方式见参考链接。</p></blockquote><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该笔记基于IDEA-2019版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;提高运行速度&quot;&gt;&lt;a href=&quot;#提高运行速度&quot; class=&quot;headerlink&quot; title=&quot;提高运行速度&quot;&gt;&lt;/a&gt;提高运行速度&lt;/h2&gt;&lt;p&gt;在id</summary>
      
    
    
    
    <category term="IDEA" scheme="http://example.com/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="http://example.com/Tag/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>多线程笔记1</title>
    <link href="http://example.com/2021/02/25/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/"/>
    <id>http://example.com/2021/02/25/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/</id>
    <published>2021-02-24T16:21:20.469Z</published>
    <updated>2021-03-20T12:06:42.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>一个程序进入内存运行时，即变成一个进程。进程是代码在数据集合上的一次运行活动；<strong>进程是系统进行资源分配和调度的一个独立单位</strong>。 </p><p>进程的三个特征：</p><ul><li><strong>独立性</strong>：拥有独立的资源、私有的地址空间。未经允许的情况下，一个进程不能直接访问其他的进程。</li><li><strong>动态性</strong>：程序是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程具有自己的生命周期和各种不同状态。</li><li><strong>并发性</strong>：多个进程可以在单个处理器上并发执行，进程之间不会互相影响。</li></ul><p>并发和并行：</p><ul><li>并发：指同一时刻，只有一条指令执行，但多个进程指令快速轮换执行。<strong>CPU执行指令即为并发执行</strong>。“<strong>微观串行，宏观并行</strong>”。（单核CPU）</li><li>并行：同一时刻多个指令同时执行（多核CPU）。</li><li>对于多核OS，既有并行又有并发。</li></ul><h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2) 线程"></a>2) 线程</h4><p><strong>线程是进程中的一个实体，线程本身是不会独立存在的</strong>。线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p><p>操作系统在分配资源时是把资源分配给进程的的， 但是<strong>CPU资源是被分配到线程的， 因为真正要占用CPU运行的是线</strong>程，所以也说<strong>线程是CPU分配的基本单位</strong>。在Java中，<strong>当启动main函数时其实就启动了一个JVM的进程， 而main函数所在的线程就是这个进程中的一个线程，也称主线程</strong>。</p><p>&emsp;&emsp;</p><p>一个进程可以同时并发处理多个任务（即执行多个线程）。线程也被称作轻量级进程。线程是进程的执行单元。<strong>线程是一个指令流</strong>。</p><p><strong>于绝大多数的应用程序来说，通常仅要求有一个主线程，但也可以在该进程内创建多条顺序执行流，这些顺序执行流就是线程，每个线程也是互相独立的。</strong>   </p><ul><li><strong>线程拥有自己的堆栈、自己的程序计数器和自己的局部变量</strong>，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。多个线程共享父进程里的全部资源，需要确保线程不会妨碍同一进程里的其他线程。</li><li>线程是独立运行的，它并不知道进程中是否还有其他线程存在。<strong>线程的执行是抢占式</strong>(当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。)</li><li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li><li>多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行.</li><li>线程的调度和管理由进程本身负责完成。</li><li>一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程.</li></ul><p><strong><em>归纳</em></strong>：<br><strong>操作系统可以同时执行多个任务，每个任务即为一个进程；进程可同时执行多个任务，每个任务即为一个线程。单线程只有一个顺序执行流，多线程有多个，多个顺序流之间互不干扰。</strong></p><h3 id="多线程相比于多进程的优势"><a href="#多线程相比于多进程的优势" class="headerlink" title="多线程相比于多进程的优势"></a>多线程相比于多进程的优势</h3><p>（为什么使用多线程而不是用多进程）</p><ul><li>进程中线程隔离程度小，使得多线程程序并发性高。</li><li>进程之间不能共享内存，而线程可以，运行效率高。</li><li>创建进程系统需为该进程分配独立内存空间，并分配大量资源，而创建线程代价小得多。</li><li>Java语言内置多线程功能支持。</li></ul><p>&emsp;&emsp;</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>从方法调用的角度来讲，</p><ul><li>如果需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p>同步在多线程中还有另外一层意思，是让多个线程步调一致</p><p>&emsp;&emsp;</p><h3 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h3><ul><li>windows<ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程 </li><li>tasklist 查看进程 </li><li>taskkill 杀死进程</li></ul></li><li>linux<ul><li><code>ps -fe</code> 查看所有进程 </li><li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程 </li><li><code>kill</code> 杀死进程 </li><li><code>top</code> 按大写 H 切换是否显示线程 </li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul></li><li>Java<ul><li>jps 命令查看所有 Java 进程 </li><li>jstack &lt;PID&gt; 查看某个 Java 进程（PID）的所有线程状态 </li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul></li></ul><p>&emsp;&emsp;</p><hr><h2 id="线程的3种创建方式"><a href="#线程的3种创建方式" class="headerlink" title="线程的3种创建方式"></a>线程的3种创建方式</h2><p>Java使用<strong>Thread类</strong>代表线程，每个线程对象都是Thread类实例或Thread类的子类实例。<br>每个线程的作用是完成一定的任务，即执行一段程序流。Java使用线程执行体来代表这段程序流。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>定义Thread类子类，重写run()方法。<strong>run()<em>方法的方法体代表线程要完成的任务</em></strong>。  </p><p>Thread类常用方法：</p><ul><li>run()</li><li>start()</li><li>getName()<br>获取调用该方法的线程的名字</li><li>Thread.currentThread()<br>Thread类的静态方法，返回<strong>当前正在执行</strong>的线程对象（返回值为Thread）。</li></ul><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line"><span class="keyword">new</span> FirstTread().start();</span><br><span class="line"><span class="keyword">new</span> FirstTread().start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或使用匿名内部类方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;thread is running...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p><strong>使用继承Thread类的方法创建线程时，多个线程之间无法共享线程类的实例变量（每个线程都是独立的）</strong>。</p><p>&emsp;&emsp;</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Runnable接口是一个函数式接口，包含一个<code>run()</code>方法。<strong>通过实现该接口来创建线程任务</strong>。</p><p>eg:</p><p>1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByRunnable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Runnable runnable = () -&gt; log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">100</span> ;i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> +i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">    <span class="comment">//通过该方法创建线程，要获取线程名称只能通过currentThread()调用getName()</span></span><br><span class="line">    <span class="comment">//无法通过this引用直接调用getName()</span></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">SecondThread st = <span class="keyword">new</span> SecondThread();</span><br><span class="line"><span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>该例子的两个子线程共享i变量（两个子线程输出的i变量是连续的）。</strong><br><strong>即采用同一个Runnable变量创建的线程可共享线程类的实例变量。</strong></p><p>&emsp;&emsp;</p><p>使用该方法将线程和任务分开，更加灵活。</p><p>&emsp;&emsp;</p><h3 id="使用FutureTask"><a href="#使用FutureTask" class="headerlink" title="使用FutureTask"></a>使用FutureTask</h3><p>FutureTask的继承关系：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210115247727.png" alt="image-20210210115247727"></p><p>FutureTask中封装了一个Callable接口。</p><p>Callable接口<strong>提供一个call()方法作为线程执行体</strong>，与run()方法相比：</p><ul><li>call()方法有返回值。</li><li>call()方法可以抛出异常。</li></ul><p>Callable接口的call()方法并不是直接调用，而是作为线程执行体被调用。</p><p>Future的几个控制与他关联的Callable任务公共方法：</p><ol><li><code>boolean cancel( boolean maylnterruptlfrunnin)</code>：试图取消该Future里关联的 Callable任务。</li><li><code>V get()</code>:返回 Callable任务里call()方法的返回值。<strong>调用该方法将导致程序阻塞，必须等到子线程结束后才会得到返回值（其他线程将被阻塞，直到该子线程执行完毕并返回对应值）</strong>。</li><li><code>V get(long timeout， Timeunit unit)</code>:返回 Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出Timeoutexception异常。</li><li><code>boolean isCancelled()</code>:如果在Callable任务正常完成前被取消，则返回true。</li><li><code>boolean isDone()</code>:如果 Callable任务已完成，则返回true。  </li></ol><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread&#x27;s running...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;the return value of the task: &quot;</span> + task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的返回值通过FutureTask对象的get()方法获取，<strong>且当调用该方法时当前线程会阻塞，直到FutureTask执行完毕才返回，若是在调用线程的<code>start()</code>方法之前调用get方法，会陷入死锁</strong>。</p><p>&emsp;&emsp;</p><h3 id="三种方式优缺点"><a href="#三种方式优缺点" class="headerlink" title="三种方式优缺点"></a>三种方式优缺点</h3><p>通过实现Runnable、Callable接口创建多线程的优缺点：  </p><ul><li>线程类只是实现了对应接口，可继承其他的类。</li><li>多个线程可以共享一个target对象。适合多个相同线程处理同一份资源的情况。<strong>可以将CPU、代码和数据分开，形成清晰的模型，体现面向对象的思想</strong>。</li><li>劣势：编程稍稍复杂，访问当前线程只能用<code>Thread.currentThread()</code>方法。  </li></ul><p>继承Thread方法的优缺点：</p><ul><li>劣势：<strong>不可继承其他父类</strong>。</li><li>优势：编写简单。<strong>使用当前线程可直接使用this</strong>。</li></ul><p>Runnable、继承Thread都不能获取线程返回值，使用FutrueTask可以获取返回值，且<code>call()</code>方法可以抛出异常。</p><p><strong>推荐方法为实现Runnable接口、Callable接口</strong>。</p><p>&emsp;&emsp;</p><h2 id="线程中的常用方法"><a href="#线程中的常用方法" class="headerlink" title="线程中的常用方法"></a>线程中的常用方法</h2><h3 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h3><p>wait、notify、notifyAll是<strong>Object类中的实例方法</strong>。</p><p>3个api：</p><ul><li><code>wait()</code> 让进入 object 监视器的线程到 waitSet <strong>一直</strong>等待 </li><li><code>wait(long n)</code> 等待直到时间超时后进入EntryList</li><li><code>notify()</code> 在 object 上正在 waitSet 等待的线程中随机唤醒一个。<strong>interrupt()可以叫醒wait中的线程</strong>。</li><li><code>notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210216174346353.png" alt="image-20210216174346353"></p><ul><li><p>Owner 线程发现条件不满足时，<strong>调用 wait 方法，进入 WaitSet 变为 WAITING 状态，等待被唤醒</strong> 。</p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </p></li><li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </p></li><li><p>而WAITING 线程只能<strong>在 Owner 线程中调用 notify 或 notifyAll 唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</strong>。</p></li><li><p><strong><font color="red">当前线程必须拥有对象的monitor才能调用这些api，否则抛出IllegalMonitorStateException异常</font></strong>。<code>wait()</code>的JavaDoc：</p><p><code>The current thread must own this object&#39;s monitor  </code> </p><blockquote><p>注意是1个对象对应1个monitor</p></blockquote></li><li><p><strong>当前线程调用<code>wait()</code>只会释放当前该共享变量的锁，而该线程的其他锁是不会释放的</strong>。</p></li><li><p>被唤醒的线程不能马上从wait方法返回并继续执行， 它<strong>必须在获取了共享对象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行</strong>。</p></li></ul><p>&emsp;&emsp;</p><h4 id="使用的正确姿势"><a href="#使用的正确姿势" class="headerlink" title="使用的正确姿势"></a>使用的正确姿势</h4><p><strong>sleep和 wait的异同</strong>：</p><ol><li><p>sleep 是 Thread 方法，而 wait 是 Object 的方法 </p></li><li><p>sleep 不需要强制和 synchronized 配合使用，<strong>但 wait 需要 和 synchronized 一起用</strong> </p></li><li><p><strong><font color="red">sleep在睡眠的同时不会释放对象锁，但 wait 在等待的时候会释放对象锁 </font></strong>。</p></li><li><p>它们状态都是TIMED_WAITING。</p></li></ol><p>&emsp;&emsp;</p><p>以下姿势对应的demo在<code>practice/useWaitNotifyOBBK</code>包下。</p><p><strong>姿势1</strong>：某些条件不满足时调用sleep会占用锁，使用wait更合理。</p><p><strong>姿势2</strong>：若是有多个线程在WaitSet，则不宜使用<code>notify()</code>，它只能随机唤醒一个，不能唤醒满足条件的线程。应使用<code>notifyAll()</code>（显然会唤醒部分不满足条件的线程）。</p><p><strong>姿势3</strong>：使用循环进行<code>wait()</code>，不满足条件则一直等。<strong>一个线程即使没有被其他线程调用<code>notify()</code>、<code>notifyAll()</code>方法进行通知、或者被中断、或者等待超时，也可以被唤醒，这就是所谓的虚假唤醒</strong>。虽然虚假唤醒很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"><span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">lock.wait();</span><br><span class="line">&#125; <span class="comment">// 干活 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程 </span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">lock.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="park、unpark"><a href="#park、unpark" class="headerlink" title="park、unpark"></a>park、unpark</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>它们是 LockSupport 类中的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程 </span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行 </span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure><p>与 Object 的 wait &amp; notify 相比 </p><ul><li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p></li><li><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 </p></li><li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p></li></ul><p>&emsp;&emsp;</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><strong>每个线程都关联一个 Parker 对象</strong>，由三部分组成 _counter ， _cond 和 _mutex</p><ul><li>_counter ：值为0或1，调用park时若<code>_count</code>为0则当前线程阻塞，为1则将其减1并继续运行，无需阻塞。</li><li>_cond：相当于阻塞队列。</li><li>_mutex：互斥锁，操作<code>_count</code>时需要获取该锁？。</li></ul><p>&emsp;&emsp;</p><p>先调用<code>park()</code>，再调用<code>unpark()</code>过程解析：</p><ul><li>调用<code>park()</code>：</li></ul><ol><li><p>当前线程调用 Unsafe.park() 方法 </p></li><li><p>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁 </p></li><li><p>线程<strong>进入 _cond 条件变量阻塞</strong> </p></li><li><p><strong>设置 _counter = 0</strong> </p></li></ol><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217142957852.png" alt="image-20210217142957852" style="zoom: 67%;" /><ul><li>调用<code>unpark()</code>：</li></ul><ol><li><p>设置 _counter 为 1 </p></li><li><p>唤醒 _cond 条件变量中的 Thread_0 </p></li><li><p>Thread_0 恢复运行 </p></li><li><p>设置 _counter 为 0</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143224158.png" alt="image-20210217143224158" style="zoom:67%;" /></li></ol><p>&emsp;&emsp;</p><p>先调用<code>unpark()</code>，再调用<code>park()</code>过程解析：</p><ol><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 </p></li><li><p>当前线程调用 Unsafe.park() 方法 </p></li><li><p><strong>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</strong>  </p></li><li><p>设置 _counter 为 0</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143503716.png" alt="image-20210217143503716" style="zoom:67%;" /></li></ol><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>以下api都是Thread类的方法。</p><ul><li><p><code>interrupt()</code>：中断线程，<strong style="color:red">但其实只是将线程的中断标志置为true，线程还是会继续运行</strong>。</p><ul><li><strong>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记</strong> ；</li><li>否则，<strong>仅仅设置打断标记 ，但并不会使线程停止（即调用interrupt只是让线程知道有人要终止它，它可以先进行某些处理后再自行终止线程）</strong>。</li><li>被<code>LockSurpport.park()</code><strong>暂停</strong>的线程被打断则会继续运行，<strong>且会设置打断标记为true</strong>。</li></ul><p>**demo见<code>JavaConcurrentDemo/trhead_basic/TestInterrupt</code>**。</p></li><li><p><code>isInterrupted()</code>：返回中断标志，<strong>不清除中断标志</strong>。</p></li><li><p><code>static interrupted()</code>：判断当前线程是否被打断。<strong>清除中断标记（即将中断标志置false）</strong>。<strong>注意是静态方法</strong>。</p><ul><li><p>该方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要注意返回的是<font color="red">“当前线程”</font>的中断标志</strong>。</p></li></ul></li><li><p><code>private native boolean isInterrupted(boolean ClearInterrupted)</code>：私有方法，返回中断标志，并根据ClearInterrupted参数决定是否清除中断标志，上面2个方法都是调用了该方法。</p></li></ul><p>&emsp;&emsp;</p><h3 id="Thread类方法"><a href="#Thread类方法" class="headerlink" title="Thread类方法"></a>Thread类方法</h3><ul><li><p><code>start()</code>：启动一个新线程，在新的线程运行run方法中的代码。<strong>start方法只是让线程进入就绪，里面代码不一定立刻运行</strong>（CPU的时间片还没分给它）。<strong>每个线程对象的 start方法只能调用一次</strong>，如果调用了多次会出IllegalThreadStateException</p></li><li><p><code>run()</code>：如果在构造Thread对象时传递了 Runnable 参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为。</p></li><li><p><code>join()</code> ：<strong>在当前线程中阻塞，直到指定线程运行结束，<font color="red">注意此时当前线程是在指定线程对象上的monitor等待（即在该monitor的WaitSet上）</font></strong>。其他线程调用因<code>join()</code>阻塞线程的<code>interrupt()</code>方法时，被打断程序会抛出InterruptedException 并返回。</p></li><li><p><code>join(long n) </code>：等待线程运行结束,最多等待 n 毫秒</p></li><li><p><code>setPriority(int)</code> ：线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用。</p></li><li><p><code>isAlive()</code>：线程是否存活 （还没有运行完毕）</p></li><li><p><code>sleep()</code>：</p></li><li><p>在一些<code>while(true)</code>中可以使用sleep来避免占用过多的cpu用于空转。</p><ul><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） </li><li><strong>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时线程会抛出 InterruptedException并返回</strong> 。</li><li>睡眠结束后的线程未必会立刻得到执行 </li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。如<code>TimeUnit.SECONDS.sleep(2);</code>表示睡眠2s。</li></ul></li><li><p><code>static currentThread()</code>：获取当前正在执 行的线程</p></li><li><p><code>static yield()</code>：提示线程调度器让出当前线程对 CPU的使用，<strong>线程调度器可以无视这个提示</strong>。<strong>调用该方法时，当前线程会进入就绪状态，线程调度器会重新执行调度，当然有可能重新调度到执行yeild的线程</strong>。</p><ul><li>示例：若没有<code>Thread.yield();</code>，则两个线程打印的count数相差不大；加上<code>Thread.yield();</code>，可以看到线程1明显打印的更快。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----&gt;1 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">               Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;              ----&gt;2 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; </p><p>其他方法：</p><ul><li><p><code>getState()</code></p></li><li><p><code>getId()</code> </p></li><li><p><code>getName()</code> </p></li><li><p><code>setName(String)</code> </p></li><li><p><code>getPriority() </code></p></li></ul><p>停止线程使用“两阶段停止模式”（demo TestTwoPhaseTermination），而不要使用以下过时方法：</p><ul><li>stop() </li><li>suspend() </li><li>resume() static </li></ul><p>&emsp;&emsp;</p><h2 id="理解线程上下文切换"><a href="#理解线程上下文切换" class="headerlink" title="理解线程上下文切换"></a>理解线程上下文切换</h2><p>在多线程编程中线程个数一般都大于CPU个数， 而每个CPU同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行的， CPU资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片， 线程在时间片内占用CPU执行任务。<strong>当前线程使用完时间片后就会处于就绪状态并让出CPU让其他线程占用， 这就是上下文切换</strong>。</p><p>在切换线程上下文时需要保存当前线程的执行现场，当再次执行时根据保存的执行现场信息恢复执行现场。</p><p>&emsp;&emsp;</p><p>概括来说就是：<strong>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>线程上下文切换的时机有：</p><ul><li>当前线程的CPU时间片使用完处于就绪状态时。</li><li>当前线程被其他线程中断时。</li></ul><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>&emsp;&emsp;</p><h2 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h2><p><strong>Java中的线程分为两类， 分别为daemon线程(守护线程) 和user线程(用户线程)</strong> 。在JVM启动时会调用main函数， main函数所在的线程就是一个用户线程， 其实在JVM内部同时还启动了好多守护线程，比如垃圾回收线程。</p><p><strong>当最后一个非守护线程结束时， JVM会正常退出， 而不管当前是否有守护线程， 也就是说， 只要有一个用户线程还没结束，正常情况下JVM就不会退出</strong>。</p><p>创建的线程默认是用户线程，可以通过Thread的<code>setDeamon(true)</code>可将线程设置为守护线程。</p><p>示例demo：TestDeamon。</p><p>&emsp;&emsp;</p><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><h3 id="从OS层面"><a href="#从OS层面" class="headerlink" title="从OS层面"></a>从OS层面</h3><p>从操作系统层面，线程的生命周期包括<strong>新建（New），就绪（Ready），运行（Running），阻塞（Blocked），死亡（Dead）</strong>。CPU在多个线程之间切换时，线程状态也在Ready、Running之间切换。</p><h4 id="新建与就绪状态"><a href="#新建与就绪状态" class="headerlink" title="新建与就绪状态"></a>新建与就绪状态</h4><p><strong>使用new关键字创建一个线程时，该线程即处于新建状态</strong>，此时JVM仅为它分配内存，初始化成员变量的值（与new普通对象一样）。<br><strong>调用start()方法后，线程处于就绪状态</strong>，<strong>JVM为其创建方法调用栈和程序计数器</strong>，<strong>此时线程并没有运行，只是表示其可以运行</strong>，何时运行取决于JVM里线程调度器的调度。 </p><p>&emsp;&emsp;</p><h4 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h4><p>处于就绪状态的线程获得CPU，开始执行run()方法，则<strong>处于运行状态</strong>。如果只有一个CPU，则每个时刻只有一个线程在运行状态。<br>线程调度策略：</p><ul><li><strong>抢占式策略</strong>：系统给每个线程一小段时间处理任务，时间用完后，系统剥夺该线程所占用的资源，让给其他线程。选择下一个线程时，系统会考虑线程优先级。</li><li><strong>协作式调度策略</strong>：只有一个线程调用它的sleep()或yield()方法后才会放弃所占用的资源——即必须由线程主动放弃资源。  </li></ul><p>发生以下情况时，<strong>线程进入阻塞状态</strong>：</p><ul><li>线程调用sleep()。</li><li>线程调用一个阻塞式IO方法，在该方法返回之前。</li><li>线程试图获取一个同步监视器，但该监视器被其他线程所持有。</li><li>线程在等待某个通知（notify）。</li><li>线程调用suspend()方法将该线程挂起。（该方法<strong>容易导致死锁</strong>）  </li></ul><p>当线程被阻塞，其他线程即可获得CPU。被阻塞的线程在合适的时候进入就绪状态（而不是运行状态，解除阻塞后，必须重新等待线程调度器调用它）。<br>发生以下情况时，阻塞的线程进入就绪状态（对应上面的情况）：</p><ul><li>sleep()方法超过指定时间。</li><li>IO方法已返回。</li><li>获得同步监视器。</li><li>线程正在等待通知时，其他线程发出了一个通知。</li><li>被挂起的线程调用resume()恢复方法。</li></ul><h4 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h4><p>线程以如下三种方式结束时死亡：</p><ul><li>run()或call()方法执行完毕。</li><li>抛出Exception或Error。</li><li>调用线程的stop()方法。（<strong>容易导致死锁</strong>）  </li></ul><p>判断某个线程是否已死亡可调用线程的isAlive()方法（<strong>处于新建、死亡状态返回false</strong>，处于就绪、运行、阻塞返回true）。</p><blockquote><ul><li><strong>主线程结束时，其他线程不受影响。一旦子线程启动，就拥有与主线程相同地位</strong>。</li><li>不要对一个已死亡的线程调用start()。  </li></ul></blockquote><p>&emsp;&emsp;</p><h3 id="从Java-API方面"><a href="#从Java-API方面" class="headerlink" title="从Java API方面"></a>从Java API方面</h3><p>（以下图片来自JavaGuide）</p><p>在<strong>Thread中的State枚举类里定义了线程的6种状态</strong>：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215044761.png" alt="image-20210210215044761"></p><p>其中，将OS层面的就绪（Ready）和运行（Running）状态统称为 <strong>RUNNABLE（可运行）</strong> 状态 。</p><blockquote><p>在idea中debug时，BLOCKED状态显示为MONITOR</p></blockquote><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>Java 线程状态变迁如下图（<strong>大概情况</strong>）：（这里join方法应是来自Thread类）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215151522.png" alt="image-20210210215151522" style="zoom: 80%;" /><p>其中的一些情况补充：</p><ul><li><p>WAITING &lt;–&gt; RUNNABLE：调用 <code>obj.notify()  obj.notifyAll()  t.interrupt()</code> 时线程不是直接进入RUNNABLE状态，而是进入EntryList后再竞争锁（<i>对于join、park等应该也是</i>）：</p><ul><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE </li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li></ul></li><li><p>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING。<strong><font color="red">注意是当前线程在t 线程对象的监视器上（具体是在WaitSet上）等待</font></strong>。<br>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 WAITING –&gt; RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：</p><ul><li>t 线程用 <code>synchronized(obj)</code> <strong>获取对象锁时如果竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED </li><li><strong>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争</strong>，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED。</li></ul></li></ul><p>&emsp;&emsp;</p><h2 id="变量的线程安全"><a href="#变量的线程安全" class="headerlink" title="变量的线程安全"></a>变量的线程安全</h2><h3 id="成员变量和静态变量"><a href="#成员变量和静态变量" class="headerlink" title="成员变量和静态变量"></a>成员变量和静态变量</h3><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 <ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul><li>局部变量是线程安全的 </li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的 </li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p>&emsp;&emsp;</p><p>对于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</strong>。</p><p>&emsp;&emsp;</p><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul><li>String、Integer：String、Integer 等都是不可变类，因为<strong>其内部的状态不可以改变</strong>，因此它们的方法都是线程安全的。对于String的replace，substring 等方法，其实质是返回一个新的字符串。</li><li>StringBuffer</li><li>Random </li><li>Vector</li><li>Hashtable </li><li>java.util.concurrent 包下的类</li></ul><p>线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong>。它们的每个方法是原子的，<strong>但注意它们多个方法的组合不是原子的</strong>。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable(); </span><br><span class="line"><span class="comment">// 线程1，线程2 </span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="keyword">null</span>) &#123; </span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种线程不安全的执行示例：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210213172057961.png" alt="image-20210213172057961"></p><p>&emsp;&emsp;</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>死锁是指<strong>两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。发生死锁时，整个程序不会发生任何异常，也不会给出任何提示，如果没有外力作用，这些线程会一直等待，无法继续运行</strong>。</p><p><strong style="color:red">发生死锁的4个条件</strong>：</p><ul><li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li><li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程一资源的环形链，即线程集合{T0，T1，T2，…，Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。</li></ul><p>&emsp;&emsp;</p><p>避免死锁可以通过破坏4个条件的至少一个实现，<strong>而目前只有请求并持有和环路等待条件是可破坏的</strong>。造成死锁的原因和资源申请顺序关系很大，可以使用资源的有序性申请来避免死锁（<strong>破坏环路等待条件</strong>）。有序性即：<strong>假如线程A和线程B都需要资源1，2，3，…，n时，对资源进行排序，<font color="red">线程A和线程B只有在获取了资源n-1时才能去获取资源n</font></strong>。</p><p>&emsp;&emsp;</p><p>一种死锁示例：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">* t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁</span></span><br><span class="line"><span class="comment">* t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                sleep(<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="检测死锁的工具"><a href="#检测死锁的工具" class="headerlink" title="检测死锁的工具"></a>检测死锁的工具</h3><h4 id="jstack命令"><a href="#jstack命令" class="headerlink" title="jstack命令"></a>jstack命令</h4><p>运行上述示例代码，在cmd输入<code>jps</code>，查看线程id，再执行<code>jstack thread_id</code>输出检测结果。</p><p>输出结果的部分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">  waiting to <span class="keyword">lock</span> monitor <span class="number">0x000000000297c178</span> (<span class="keyword">object</span> <span class="number">0x00000000d6b65178</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held <span class="keyword">by</span> <span class="string">&quot;t1&quot;</span></span><br><span class="line"><span class="string">&quot;t1&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">to</span> <span class="keyword">lock</span> monitor <span class="number">0x000000000297e488</span> (<span class="keyword">object</span> <span class="number">0x00000000d6b65188</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held <span class="keyword">by</span> <span class="string">&quot;t2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Java</span> stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;t2&quot;</span>:</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock.lambda$<span class="keyword">main</span>$<span class="number">1</span>(TestDeadLock.java:<span class="number">34</span>)</span><br><span class="line">        - waiting <span class="keyword">to</span> <span class="keyword">lock</span> &lt;<span class="number">0x00000000d6b65178</span>&gt; (a java.lang.Object)</span><br><span class="line">        - <span class="keyword">locked</span> &lt;<span class="number">0x00000000d6b65188</span>&gt; (a java.lang.Object)</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock$$Lambda$<span class="number">2</span>/<span class="number">1879034789.</span>run(<span class="literal">Unknown</span> <span class="keyword">Source</span>)</span><br><span class="line">        <span class="keyword">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">&quot;t1&quot;</span>:</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock.lambda$<span class="keyword">main</span>$<span class="number">0</span>(TestDeadLock.java:<span class="number">23</span>)</span><br><span class="line">        - waiting <span class="keyword">to</span> <span class="keyword">lock</span> &lt;<span class="number">0x00000000d6b65188</span>&gt; (a java.lang.Object)</span><br><span class="line">        - <span class="keyword">locked</span> &lt;<span class="number">0x00000000d6b65178</span>&gt; (a java.lang.Object)</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock$$Lambda$<span class="number">1</span>/<span class="number">942986815.</span>run(<span class="literal">Unknown</span> <span class="keyword">Source</span>)</span><br><span class="line">        <span class="keyword">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Found</span> <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p>进入cmd，输入<code>jconsole</code>，连接线程。</p><p>在线程窗口点击检测死锁，可看到相关信息：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217170359984.png" alt="image-20210217170359984"></p><p>&emsp;&emsp;</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>5个哲学家围在圆桌上用餐，有5根筷子，只有拥有两根筷子才能吃饭，吃完饭会放下筷子思考，如此反复。</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217171857739.png" alt="image-20210217171857739" style="zoom:67%;" /><p>代码：demo位于<code>lock/deadlock/v1/TestPhilosopher.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//　尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p><p>示例：（demo：<code>lock/TestLiveLock.java</code>）</p><p>t1要将count减到0，t2要加到20，由于它们的运算速度相近，导致一直执行不结束。</p><p><strong>可以使用随机sleep时间避免等</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个线程由于优先级太低（或者说长时间运行不了），始终得不到 CPU 调度执行，也不能够结束。</p><p>&emsp;&emsp;</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量，JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 **<code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，</strong>即创建一个变量，每一个线程访问该变量获取的都是该变量在该线程的副本**。</p><p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p><p>&emsp;&emsp;</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote><p><code>sleep(int i)</code>表示睡眠i s</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String str = <span class="string">&quot;str from t1&quot;</span>;</span><br><span class="line">            threadLocal.set(str);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 获取的是自己放置的str，获取不到t2放置的</span></span><br><span class="line">            String str1 = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str after 2s: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获取的str为null，不能获取到t1放置的str</span></span><br><span class="line">            String str = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            String str1 = <span class="string">&quot;str from t2&quot;</span>;</span><br><span class="line">            threadLocal.set(str1);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Thread类包含一个ThreadLocal.ThreadLocalMap成员变量，其实质是一个Map，映射类型是 ThreadLocal-Object，存放多个ThreadLocal的本地副本，</p><p>从Thread类源码开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>即<strong>Thread类中有一个threadLocals和一个inheritableThreadLocals， 它们都是ThreadLocalMap类型（<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类）的变量</strong>， 而<strong>ThreadLocalMap是一个定制化的map，存放多个ThreadLocal变量在当前线程的副本，<code>ThreadLocalMap</code>存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</strong>。</p><p>在默认情况下， 每个线程中的这两个变量都为nll， <strong>只有当前线程第一次调用Thread Local的<code>set()</code>或者<code>get()</code>方法时才会创建它们</strong>。</p><p>从上面可以看出，<strong style="color:red">每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</strong>。<strong>Thread Local就是一个工具壳， 通过它来从当前线程的threadLocals中获取值或放入值</strong>。</p><p>如果调用线程一直不终止， 那么这个本地变量会一直存放在调用线程的thread Locals变量里面， 所以当不需要使用本地变量时可以通过调用Thread Local变量的<code>remove()</code>方法， 从当前线程的thread Locas里面删除该本地变量，避免内存泄漏。</p><p>&emsp;&emsp;</p><p><code>set()</code>、<code>get()</code>的源码简单分析：</p><p><code>set()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// threadLocalMap不为null，修改值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 第一次调用则创建当前线程对应的threadLocalMap，并将value放进去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p><code>get()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 不为null则从中尝试获取值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前ThreadLocal对象为key，从线程的threadLocalMap中尝试获取值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map为null或其中没有当前ThreadLocal对应的值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong style="color:red">可以看到<code>set()</code>、<code>get()</code>方法都是先从当前线程中获取ThreadLocalMap对象</strong>。</li></ul><p>&emsp;&emsp;</p><p><code>setInitialValue()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();<span class="comment">//该方法只是返回一个null</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="comment">// map不为null（表示其中没有当前ThreadLocal对应的值）</span></span><br><span class="line">    <span class="comment">// 放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 否则创建一个ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 并同样放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p><code>createMap()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>Thread、ThreadLoacal、ThreadLoacalMap的关系图解：（图片来自JavaGuide）</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210218180050123.png" alt="image-20210218180050123" style="zoom:80%;" /><h3 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h3><p><strong><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry</strong>。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。<strong>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</strong>。</p><blockquote><p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放但又无法使用，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p></blockquote><p>ThreadLocalMap的静态内部类Entry：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="InheritableThreadLocal-to-be-…"><a href="#InheritableThreadLocal-to-be-…" class="headerlink" title="InheritableThreadLocal(to be …)"></a>InheritableThreadLocal(to be …)</h3><p>&emsp;&emsp;</p><h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h2><p>CPU与主内存之间会添加一级或多级高速缓冲存储器，即Cache。</p><p><strong>在Cache内部是按行存储的， 其中每一行称为一个Cache行</strong>。Cache行是<strong>Cache与主内存进行数据交换的单位</strong>，Cache行的大小一般为2的幂次数字节。当CPU访问某个变量时， 首先会去看CPU Cache内是否有该变量， 如果有则直接从中获取，否则就去主内存里面获取该变量， <strong style="color:red">然后把该变量所在内存区域的一个Cache行大小的内存块（局部性原理）复制到Cache中</strong>。</p><p><strong>由于存放到Cache行的是内存块而不是单个变量， 所以可能会把多个变量存放到一个Cache行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</strong>。</p><p>比如CPU1、CPU2读取了同一个缓存行，若CPU1对其中的一个变量修改，在缓存一致性协议下，CPU2中对应的缓存行就会失效，即破坏了CPU2的一级缓存，CPU2需要到二级缓存查找（甚至到主存），造成性能下降。</p><p>&emsp;&emsp;</p><p>比如有4个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure><p>假设缓存行大小32字节，一个long类型8个字节，当CPU访问a时，会把a及附近的b、c、d一起放入缓存行。</p><p><strong style="color:red">也就是地址连续的多个变量才有可能会被放到一个缓存行中</strong>。比如创建数组时，数组里面的多个元素就会被放入同一个缓存行。</p><p>在正常情况下单线程访问时将数组元素放入一个或者多个缓存行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p><p>测试缓存行demo见<code>test/TestCacheLine</code>。</p><p>&emsp;&emsp;</p><p>JDK8之前使用声明多个填充变量的方法来避免伪共享问题，让一个缓存行只有一个有用变量：</p><p>该例中，若缓存行大小是64B，则value+p1-6是56B，对象头是8B，所以共64B。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>JDK8提供了一个注解<code>@sun.misc.Contended</code>解决伪共享问题，它可以自行执行填充。上面代码可以改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><blockquote><p>需要注意的是， 在默认情况下， @Contended注解只用于Java核心类， 比如rt包下的类。如果用户类路径下的类需要使用这个注解， 则需要添加JVM参数：<code>-XX:-RestrictContended</code>。填充的宽度默认为128，要自定义宽度则可以设置</p><p><code>-XX:ContendedPaddingWidth</code>参数。</p></blockquote><h2 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。</p><p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以<strong>在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态</strong>。</p><blockquote><p>悲观锁的<strong>实现往往依靠数据库提供的锁机制</strong>，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p></blockquote><p>&emsp;&emsp;</p><p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以<strong>在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测</strong>。比如根据update返回的行数让用户决定如何去做。</p><p>乐观锁并不会使用数据库提供的锁机制， 一般在表中添加version字段（<strong>每次根据id和version修改记录，若修改成功，将version+1</strong>）或者使用业务状态来实现。乐观锁直到提交时才锁定，所以不会产生任何死锁。</p><p>&emsp;&emsp;</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，</p><ul><li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的。</li><li>非公平锁则是先来不一定先得。</li></ul><p>Reentrant Lock提供了公平和非公平锁的实现。</p><ul><li>公平锁：<code>Reentrant Lock pair Lock=nhew Reentrant Lock(true)</code> 。</li><li>非公平锁：<code>Reentrant Lock pair Lock=new Reentrant Lock(false) </code>。如果构造函数不传递参数，则默认是非公平锁。</li></ul><p>&emsp;&emsp;</p><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p><strong>独占锁表示一个锁只能被一个线程获取，共享锁则可以被多个线程获取</strong>。</p><p><strong>独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性</strong>，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p><p>&emsp;&emsp;</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>当一个线程可以再次获取它已经获取了的锁，则该锁是可重入的。synchronized内部锁和ReentrantLock都是可重入锁。</p><p>&emsp;&emsp;</p><p>可重入锁的原理是<strong>在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器</strong>。一开始计数器值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁时，计数器的值会变成1，这时其他线程再来获取该锁时<strong>会发现锁的所有者不是自己而被阻塞挂起</strong>。但是当<strong>获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+1</strong>，当释放锁后计数器值-1。当计数器值为0时， 锁里面的线程标示被重置为null， 这时候被阻塞的线程会被唤醒来竞争获取该锁。</p><p>&emsp;&emsp;</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>由于Java中的线程是与操作系统中的线程一一对应的，<strong>所以当一个线程在获取锁(比如独占锁)失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。<font color="red">而从用户状态切换到内核状态的开销是比较大的</font>，在一定程度上会影响并发性能</strong>。</p><p>自旋锁是<strong>当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取</strong>（默认次数是10，可以使用<code>-XX：PreBlockSpinsh</code>参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。</p><p>由此看来自旋锁是使用CPU时间换取线程阳塞与调度的开销， <strong>但是很有可能这些CPU时间白白浪费了</strong>。</p><p>&emsp;&emsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;线程和进程&quot;&gt;&lt;a href=&quot;#线程和进程&quot; class=&quot;headerlink&quot; title=&quot;线程和进程&quot;&gt;&lt;/a&gt;线程和进</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="多线程" scheme="http://example.com/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java并发" scheme="http://example.com/Tag/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="http://example.com/2021/02/18/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2021/02/18/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2021-02-18T05:20:53.928Z</published>
    <updated>2021-03-20T12:51:21.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><p>对于程序计数器、虚拟机栈、本地方法栈，这几个区域的内存分配和回收都具有确定性，它们随着线程结束或方法结束时回收内存。<strong>而堆和方法区则有很大的不确定性：只有到运行期才能知道程序要创建哪些对象，创建多少对象，它们的内存分配和回收是动态的</strong>。</p><p>&emsp;&emsp;</p><p>Java 的自动内存管理<strong>主要是针对对象内存的回收和对象内存的分配</strong>。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong> </p><p><strong>堆空间的基本结构</strong>（图片来自javaGuide）：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129095613698.png" alt="image-20210129095613698"></p><p>&emsp;&emsp;</p><h2 id="判断对象已死"><a href="#判断对象已死" class="headerlink" title="判断对象已死"></a>判断对象已死</h2><p>垃圾收集器对堆回收之前需要判断哪些对象存活，哪些死亡（<strong>即不能再被任何途径使用的对象</strong>）。有<strong>引用计数算法和可达性分析算法</strong>两种判断方式。</p><p>&emsp;&emsp;</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；<strong>任何时候计数器为 0 的对象就是不可能再被使用的</strong>。</p><p>这个方法实现简单，效率高，但是目前<strong>主流的虚拟机中并没有选择这个算法</strong>来管理内存，其最主要的原因是它<strong>很难解决对象之间相互循环引用的问题</strong>。</p><p>循环依赖示例：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，<strong>于是引用计数算法无法通知 GC 回收器回收他们</strong>。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是<strong>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的</strong>。</p><p><strong>可作为 GC Roots 的对象</strong>包括下面几种:</p><ul><li><strong>虚拟机栈</strong>(栈帧中的本地变量表)中引用的对象</li><li><strong>本地方法栈</strong>(Native 方法)中引用的对象</li><li><strong>方法区</strong>中<strong>类静态属性引用</strong>的对象</li><li><strong>方法区</strong>中<strong>常量引用的对象</strong> </li><li>Java虚拟机内部引用，如基本类型对应的Class对象，系统类加载器、常驻异常对象等。</li><li>被同步锁（synchronized关键字）持有的对象。</li></ul><p>&emsp;&emsp;</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p><strong>JDK1.2 之前</strong>，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p><strong>JDK1.2 以后</strong>，Java 对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种（<strong>引用强度逐渐减弱</strong>）。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。<strong>在任何情况下，只要这个强引用存在，垃圾回收器绝不会回收它</strong>。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p>&emsp;&emsp;</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述一些<strong><font color="red">还有用，但非必须的对象</font></strong>。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存</strong>。</p><p>软引用<strong>可以和一个引用队列（ReferenceQueue）联合使用</strong>，如果<strong>软引用所引用的对象被垃圾回收</strong>，JAVA 虚拟机就会<strong>把这个软引用</strong>加入到与之关联的引用队列中。后续可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。</p><p>&emsp;&emsp;</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，<strong style="color:red">它只能生存到下一次垃圾收集发生</strong>。</p><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p>&emsp;&emsp;</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<font color="red">虚引用主要用来跟踪对象被垃圾回收的活动</font></strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用<strong>必须和引用队列</strong>（ReferenceQueue）<strong>联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<strong>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收</strong>。程序如果发现某个虚引用已经被加入到引用队列，那么就<strong>可以在所引用的对象的内存被回收之前采取必要的行动</strong>。</p><p>&emsp;&emsp;</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><p>&emsp;&emsp;</p><h3 id="“非死不可”？"><a href="#“非死不可”？" class="headerlink" title="“非死不可”？"></a>“非死不可”？</h3><p><strong>即使在可达性分析法中不可达的对象，也并非是“非死不可”的</strong>，这时候它们暂时处于“缓刑阶段”，要<strong>真正宣告一个对象死亡，至少要经历两次标记过程</strong>：可达性分析法中不可达的对象被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p><strong>被判定为需要执行的对象将会被放在一个队列中，并由一个低优先级线程去执行它们的<code>finalize()</code>方法</strong>，除非这个对象在<code>finalize()</code>方法中与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><p><strong style="color:red">这种“自救”不推荐被使用</strong>。</p><p>&emsp;&emsp;</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p><strong>方法区也是垃圾回收的对象区域</strong>，这里的垃圾收集主要包含两部分内容：<strong>废弃的常量和不再使用的类型</strong>。方法区的垃圾收集通常“性价比”比较低。</p><h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><p>运行时常量池主要回收的是废弃的常量。判断一个常量是否废弃：</p><p><strong>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了</strong>。</p><p>&emsp;&emsp;</p><p><strong><font color="red">关于常量池，方法区，元空间</font></strong>：</p><ol><li>JDK1.7 <strong>之前</strong>运行时常量池逻辑包含字符串常量池存放在方法区， 此时 HotSpot 虚拟机对方法区的实现为永久代</li><li><strong>JDK1.7  字符串常量池 被从方法区拿到了堆中</strong>， 这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区， 也就是 HotSpot 中的永久代 。</li><li>JDK1.8 HotSpot 移除了永久代用元空间(Metaspace)取而代之，<strong><font color="red"> 这时候字符串常量池还在堆， 运行时常量池还在方法区， 只不过方法区的实现从永久代变成了元空间</font></strong>(Metaspace)。</li></ol><p>&emsp;&emsp;</p><h4 id="回收类"><a href="#回收类" class="headerlink" title="回收类"></a>回收类</h4><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p><p>类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><blockquote><p>在大量使用反射、动态代理、CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 通常都需要Java虚拟机具备类型卸载的能力， <strong>以保证不会对方法区造成过大的内存压力</strong>。</p></blockquote><p>&emsp;&emsp;</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集理论的3个经验法则：</p><ul><li><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p></li><li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p></li><li><p>跨代引用假说：跨代引用相对于同代引用来说占极少数。</p><blockquote><p>假如要进行一次只局限于新生代区域内的收集(Minor GC) ， <strong>但新生代中的对象是完全有可能被老年代所引用的</strong>， 为了找出该区域中的存活对象， 不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。但无疑会为内存回收带来很大的性能负担。为了解决这个问题，于是添加了第3个经验法则。</p></blockquote></li></ul><p>&emsp;&emsp;</p><p>分代收集理论放到具体的JVM中，设计者一般至少把Java堆划分为新生代和老年代。在Java堆划分出不同的区域之后，<strong>垃圾收集器才可以每次只回收其中某一个或者某些部分的区域</strong>——因而有了“Minor GC”、“Major GC”、“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。</p><p>&emsp;&emsp;</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</strong>。（或者反过来标记不需要回收的对象）</p><p>它是<strong>最基础的收集算法，后续的算法都是对其不足进行改进得到</strong>。这种垃圾收集算法会带来两个明显的问题：</p><ul><li><p><strong>效率问题</strong>。如果堆中很多对象需要回收，这时必须进行大量清除和标记的动作。</p></li><li><p><strong>内存碎片问题（标记清除后会产生大量不连续的碎片）</strong> </p></li></ul><p>&emsp;&emsp;</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。<strong>它将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收</strong>。</p><p>这样实现简单，运行高效，<strong>缺陷也明显，可用内存缩小了一半，且当对象存活率较高时，该算法效率较低</strong>。</p><p>&emsp;&emsp;</p><p>针对内存浪费太多的改进（Appel式回收）：<strong>把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间</strong>。HotSpot虚拟机<strong>默认Eden和Survivor的大小比例是8：1</strong>， 只有10%的新生代是会被“浪费”的。</p><p>但也没有办法保证每次回收都只有不多于10%的对象存活， 因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计， 当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（<strong>实际上大多就是老年代</strong>）进行分配担保(Handle Promotion) </p><p>&emsp;&emsp;</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法不适合老年代，因为老年代的回收率低，需要复制的对象太多。<strong style="color:red">标记-整理算法是针对老年代的</strong>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<strong>而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</strong>。</p><p>图示（来自JavaGuide）：</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129150506762.png" alt="image-20210129150506762"></p><p>&emsp;&emsp;</p><p>标记-清除、标记-整理的<strong>本质区别在于是不是移动式的回收算法</strong>。是否移动对象都存在弊端：</p><ul><li>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，<strong>移动存活对象并更新所有引用这些对象的地方</strong>将会是一种极为负重的操作，<strong>而且这种对象移动操作必须全程暂停用户应用程序才能进行</strong>（“<strong style="color:red">Stop The World</strong>”）。</li><li>但如果完全不考虑移动和整理存活对象，<strong>弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配策略来解决</strong>。</li></ul><p><strong>移动则内存回收时会更复杂，不移动则内存分配时会更复杂</strong>。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是<strong style="color:red">从总的来说，移动对象会更划算</strong>。</p><p>&emsp;&emsp;</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块</strong>。一般将 java 堆分为新生代和老年代，<strong style="color:red">这样就可以根据各个年代的特点选择合适的垃圾收集算法</strong>。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><blockquote><p> <strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？根据上面的对分代收集算法的介绍回答。</p></blockquote><p>&emsp;&emsp;</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器。这个收集器是一个<strong>单线程收集器</strong>。它的 <strong>“单线程” 的意义</strong>不仅仅意味着它<strong>只会使用一条垃圾收集线程去完成垃圾收集工作</strong>，<strong style="color:red">而且它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束</strong>。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。如图（来自《深入理解JVM》</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155016436.png" alt="image-20210129155016436"></p><p>Serial不是已无用的”鸡肋“，<strong>它是HotSpot运行在客户端模式下的默认<font color="red">新生代</font>收集器</strong>。它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器<strong>没有线程交互的额外开销</strong>，可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><p>&emsp;&emsp;</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样</strong>。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。（图片来自JavaGuide)</p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155850631.png" alt="image-20210129155850631" style="zoom:80%;" /><p><strong>它是许多运行在 Server 模式下的虚拟机的首要选择</strong>，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。</p><p><strong>在谈论垃圾收集器的上下文语境中，并行和并发概念可理解为：</strong> </p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，通常默认<strong>此时用户线程仍然处于等待状态</strong>。</li><li><strong>并发（Concurrent）</strong>：指<strong>用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行）</strong>，用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><p>&emsp;&emsp;</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器也是<strong>使用复制算法的新生代多线程收集器，看上去几乎和 ParNew 一样</strong>。</p><p>其不同点在于：CMS 等垃圾收集器的关注点更多的是用户线程的<strong>停顿时间</strong>，而<strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）</strong>。停顿时间短，可以让用户有更好的体验；高吞吐量则可以充分利用处理器资源，<strong>适合在后台运算而不需要过多交互的任务</strong>。</p><p>所谓<strong>吞吐量</strong>就是 <strong>CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值</strong>。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合<strong>自适应调节策略</strong>，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性</strong>。</p><p>  &emsp;&emsp;</p><p><strong>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old</strong>，如果指定了<code>-XX:+UseParallelGC</code> 参数，则默认指定了</p><p><code>-XX:+UseParallelOldGC</code>，可以使用<code>-XX:-UseParallelOldGC</code> 来禁用该功能。</p><p>  &emsp;&emsp;</p><p>新生代采用复制算法，老年代采用标记-整理算法。（图片来自JavaGuide）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130154438990.png" alt="image-20210130154438990"></p><p>&emsp;&emsp;</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial收集器的老年代版本，使用标记-整理算法，它同样是一个单线程收集器</strong>。该收集器主要也是供客户端模式下的HotSpot使用。如果在<strong>服务端模式下，主要有两大用途</strong>：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p>&emsp;&emsp;</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法</strong>。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器组合使用。</p><p>&emsp;&emsp;</p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep，并发标记清除）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用</strong>。CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它<strong style="color:red">第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。（并发收集、低停顿）</p><p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<strong>整个过程分为四个步骤</strong>：</p><ul><li><strong>初始标记</strong>（<strong style="color:red">STW</strong>）： 暂停所有的其他线程，并记录下<strong>直接与 root 相连的对象</strong>，速度很快 ；</li><li><strong><font color="red">并发</font>标记</strong>： <strong>GC 和用户线程一起并发运行，从GC Roots的直接关联对象开始遍历整个对象图</strong>。但在这个阶段结束，并不能保证扫描完当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以<strong>这个算法里会跟踪记录这些发生引用更新的地方</strong>。</li><li><strong>重新标记</strong>（<strong style="color:red">STW</strong>）： 重新标记阶段就是为了<strong>修正并发标记期间因为用户程序继续运行而导致标记产生变动</strong>的那一部分对象的<strong>标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</strong>。</li><li><strong><font color="red">并发</font>清除</strong>： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p>（图片来自JavaGuide）</p><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130162109512.png" alt="image-20210130162109512"></p><p>&emsp;&emsp;</p><p><strong>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的</strong>。</p><p>&emsp;&emsp;</p><p>CMS收集器有下面三个明显的缺点：</p><ul><li><p><strong>对 CPU 资源敏感；</strong> </p></li><li><p><strong>无法处理浮动垃圾； 且在垃圾收集阶段还需要预留足够内存空间提供给用户线程使用</strong>， 在JDK 5的默认设置下， CMS收集的阈值是68%。JDK 6时，阈值默认提升至92%。但如果预留的内存无法满足程序分配新对象的需要， 就会出现一次“<strong>并发失败</strong>”(Concurrent Mode Failure) ， <strong>这时虚拟机将启动后备预案：冻结用户线程的执行， 临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了</strong>。</p><blockquote><p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p></blockquote></li><li><p><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></p></li></ul><p>&emsp;&emsp;</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</strong>。它开创了<strong>收集器面向局部收集</strong>的设计思路和<strong>基于Region的内存布局</strong>形式。</p><blockquote><p>JDK9发布时，G1取代Parallel Scavenge+Parallel Old组合，是服务端模式下的默认收集器，而CMS被声明为不被推荐。</p></blockquote><p>&emsp;&emsp;</p><p><strong>基于Region的内存布局</strong>：</p><p>在G1收集器出现之前的所有其他收集器， 包括CMS在内， 垃圾收集的目标范围要么是整个新生代(MinorGC) 、整个老年代(Major GC) 、或整个Java堆(Full GC) 。<strong>而G1可以面向堆内存任何部分来组成回收集(Collection Set， 一般简称CSet) 进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大</strong>， 这就是G1收集器的Mixed GC模式。</p><p>G1仍是遵循分代收集理论，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分， <strong>而是把连续的Java堆划分为多个大小相等的独立区域(Region) ， 每一个Region都可以根据需要， 扮演新生代的Eden空间、Survivor空间，或者老年代空间</strong>。</p><blockquote><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围为1MB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中， </p></blockquote><p>&emsp;&emsp;</p><p>总结G1的一些特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的</strong>。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，停顿时间模型即<strong>支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标</strong>。</li></ul><p>&emsp;&emsp;</p><p>G1 收集器的运作大致分为以下几个步骤（具体P101）：</p><ul><li><strong>初始标记</strong> （<strong style="color:red">短暂STW</strong>）</li><li><strong>并发标记</strong> </li><li><strong>最终标记</strong> （<strong style="color:red">短暂STW</strong>）</li><li><strong>筛选回收</strong> （<strong style="color:red">STW</strong>）</li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（这也就是它的名字 Garbage-First 的由来）</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p>&emsp;&emsp;</p><h3 id="Shenandoah收集器-to-be…"><a href="#Shenandoah收集器-to-be…" class="headerlink" title="Shenandoah收集器(to be…)"></a>Shenandoah收集器(to be…)</h3><p>&emsp;&emsp;</p><h3 id="ZGC收集器-to-be…"><a href="#ZGC收集器-to-be…" class="headerlink" title="ZGC收集器(to be…)"></a>ZGC收集器(to be…)</h3><p><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a> </p><p>&emsp;&emsp;</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide-Note</a> </p><p>《深入理解JVM》第3版</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。&lt;/p&gt;
&lt;p&gt;对</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    <category term="JVM" scheme="http://example.com/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/Tag/JVM/"/>
    
  </entry>
  
</feed>
