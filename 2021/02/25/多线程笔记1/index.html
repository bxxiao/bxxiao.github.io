<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多线程笔记1 | bxxiao</title><meta name="keywords" content="Java多线程,并发"><meta name="author" content="bxxiao"><meta name="copyright" content="bxxiao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 概述1.1 线程和进程1) 进程一个程序进入内存运行时，即变成一个进程。进程是代码在数据集合上的一次运行活动；进程是系统进行资源分配和调度的一个独立单位。  进程的三个特征：  独立性：拥有独立的资源、私有的地址空间。未经允许的情况下，一个进程不能直接访问其他的进程。 动态性：程序是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程具有自己的生命周期和各种不同状态。 并发性：多个">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程笔记1">
<meta property="og:url" content="http://example.com/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/index.html">
<meta property="og:site_name" content="bxxiao">
<meta property="og:description" content="1. 概述1.1 线程和进程1) 进程一个程序进入内存运行时，即变成一个进程。进程是代码在数据集合上的一次运行活动；进程是系统进行资源分配和调度的一个独立单位。  进程的三个特征：  独立性：拥有独立的资源、私有的地址空间。未经允许的情况下，一个进程不能直接访问其他的进程。 动态性：程序是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程具有自己的生命周期和各种不同状态。 并发性：多个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/wallhaven-137lo1.jpg">
<meta property="article:published_time" content="2021-02-24T16:21:20.469Z">
<meta property="article:modified_time" content="2021-02-26T12:14:51.527Z">
<meta property="article:author" content="bxxiao">
<meta property="article:tag" content="Java并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/wallhaven-137lo1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-02-26 20:14:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/zfe-2.0@1.15/css/cardlistpost.css"/><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/bxgitee/noteImage/raw/master/image/567.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/Tag/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/JVM/"><i class="fa-fw fas fa-folder-open"></i><span> JVM</span></a></li><li><a class="site-page" href="/categories/Java/"><i class="fa-fw fas fa-folder-open"></i><span> Java</span></a></li><li><a class="site-page" href="/categories/Java%E5%B9%B6%E5%8F%91/"><i class="fa-fw fas fa-folder-ope"></i><span> Java并发</span></a></li><li><a class="site-page" href="/categories/MySQL/"><i class="fa-fw fas fa-folder-open"></i><span> MySQL</span></a></li><li><a class="site-page" href="/categories/%E6%A1%86%E6%9E%B6/"><i class="fa-fw fas fa-folder-open"></i><span> 框架</span></a></li><li><a class="site-page" href="/categories/%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"><i class="fa-fw fas fa-folder-open"></i><span> 有的没的</span></a></li><li><a class="site-page" href="/categories/IDEA/"><i class="fa-fw fas fa-folder-open"></i><span> IDEA</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Tag/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/wallhaven-137lo1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">bxxiao</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/JVM/"><i class="fa-fw fas fa-folder-open"></i><span> JVM</span></a></li><li><a class="site-page" href="/categories/Java/"><i class="fa-fw fas fa-folder-open"></i><span> Java</span></a></li><li><a class="site-page" href="/categories/Java%E5%B9%B6%E5%8F%91/"><i class="fa-fw fas fa-folder-ope"></i><span> Java并发</span></a></li><li><a class="site-page" href="/categories/MySQL/"><i class="fa-fw fas fa-folder-open"></i><span> MySQL</span></a></li><li><a class="site-page" href="/categories/%E6%A1%86%E6%9E%B6/"><i class="fa-fw fas fa-folder-open"></i><span> 框架</span></a></li><li><a class="site-page" href="/categories/%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"><i class="fa-fw fas fa-folder-open"></i><span> 有的没的</span></a></li><li><a class="site-page" href="/categories/IDEA/"><i class="fa-fw fas fa-folder-open"></i><span> IDEA</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Tag/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程笔记1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-24T16:21:20.469Z" title="发表于 2021-02-25 00:21:20">2021-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-26T12:14:51.527Z" title="更新于 2021-02-26 20:14:51">2021-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-线程和进程"><a href="#1-1-线程和进程" class="headerlink" title="1.1 线程和进程"></a>1.1 线程和进程</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1) 进程"></a>1) 进程</h4><p>一个程序进入内存运行时，即变成一个进程。进程是代码在数据集合上的一次运行活动；<strong>进程是系统进行资源分配和调度的一个独立单位</strong>。 </p>
<p>进程的三个特征：</p>
<ul>
<li><strong>独立性</strong>：拥有独立的资源、私有的地址空间。未经允许的情况下，一个进程不能直接访问其他的进程。</li>
<li><strong>动态性</strong>：程序是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程具有自己的生命周期和各种不同状态。</li>
<li><strong>并发性</strong>：多个进程可以在单个处理器上并发执行，进程之间不会互相影响。</li>
</ul>
<p>并发和并行：</p>
<ul>
<li>并发：指同一时刻，只有一条指令执行，但多个进程指令快速轮换执行。<strong>CPU执行指令即为并发执行</strong>。“<strong>微观串行，宏观并行</strong>”。（单核CPU）</li>
<li>并行：同一时刻多个指令同时执行（多核CPU）。</li>
<li>对于多核OS，既有并行又有并发。</li>
</ul>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2) 线程"></a>2) 线程</h4><p><strong>线程是进程中的一个实体，线程本身是不会独立存在的</strong>。线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p>
<p>操作系统在分配资源时是把资源分配给进程的的， 但是<strong>CPU资源是被分配到线程的， 因为真正要占用CPU运行的是线</strong>程，所以也说<strong>线程是CPU分配的基本单位</strong>。在Java中，<strong>当启动main函数时其实就启动了一个JVM的进程， 而main函数所在的线程就是这个进程中的一个线程，也称主线程</strong>。</p>
<p>&emsp;&emsp;</p>
<p>一个进程可以同时并发处理多个任务（即执行多个线程）。线程也被称作轻量级进程。线程是进程的执行单元。<strong>线程是一个指令流</strong>。</p>
<p><strong>于绝大多数的应用程序来说，通常仅要求有一个主线程，但也可以在该进程内创建多条顺序执行流，这些顺序执行流就是线程，每个线程也是互相独立的。</strong>   </p>
<ul>
<li><strong>线程拥有自己的堆栈、自己的程序计数器和自己的局部变量</strong>，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。多个线程共享父进程里的全部资源，需要确保线程不会妨碍同一进程里的其他线程。</li>
<li>线程是独立运行的，它并不知道进程中是否还有其他线程存在。<strong>线程的执行是抢占式</strong>(当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。)</li>
<li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li>
<li>多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行.</li>
<li>线程的调度和管理由进程本身负责完成。</li>
<li>一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程.</li>
</ul>
<p><strong><em>归纳</em></strong>：<br><strong>操作系统可以同时执行多个任务，每个任务即为一个进程；进程可同时执行多个任务，每个任务即为一个线程。单线程只有一个顺序执行流，多线程有多个，多个顺序流之间互不干扰。</strong></p>
<h3 id="1-2-多线程相比于多进程的优势"><a href="#1-2-多线程相比于多进程的优势" class="headerlink" title="1.2 多线程相比于多进程的优势"></a>1.2 多线程相比于多进程的优势</h3><p>（为什么使用多线程而不是用多进程）</p>
<ul>
<li>进程中线程隔离程度小，使得多线程程序并发性高。</li>
<li>进程之间不能共享内存，而线程可以，运行效率高。</li>
<li>创建进程系统需为该进程分配独立内存空间，并分配大量资源，而创建线程代价小得多。</li>
<li>Java语言内置多线程功能支持。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="1-3-同步和异步"><a href="#1-3-同步和异步" class="headerlink" title="1.3 同步和异步"></a>1.3 同步和异步</h3><p>从方法调用的角度来讲，</p>
<ul>
<li>如果需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p>同步在多线程中还有另外一层意思，是让多个线程步调一致</p>
<p>&emsp;&emsp;</p>
<h3 id="1-4-查看进程线程的方法"><a href="#1-4-查看进程线程的方法" class="headerlink" title="1.4 查看进程线程的方法"></a>1.4 查看进程线程的方法</h3><ul>
<li>windows<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程 </li>
<li>tasklist 查看进程 </li>
<li>taskkill 杀死进程</li>
</ul>
</li>
<li>linux<ul>
<li><code>ps -fe</code> 查看所有进程 </li>
<li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程 </li>
<li><code>kill</code> 杀死进程 </li>
<li><code>top</code> 按大写 H 切换是否显示线程 </li>
<li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li>
</ul>
</li>
<li>Java<ul>
<li>jps 命令查看所有 Java 进程 </li>
<li>jstack &lt;PID&gt; 查看某个 Java 进程（PID）的所有线程状态 </li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<hr>
<h2 id="2-线程的3种创建方式"><a href="#2-线程的3种创建方式" class="headerlink" title="2. 线程的3种创建方式"></a>2. 线程的3种创建方式</h2><p>Java使用<strong>Thread类</strong>代表线程，每个线程对象都是Thread类实例或Thread类的子类实例。<br>每个线程的作用是完成一定的任务，即执行一段程序流。Java使用线程执行体来代表这段程序流。</p>
<h3 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h3><p>定义Thread类子类，重写run()方法。<strong>run()<em>方法的方法体代表线程要完成的任务</em></strong>。  </p>
<p>Thread类常用方法：</p>
<ul>
<li>run()</li>
<li>start()</li>
<li>getName()<br>获取调用该方法的线程的名字</li>
<li>Thread.currentThread()<br>Thread类的静态方法，返回<strong>当前正在执行</strong>的线程对象（返回值为Thread）。</li>
</ul>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">				<span class="keyword">new</span> FirstTread().start();</span><br><span class="line">				<span class="keyword">new</span> FirstTread().start();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或使用匿名内部类方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;thread is running...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><strong>使用继承Thread类的方法创建线程时，多个线程之间无法共享线程类的实例变量（每个线程都是独立的）</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h3><p>Runnable接口是一个函数式接口，包含一个<code>run()</code>方法。<strong>通过实现该接口来创建线程任务</strong>。</p>
<p>eg:</p>
<p>1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByRunnable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Runnable runnable = () -&gt; log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(; i &lt; <span class="number">100</span> ;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> +i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">		    <span class="comment">//通过该方法创建线程，要获取线程名称只能通过currentThread()调用getName()</span></span><br><span class="line">		    <span class="comment">//无法通过this引用直接调用getName()</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">				SecondThread st = <span class="keyword">new</span> SecondThread();</span><br><span class="line">				<span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line">				<span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>该例子的两个子线程共享i变量（两个子线程输出的i变量是连续的）。</strong><br><strong>即采用同一个Runnable变量创建的线程可共享线程类的实例变量。</strong></p>
<p>&emsp;&emsp;</p>
<p>使用该方法将线程和任务分开，更加灵活。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-3-使用FutureTask"><a href="#2-3-使用FutureTask" class="headerlink" title="2.3 使用FutureTask"></a>2.3 使用FutureTask</h3><p>FutureTask的继承关系：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210115247727.png" alt="image-20210210115247727"></p>
<p>FutureTask中封装了一个Callable接口。</p>
<p>Callable接口<strong>提供一个call()方法作为线程执行体</strong>，与run()方法相比：</p>
<ul>
<li>call()方法有返回值。</li>
<li>call()方法可以抛出异常。</li>
</ul>
<p>Callable接口的call()方法并不是直接调用，而是作为线程执行体被调用。</p>
<p>Future的几个控制与他关联的Callable任务公共方法：</p>
<ol>
<li><code>boolean cancel( boolean maylnterruptlfrunnin)</code>：试图取消该Future里关联的 Callable任务。</li>
<li><code>V get()</code>:返回 Callable任务里call()方法的返回值。<strong>调用该方法将导致程序阻塞，必须等到子线程结束后才会得到返回值（其他线程将被阻塞，直到该子线程执行完毕并返回对应值）</strong>。</li>
<li><code>V get(long timeout， Timeunit unit)</code>:返回 Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出Timeoutexception异常。</li>
<li><code>boolean isCancelled()</code>:如果在Callable任务正常完成前被取消，则返回true。</li>
<li><code>boolean isDone()</code>:如果 Callable任务已完成，则返回true。  </li>
</ol>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread&#x27;s running...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;the return value of the task: &quot;</span> + task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程的返回值通过FutureTask对象的get()方法获取，<strong>且当调用该方法时当前线程会阻塞，直到FutureTask执行完毕才返回，若是在调用线程的<code>start()</code>方法之前调用get方法，会陷入死锁</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-4-三种方式优缺点"><a href="#2-4-三种方式优缺点" class="headerlink" title="2.4 三种方式优缺点"></a>2.4 三种方式优缺点</h3><p>通过实现Runnable、Callable接口创建多线程的优缺点：  </p>
<ul>
<li>线程类只是实现了对应接口，可继承其他的类。</li>
<li>多个线程可以共享一个target对象。适合多个相同线程处理同一份资源的情况。<strong>可以将CPU、代码和数据分开，形成清晰的模型，体现面向对象的思想</strong>。</li>
<li>劣势：编程稍稍复杂，访问当前线程只能用<code>Thread.currentThread()</code>方法。  </li>
</ul>
<p>继承Thread方法的优缺点：</p>
<ul>
<li>劣势：<strong>不可继承其他父类</strong>。</li>
<li>优势：编写简单。<strong>使用当前线程可直接使用this</strong>。</li>
</ul>
<p>Runnable、继承Thread都不能获取线程返回值，使用FutrueTask可以获取返回值，且<code>call()</code>方法可以抛出异常。</p>
<p><strong>推荐方法为实现Runnable接口、Callable接口</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="3-线程中的常用方法"><a href="#3-线程中的常用方法" class="headerlink" title="3. 线程中的常用方法"></a>3. 线程中的常用方法</h2><h3 id="3-1-wait、notify、notifyAll"><a href="#3-1-wait、notify、notifyAll" class="headerlink" title="3.1 wait、notify、notifyAll"></a>3.1 wait、notify、notifyAll</h3><p>wait、notify、notifyAll是<strong>Object类中的实例方法</strong>。</p>
<p>3个api：</p>
<ul>
<li><code>wait()</code> 让进入 object 监视器的线程到 waitSet <strong>一直</strong>等待 </li>
<li><code>wait(long n)</code> 等待直到时间超时后进入EntryList</li>
<li><code>notify()</code> 在 object 上正在 waitSet 等待的线程中随机唤醒一个。<strong>interrupt()可以叫醒wait中的线程</strong>。</li>
<li><code>notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1) 原理"></a>1) 原理</h4><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210216174346353.png" alt="image-20210216174346353"></p>
<ul>
<li><p>Owner 线程发现条件不满足时，<strong>调用 wait 方法，进入 WaitSet 变为 WAITING 状态，等待被唤醒</strong> 。</p>
</li>
<li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </p>
</li>
<li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </p>
</li>
<li><p>而WAITING 线程只能<strong>在 Owner 线程中调用 notify 或 notifyAll 唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</strong>。</p>
</li>
<li><p><strong><font color="red">当前线程必须拥有对象的monitor才能调用这些api，否则抛出IllegalMonitorStateException异常</font></strong>。<code>wait()</code>的JavaDoc：</p>
<p><code>The current thread must own this object&#39;s monitor  </code> </p>
<blockquote>
<p>注意是1个对象对应1个monitor</p>
</blockquote>
</li>
<li><p><strong>当前线程调用<code>wait()</code>只会释放当前该共享变量的锁，而该线程的其他锁是不会释放的</strong>。</p>
</li>
<li><p>被唤醒的线程不能马上从wait方法返回并继续执行， 它<strong>必须在获取了共享对象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行</strong>。</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h4 id="2-使用的正确姿势"><a href="#2-使用的正确姿势" class="headerlink" title="2) 使用的正确姿势"></a>2) 使用的正确姿势</h4><p><strong>sleep和 wait的异同</strong>：</p>
<ol>
<li><p>sleep 是 Thread 方法，而 wait 是 Object 的方法 </p>
</li>
<li><p>sleep 不需要强制和 synchronized 配合使用，<strong>但 wait 需要 和 synchronized 一起用</strong> </p>
</li>
<li><p><strong><font color="red">sleep在睡眠的同时不会释放对象锁，但 wait 在等待的时候会释放对象锁 </font></strong>。</p>
</li>
<li><p>它们状态都是TIMED_WAITING。</p>
</li>
</ol>
<p>&emsp;&emsp;</p>
<p>以下姿势对应的demo在<code>practice/useWaitNotifyOBBK</code>包下。</p>
<p><strong>姿势1</strong>：某些条件不满足时调用sleep会占用锁，使用wait更合理。</p>
<p><strong>姿势2</strong>：若是有多个线程在WaitSet，则不宜使用<code>notify()</code>，它只能随机唤醒一个，不能唤醒满足条件的线程。应使用<code>notifyAll()</code>（显然会唤醒部分不满足条件的线程）。</p>
<p><strong>姿势3</strong>：使用循环进行<code>wait()</code>，不满足条件则一直等。<strong>一个线程即使没有被其他线程调用<code>notify()</code>、<code>notifyAll()</code>方法进行通知、或者被中断、或者等待超时，也可以被唤醒，这就是所谓的虚假唤醒</strong>。虽然虚假唤醒很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	<span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">		lock.wait();</span><br><span class="line">	&#125; <span class="comment">// 干活 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程 </span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	lock.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="3-2-park、unpark"><a href="#3-2-park、unpark" class="headerlink" title="3.2 park、unpark"></a>3.2 park、unpark</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1) 概述"></a>1) 概述</h4><p>它们是 LockSupport 类中的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程 </span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行 </span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>

<p>与 Object 的 wait &amp; notify 相比 </p>
<ul>
<li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p>
</li>
<li><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 </p>
</li>
<li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2) 原理"></a>2) 原理</h4><p><strong>每个线程都关联一个 Parker 对象</strong>，由三部分组成 _counter ， _cond 和 _mutex</p>
<ul>
<li>_counter ：值为0或1，调用park时若<code>_count</code>为0则当前线程阻塞，为1则将其减1并继续运行，无需阻塞。</li>
<li>_cond：相当于阻塞队列。</li>
<li>_mutex：互斥锁，操作<code>_count</code>时需要获取该锁？。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>先调用<code>park()</code>，再调用<code>unpark()</code>过程解析：</p>
<ul>
<li>调用<code>park()</code>：</li>
</ul>
<ol>
<li><p>当前线程调用 Unsafe.park() 方法 </p>
</li>
<li><p>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁 </p>
</li>
<li><p>线程<strong>进入 _cond 条件变量阻塞</strong> </p>
</li>
<li><p><strong>设置 _counter = 0</strong> </p>
</li>
</ol>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217142957852.png" alt="image-20210217142957852" style="zoom: 67%;" />

<ul>
<li>调用<code>unpark()</code>：</li>
</ul>
<ol>
<li><p>设置 _counter 为 1 </p>
</li>
<li><p>唤醒 _cond 条件变量中的 Thread_0 </p>
</li>
<li><p>Thread_0 恢复运行 </p>
</li>
<li><p>设置 _counter 为 0</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143224158.png" alt="image-20210217143224158" style="zoom:67%;" />

</li>
</ol>
<p>&emsp;&emsp;</p>
<p>先调用<code>unpark()</code>，再调用<code>park()</code>过程解析：</p>
<ol>
<li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 </p>
</li>
<li><p>当前线程调用 Unsafe.park() 方法 </p>
</li>
<li><p><strong>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</strong>  </p>
</li>
<li><p>设置 _counter 为 0</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143503716.png" alt="image-20210217143503716" style="zoom:67%;" />

</li>
</ol>
<h3 id="3-3-interrupt"><a href="#3-3-interrupt" class="headerlink" title="3.3 interrupt"></a>3.3 interrupt</h3><p>以下api都是Thread类的方法。</p>
<ul>
<li><p><code>interrupt()</code>：中断线程，<strong style="color:red">但其实只是将线程的中断标志置为true，线程还是会继续运行</strong>。</p>
<ul>
<li><strong>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记</strong> ；</li>
<li>否则，<strong>仅仅设置打断标记 ，但并不会使线程停止（即调用interrupt只是让线程知道有人要终止它，它可以先进行某些处理后再自行终止线程）</strong>。</li>
<li>被<code>LockSurpport.park()</code><strong>暂停</strong>的线程被打断则会继续运行，<strong>且会设置打断标记为true</strong>。</li>
</ul>
<p>**demo见<code>JavaConcurrentDemo/trhead_basic/TestInterrupt</code>**。</p>
</li>
<li><p><code>isInterrupted()</code>：返回中断标志，<strong>不清除中断标志</strong>。</p>
</li>
<li><p><code>static interrupted()</code>：判断当前线程是否被打断。<strong>清除中断标记（即将中断标志置false）</strong>。<strong>注意是静态方法</strong>。</p>
<ul>
<li><p>该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要注意返回的是<font color="red">“当前线程”</font>的中断标志</strong>。</p>
</li>
</ul>
</li>
<li><p><code>private native boolean isInterrupted(boolean ClearInterrupted)</code>：私有方法，返回中断标志，并根据ClearInterrupted参数决定是否清除中断标志，上面2个方法都是调用了该方法。</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="3-4-Thread类方法"><a href="#3-4-Thread类方法" class="headerlink" title="3.4 Thread类方法"></a>3.4 Thread类方法</h3><ul>
<li><p><code>start()</code>：启动一个新线程，在新的线程运行run方法中的代码。<strong>start方法只是让线程进入就绪，里面代码不一定立刻运行</strong>（CPU的时间片还没分给它）。<strong>每个线程对象的 start方法只能调用一次</strong>，如果调用了多次会出IllegalThreadStateException</p>
</li>
<li><p><code>run()</code>：如果在构造Thread对象时传递了 Runnable 参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为。</p>
</li>
<li><p><code>join()</code> ：<strong>在当前线程中阻塞，直到指定线程运行结束，<font color="red">注意此时当前线程是在指定线程对象上的monitor等待（即在该monitor的WaitSet上）</font></strong>。其他线程调用因<code>join()</code>阻塞线程的<code>interrupt()</code>方法时，被打断程序会抛出InterruptedException 并返回。</p>
</li>
<li><p><code>join(long n) </code>：等待线程运行结束,最多等待 n 毫秒</p>
</li>
<li><p><code>setPriority(int)</code> ：线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用。</p>
</li>
<li><p><code>isAlive()</code>：线程是否存活 （还没有运行完毕）</p>
</li>
<li><p><code>sleep()</code>：</p>
</li>
<li><p>在一些<code>while(true)</code>中可以使用sleep来避免占用过多的cpu用于空转。</p>
<ul>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） </li>
<li><strong>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时线程会抛出 InterruptedException并返回</strong> 。</li>
<li>睡眠结束后的线程未必会立刻得到执行 </li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。如<code>TimeUnit.SECONDS.sleep(2);</code>表示睡眠2s。</li>
</ul>
</li>
<li><p><code>static currentThread()</code>：获取当前正在执 行的线程</p>
</li>
<li><p><code>static yield()</code>：提示线程调度器让出当前线程对 CPU的使用，<strong>线程调度器可以无视这个提示</strong>。<strong>调用该方法时，当前线程会进入就绪状态，线程调度器会重新执行调度，当然有可能重新调度到执行yeild的线程</strong>。</p>
<ul>
<li>示例：若没有<code>Thread.yield();</code>，则两个线程打印的count数相差不大；加上<code>Thread.yield();</code>，可以看到线程1明显打印的更快。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----&gt;1 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">               Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;              ----&gt;2 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp; </p>
<p>其他方法：</p>
<ul>
<li><p><code>getState()</code></p>
</li>
<li><p><code>getId()</code> </p>
</li>
<li><p><code>getName()</code> </p>
</li>
<li><p><code>setName(String)</code> </p>
</li>
<li><p><code>getPriority() </code></p>
</li>
</ul>
<p>停止线程使用“两阶段停止模式”（demo TestTwoPhaseTermination），而不要使用以下过时方法：</p>
<ul>
<li>stop() </li>
<li>suspend() </li>
<li>resume() static </li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="4-理解线程上下文切换"><a href="#4-理解线程上下文切换" class="headerlink" title="4. 理解线程上下文切换"></a>4. 理解线程上下文切换</h2><p>在多线程编程中线程个数一般都大于CPU个数， 而每个CPU同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行的， CPU资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片， 线程在时间片内占用CPU执行任务。<strong>当前线程使用完时间片后就会处于就绪状态并让出CPU让其他线程占用， 这就是上下文切换</strong>。</p>
<p>在切换线程上下文时需要保存当前线程的执行现场，当再次执行时根据保存的执行现场信息恢复执行现场。</p>
<p>&emsp;&emsp;</p>
<p>概括来说就是：<strong>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>线程上下文切换的时机有：</p>
<ul>
<li>当前线程的CPU时间片使用完处于就绪状态时。</li>
<li>当前线程被其他线程中断时。</li>
</ul>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>&emsp;&emsp;</p>
<h2 id="5-守护线程和用户线程"><a href="#5-守护线程和用户线程" class="headerlink" title="5. 守护线程和用户线程"></a>5. 守护线程和用户线程</h2><p><strong>Java中的线程分为两类， 分别为daemon线程(守护线程) 和user线程(用户线程)</strong> 。在JVM启动时会调用main函数， main函数所在的线程就是一个用户线程， 其实在JVM内部同时还启动了好多守护线程，比如垃圾回收线程。</p>
<p><strong>当最后一个非守护线程结束时， JVM会正常退出， 而不管当前是否有守护线程， 也就是说， 只要有一个用户线程还没结束，正常情况下JVM就不会退出</strong>。</p>
<p>创建的线程默认是用户线程，可以通过Thread的<code>setDeamon(true)</code>可将线程设置为守护线程。</p>
<p>示例demo：TestDeamon。</p>
<p>&emsp;&emsp;</p>
<h2 id="6-线程的生命周期和状态"><a href="#6-线程的生命周期和状态" class="headerlink" title="6. 线程的生命周期和状态"></a>6. 线程的生命周期和状态</h2><h3 id="6-1-从OS层面"><a href="#6-1-从OS层面" class="headerlink" title="6.1 从OS层面"></a>6.1 从OS层面</h3><p>从操作系统层面，线程的生命周期包括<strong>新建（New），就绪（Ready），运行（Running），阻塞（Blocked），死亡（Dead）</strong>。CPU在多个线程之间切换时，线程状态也在Ready、Running之间切换。</p>
<h4 id="新建与就绪状态"><a href="#新建与就绪状态" class="headerlink" title="新建与就绪状态"></a>新建与就绪状态</h4><p><strong>使用new关键字创建一个线程时，该线程即处于新建状态</strong>，此时JVM仅为它分配内存，初始化成员变量的值（与new普通对象一样）。<br><strong>调用start()方法后，线程处于就绪状态</strong>，<strong>JVM为其创建方法调用栈和程序计数器</strong>，<strong>此时线程并没有运行，只是表示其可以运行</strong>，何时运行取决于JVM里线程调度器的调度。 </p>
<p>&emsp;&emsp;</p>
<h4 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h4><p>处于就绪状态的线程获得CPU，开始执行run()方法，则<strong>处于运行状态</strong>。如果只有一个CPU，则每个时刻只有一个线程在运行状态。<br>线程调度策略：</p>
<ul>
<li><strong>抢占式策略</strong>：系统给每个线程一小段时间处理任务，时间用完后，系统剥夺该线程所占用的资源，让给其他线程。选择下一个线程时，系统会考虑线程优先级。</li>
<li><strong>协作式调度策略</strong>：只有一个线程调用它的sleep()或yield()方法后才会放弃所占用的资源——即必须由线程主动放弃资源。  </li>
</ul>
<p>发生以下情况时，<strong>线程进入阻塞状态</strong>：</p>
<ul>
<li>线程调用sleep()。</li>
<li>线程调用一个阻塞式IO方法，在该方法返回之前。</li>
<li>线程试图获取一个同步监视器，但该监视器被其他线程所持有。</li>
<li>线程在等待某个通知（notify）。</li>
<li>线程调用suspend()方法将该线程挂起。（该方法<strong>容易导致死锁</strong>）  </li>
</ul>
<p>当线程被阻塞，其他线程即可获得CPU。被阻塞的线程在合适的时候进入就绪状态（而不是运行状态，解除阻塞后，必须重新等待线程调度器调用它）。<br>发生以下情况时，阻塞的线程进入就绪状态（对应上面的情况）：</p>
<ul>
<li>sleep()方法超过指定时间。</li>
<li>IO方法已返回。</li>
<li>获得同步监视器。</li>
<li>线程正在等待通知时，其他线程发出了一个通知。</li>
<li>被挂起的线程调用resume()恢复方法。</li>
</ul>
<h4 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h4><p>线程以如下三种方式结束时死亡：</p>
<ul>
<li>run()或call()方法执行完毕。</li>
<li>抛出Exception或Error。</li>
<li>调用线程的stop()方法。（<strong>容易导致死锁</strong>）  </li>
</ul>
<p>判断某个线程是否已死亡可调用线程的isAlive()方法（<strong>处于新建、死亡状态返回false</strong>，处于就绪、运行、阻塞返回true）。</p>
<blockquote>
<ul>
<li><strong>主线程结束时，其他线程不受影响。一旦子线程启动，就拥有与主线程相同地位</strong>。</li>
<li>不要对一个已死亡的线程调用start()。  </li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<h3 id="6-2-从Java-API方面"><a href="#6-2-从Java-API方面" class="headerlink" title="6.2 从Java API方面"></a>6.2 从Java API方面</h3><p>（以下图片来自JavaGuide）</p>
<p>在<strong>Thread中的State枚举类里定义了线程的6种状态</strong>：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215044761.png" alt="image-20210210215044761"></p>
<p>其中，将OS层面的就绪（Ready）和运行（Running）状态统称为 <strong>RUNNABLE（可运行）</strong> 状态 。</p>
<blockquote>
<p>在idea中debug时，BLOCKED状态显示为MONITOR</p>
</blockquote>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>Java 线程状态变迁如下图（<strong>大概情况</strong>）：（这里join方法应是来自Thread类）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215151522.png" alt="image-20210210215151522" style="zoom: 80%;" />

<p>其中的一些情况补充：</p>
<ul>
<li><p>WAITING &lt;–&gt; RUNNABLE：调用 <code>obj.notify()  obj.notifyAll()  t.interrupt()</code> 时线程不是直接进入RUNNABLE状态，而是进入EntryList后再竞争锁（<i>对于join、park等应该也是</i>）：</p>
<ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE </li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
<li><p>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING。<strong><font color="red">注意是当前线程在t 线程对象的监视器上（具体是在WaitSet上）等待</font></strong>。<br>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
<li><p>RUNNABLE &lt;–&gt; BLOCKED：</p>
<ul>
<li>t 线程用 <code>synchronized(obj)</code> <strong>获取对象锁时如果竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED </li>
<li><strong>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争</strong>，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="7-变量的线程安全"><a href="#7-变量的线程安全" class="headerlink" title="7. 变量的线程安全"></a>7. 变量的线程安全</h2><h3 id="7-1-成员变量和静态变量"><a href="#7-1-成员变量和静态变量" class="headerlink" title="7.1 成员变量和静态变量"></a>7.1 成员变量和静态变量</h3><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 <ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="7-2-局部变量"><a href="#7-2-局部变量" class="headerlink" title="7.2 局部变量"></a>7.2 局部变量</h3><ul>
<li>局部变量是线程安全的 </li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的 </li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p>对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="8-常见线程安全类"><a href="#8-常见线程安全类" class="headerlink" title="8. 常见线程安全类"></a>8. 常见线程安全类</h2><ul>
<li>String、Integer：String、Integer 等都是不可变类，因为<strong>其内部的状态不可以改变</strong>，因此它们的方法都是线程安全的。对于String的replace，substring 等方法，其实质是返回一个新的字符串。</li>
<li>StringBuffer</li>
<li>Random </li>
<li>Vector</li>
<li>Hashtable </li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong>。它们的每个方法是原子的，<strong>但注意它们多个方法的组合不是原子的</strong>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable(); </span><br><span class="line"><span class="comment">// 线程1，线程2 </span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="keyword">null</span>) &#123; </span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种线程不安全的执行示例：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210213172057961.png" alt="image-20210213172057961"></p>
<p>&emsp;&emsp;</p>
<h2 id="9-死锁"><a href="#9-死锁" class="headerlink" title="9. 死锁"></a>9. 死锁</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><p>死锁是指<strong>两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。发生死锁时，整个程序不会发生任何异常，也不会给出任何提示，如果没有外力作用，这些线程会一直等待，无法继续运行</strong>。</p>
<p><strong style="color:red">发生死锁的4个条件</strong>：</p>
<ul>
<li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li>
<li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程一资源的环形链，即线程集合{T0，T1，T2，…，Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>避免死锁可以通过破坏4个条件的至少一个实现，<strong>而目前只有请求并持有和环路等待条件是可破坏的</strong>。造成死锁的原因和资源申请顺序关系很大，可以使用资源的有序性申请来避免死锁（<strong>破坏环路等待条件</strong>）。有序性即：<strong>假如线程A和线程B都需要资源1，2，3，…，n时，对资源进行排序，<font color="red">线程A和线程B只有在获取了资源n-1时才能去获取资源n</font></strong>。</p>
<p>&emsp;&emsp;</p>
<p>一种死锁示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁</span><br><span class="line">* t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                sleep(<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="9-2-检测死锁的工具"><a href="#9-2-检测死锁的工具" class="headerlink" title="9.2 检测死锁的工具"></a>9.2 检测死锁的工具</h3><h4 id="1-jstack命令"><a href="#1-jstack命令" class="headerlink" title="1) jstack命令"></a>1) jstack命令</h4><p>运行上述示例代码，在cmd输入<code>jps</code>，查看线程id，再执行<code>jstack thread_id</code>输出检测结果。</p>
<p>输出结果的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000000297c178 (object 0x00000000d6b65178, a java.lang.Object),</span><br><span class="line">  which is held by &quot;t1&quot;</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000000297e488 (object 0x00000000d6b65188, a java.lang.Object),</span><br><span class="line">  which is held by &quot;t2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">        at lock.TestDeadLock.lambda$main$1(TestDeadLock.java:34)</span><br><span class="line">        - waiting to lock &lt;0x00000000d6b65178&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d6b65188&gt; (a java.lang.Object)</span><br><span class="line">        at lock.TestDeadLock$$Lambda$2&#x2F;1879034789.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">        at lock.TestDeadLock.lambda$main$0(TestDeadLock.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000d6b65188&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d6b65178&gt; (a java.lang.Object)</span><br><span class="line">        at lock.TestDeadLock$$Lambda$1&#x2F;942986815.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h4 id="2-jconsole"><a href="#2-jconsole" class="headerlink" title="2) jconsole"></a>2) jconsole</h4><p>进入cmd，输入<code>jconsole</code>，连接线程。</p>
<p>在线程窗口点击检测死锁，可看到相关信息：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217170359984.png" alt="image-20210217170359984"></p>
<p>&emsp;&emsp;</p>
<h3 id="9-3-哲学家就餐问题"><a href="#9-3-哲学家就餐问题" class="headerlink" title="9.3 哲学家就餐问题"></a>9.3 哲学家就餐问题</h3><p>5个哲学家围在圆桌上用餐，有5根筷子，只有拥有两根筷子才能吃饭，吃完饭会放下筷子思考，如此反复。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217171857739.png" alt="image-20210217171857739" style="zoom:67%;" />

<p>代码：demo位于<code>lock/deadlock/v1/TestPhilosopher.java</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//　尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="9-4-活锁"><a href="#9-4-活锁" class="headerlink" title="9.4 活锁"></a>9.4 活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p>
<p>示例：（demo：<code>lock/TestLiveLock.java</code>）</p>
<p>t1要将count减到0，t2要加到20，由于它们的运算速度相近，导致一直执行不结束。</p>
<p><strong>可以使用随机sleep时间避免等</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="9-5-饥饿"><a href="#9-5-饥饿" class="headerlink" title="9.5 饥饿"></a>9.5 饥饿</h3><p>一个线程由于优先级太低（或者说长时间运行不了），始终得不到 CPU 调度执行，也不能够结束。</p>
<p>&emsp;&emsp;</p>
<h2 id="10-ThreadLocal"><a href="#10-ThreadLocal" class="headerlink" title="10. ThreadLocal"></a>10. ThreadLocal</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量，JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 **<code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，</strong>即创建一个变量，每一个线程访问该变量获取的都是该变量在该线程的副本**。</p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="10-2-示例"><a href="#10-2-示例" class="headerlink" title="10.2 示例"></a>10.2 示例</h3><blockquote>
<p><code>sleep(int i)</code>表示睡眠i s</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String str = <span class="string">&quot;str from t1&quot;</span>;</span><br><span class="line">            threadLocal.set(str);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 获取的是自己放置的str，获取不到t2放置的</span></span><br><span class="line">            String str1 = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str after 2s: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获取的str为null，不能获取到t1放置的str</span></span><br><span class="line">            String str = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            String str1 = <span class="string">&quot;str from t2&quot;</span>;</span><br><span class="line">            threadLocal.set(str1);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="10-3-原理"><a href="#10-3-原理" class="headerlink" title="10.3 原理"></a>10.3 原理</h3><p>Thread类包含一个ThreadLocal.ThreadLocalMap成员变量，其实质是一个Map，映射类型是 ThreadLocal-Object，存放多个ThreadLocal的本地副本，</p>
<p>从Thread类源码开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>即<strong>Thread类中有一个threadLocals和一个inheritableThreadLocals， 它们都是ThreadLocalMap类型（<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类）的变量</strong>， 而<strong>ThreadLocalMap是一个定制化的map，存放多个ThreadLocal变量在当前线程的副本，<code>ThreadLocalMap</code>存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</strong>。</p>
<p>在默认情况下， 每个线程中的这两个变量都为nll， <strong>只有当前线程第一次调用Thread Local的<code>set()</code>或者<code>get()</code>方法时才会创建它们</strong>。</p>
<p>从上面可以看出，<strong style="color:red">每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</strong>。<strong>Thread Local就是一个工具壳， 通过它来从当前线程的threadLocals中获取值或放入值</strong>。</p>
<p>如果调用线程一直不终止， 那么这个本地变量会一直存放在调用线程的thread Locals变量里面， 所以当不需要使用本地变量时可以通过调用Thread Local变量的<code>remove()</code>方法， 从当前线程的thread Locas里面删除该本地变量，避免内存泄漏。</p>
<p>&emsp;&emsp;</p>
<p><code>set()</code>、<code>get()</code>的源码简单分析：</p>
<p><code>set()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// threadLocalMap不为null，修改值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 第一次调用则创建当前线程对应的threadLocalMap，并将value放进去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><code>get()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 不为null则从中尝试获取值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前ThreadLocal对象为key，从线程的threadLocalMap中尝试获取值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map为null或其中没有当前ThreadLocal对应的值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong style="color:red">可以看到<code>set()</code>、<code>get()</code>方法都是先从当前线程中获取ThreadLocalMap对象</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p><code>setInitialValue()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();<span class="comment">//该方法只是返回一个null</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="comment">// map不为null（表示其中没有当前ThreadLocal对应的值）</span></span><br><span class="line">    <span class="comment">// 放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 否则创建一个ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 并同样放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><code>createMap()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>Thread、ThreadLoacal、ThreadLoacalMap的关系图解：（图片来自JavaGuide）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210218180050123.png" alt="image-20210218180050123" style="zoom:80%;" />



<h3 id="10-4-内存泄露问题"><a href="#10-4-内存泄露问题" class="headerlink" title="10.4 内存泄露问题"></a>10.4 内存泄露问题</h3><p><strong><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry</strong>。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。<strong>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</strong>。</p>
<blockquote>
<p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放但又无法使用，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
</blockquote>
<p>ThreadLocalMap的静态内部类Entry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="10-5-InheritableThreadLocal-to-be-…"><a href="#10-5-InheritableThreadLocal-to-be-…" class="headerlink" title="10.5 InheritableThreadLocal(to be …)"></a>10.5 InheritableThreadLocal(to be …)</h3><p>&emsp;&emsp;</p>
<h2 id="12-伪共享问题"><a href="#12-伪共享问题" class="headerlink" title="12. 伪共享问题"></a>12. 伪共享问题</h2><p>CPU与主内存之间会添加一级或多级高速缓冲存储器，即Cache。</p>
<p><strong>在Cache内部是按行存储的， 其中每一行称为一个Cache行</strong>。Cache行是<strong>Cache与主内存进行数据交换的单位</strong>，Cache行的大小一般为2的幂次数字节。当CPU访问某个变量时， 首先会去看CPU Cache内是否有该变量， 如果有则直接从中获取，否则就去主内存里面获取该变量， <strong style="color:red">然后把该变量所在内存区域的一个Cache行大小的内存块（局部性原理）复制到Cache中</strong>。</p>
<p><strong>由于存放到Cache行的是内存块而不是单个变量， 所以可能会把多个变量存放到一个Cache行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</strong>。</p>
<p>比如CPU1、CPU2读取了同一个缓存行，若CPU1对其中的一个变量修改，在缓存一致性协议下，CPU2中对应的缓存行就会失效，即破坏了CPU2的一级缓存，CPU2需要到二级缓存查找（甚至到主存），造成性能下降。</p>
<p>&emsp;&emsp;</p>
<p>比如有4个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure>

<p>假设缓存行大小32字节，一个long类型8个字节，当CPU访问a时，会把a及附近的b、c、d一起放入缓存行。</p>
<p><strong style="color:red">也就是地址连续的多个变量才有可能会被放到一个缓存行中</strong>。比如创建数组时，数组里面的多个元素就会被放入同一个缓存行。</p>
<p>在正常情况下单线程访问时将数组元素放入一个或者多个缓存行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p>
<p>测试缓存行demo见<code>test/TestCacheLine</code>。</p>
<p>&emsp;&emsp;</p>
<p>JDK8之前使用声明多个填充变量的方法来避免伪共享问题，让一个缓存行只有一个有用变量：</p>
<p>该例中，若缓存行大小是64B，则value+p1-6是56B，对象头是8B，所以共64B。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>JDK8提供了一个注解<code>@sun.misc.Contended</code>解决伪共享问题，它可以自行执行填充。上面代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<blockquote>
<p>需要注意的是， 在默认情况下， @Contended注解只用于Java核心类， 比如rt包下的类。如果用户类路径下的类需要使用这个注解， 则需要添加JVM参数：<code>-XX:-RestrictContended</code>。填充的宽度默认为128，要自定义宽度则可以设置</p>
<p><code>-XX:ContendedPaddingWidth</code>参数。</p>
</blockquote>
<h2 id="13-锁概述"><a href="#13-锁概述" class="headerlink" title="13. 锁概述"></a>13. 锁概述</h2><h3 id="13-1-乐观锁和悲观锁"><a href="#13-1-乐观锁和悲观锁" class="headerlink" title="13.1 乐观锁和悲观锁"></a>13.1 乐观锁和悲观锁</h3><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。</p>
<p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以<strong>在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态</strong>。</p>
<blockquote>
<p>悲观锁的<strong>实现往往依靠数据库提供的锁机制</strong>，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以<strong>在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测</strong>。比如根据update返回的行数让用户决定如何去做。</p>
<p>乐观锁并不会使用数据库提供的锁机制， 一般在表中添加version字段（<strong>每次根据id和version修改记录，若修改成功，将version+1</strong>）或者使用业务状态来实现。乐观锁直到提交时才锁定，所以不会产生任何死锁。</p>
<p>&emsp;&emsp;</p>
<h3 id="13-2-公平锁和非公平锁"><a href="#13-2-公平锁和非公平锁" class="headerlink" title="13.2 公平锁和非公平锁"></a>13.2 公平锁和非公平锁</h3><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，</p>
<ul>
<li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的。</li>
<li>非公平锁则是先来不一定先得。</li>
</ul>
<p>Reentrant Lock提供了公平和非公平锁的实现。</p>
<ul>
<li>公平锁：<code>Reentrant Lock pair Lock=nhew Reentrant Lock(true)</code> 。</li>
<li>非公平锁：<code>Reentrant Lock pair Lock=new Reentrant Lock(false) </code>。如果构造函数不传递参数，则默认是非公平锁。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="13-3-独占锁和共享锁"><a href="#13-3-独占锁和共享锁" class="headerlink" title="13.3 独占锁和共享锁"></a>13.3 独占锁和共享锁</h3><p><strong>独占锁表示一个锁只能被一个线程获取，共享锁则可以被多个线程获取</strong>。</p>
<p><strong>独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性</strong>，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<p>&emsp;&emsp;</p>
<h3 id="13-4-可重入锁"><a href="#13-4-可重入锁" class="headerlink" title="13.4 可重入锁"></a>13.4 可重入锁</h3><p>当一个线程可以再次获取它已经获取了的锁，则该锁是可重入的。synchronized内部锁和ReentrantLock都是可重入锁。</p>
<p>&emsp;&emsp;</p>
<p>可重入锁的原理是<strong>在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器</strong>。一开始计数器值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁时，计数器的值会变成1，这时其他线程再来获取该锁时<strong>会发现锁的所有者不是自己而被阻塞挂起</strong>。但是当<strong>获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+1</strong>，当释放锁后计数器值-1。当计数器值为0时， 锁里面的线程标示被重置为null， 这时候被阻塞的线程会被唤醒来竞争获取该锁。</p>
<p>&emsp;&emsp;</p>
<h3 id="13-5-自旋锁"><a href="#13-5-自旋锁" class="headerlink" title="13.5 自旋锁"></a>13.5 自旋锁</h3><p>由于Java中的线程是与操作系统中的线程一一对应的，<strong>所以当一个线程在获取锁(比如独占锁)失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。<font color="red">而从用户状态切换到内核状态的开销是比较大的</font>，在一定程度上会影响并发性能</strong>。</p>
<p>自旋锁是<strong>当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取</strong>（默认次数是10，可以使用<code>-XX：PreBlockSpinsh</code>参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。</p>
<p>由此看来自旋锁是使用CPU时间换取线程阳塞与调度的开销， <strong>但是很有可能这些CPU时间白白浪费了</strong>。</p>
<p>&emsp;&emsp;</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">bxxiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/">http://example.com/2021/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">bxxiao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Tag/Java%E5%B9%B6%E5%8F%91/">Java并发</a></div><div class="post_share"><div class="social-share" data-image="/images/wallhaven-137lo1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/25/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"><img class="prev-cover" src="https://gitee.com/bxgitee/noteImage/raw/master/image/wallhaven-9mxz8k.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IDEA的一些使用技巧</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><img class="next-cover" src="https://gitee.com/bxgitee/noteImage/raw/master/image/ball_glass_sunset_133830_1920x1080.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM垃圾回收</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">1.1 线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B"><span class="toc-text">1) 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="toc-text">2) 线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94%E4%BA%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">1.2 多线程相比于多进程的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">1.3 同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">1.4 查看进程线程的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%843%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 线程的3种创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-text">2.1 继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.2 实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8FutureTask"><span class="toc-text">2.3 使用FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.4 三种方式优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3. 线程中的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-wait%E3%80%81notify%E3%80%81notifyAll"><span class="toc-text">3.1 wait、notify、notifyAll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E7%90%86"><span class="toc-text">1) 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF"><span class="toc-text">2) 使用的正确姿势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-park%E3%80%81unpark"><span class="toc-text">3.2 park、unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1) 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86"><span class="toc-text">2) 原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-interrupt"><span class="toc-text">3.3 interrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Thread%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">3.4 Thread类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">4. 理解线程上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-text">5. 守护线程和用户线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-text">6. 线程的生命周期和状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BB%8EOS%E5%B1%82%E9%9D%A2"><span class="toc-text">6.1 从OS层面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="toc-text">新建与就绪状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%92%8C%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="toc-text">运行和阻塞状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E4%BA%A1"><span class="toc-text">线程死亡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BB%8EJava-API%E6%96%B9%E9%9D%A2"><span class="toc-text">6.2 从Java API方面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">状态转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">7. 变量的线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">7.1 成员变量和静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">7.2 局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-text">8. 常见线程安全类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%AD%BB%E9%94%81"><span class="toc-text">9. 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">9.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-text">9.2 检测死锁的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-jstack%E5%91%BD%E4%BB%A4"><span class="toc-text">1) jstack命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-jconsole"><span class="toc-text">2) jconsole</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">9.3 哲学家就餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E6%B4%BB%E9%94%81"><span class="toc-text">9.4 活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E9%A5%A5%E9%A5%BF"><span class="toc-text">9.5 饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-ThreadLocal"><span class="toc-text">10. ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">10.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E7%A4%BA%E4%BE%8B"><span class="toc-text">10.2 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%8E%9F%E7%90%86"><span class="toc-text">10.3 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-text">10.4 内存泄露问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-InheritableThreadLocal-to-be-%E2%80%A6"><span class="toc-text">10.5 InheritableThreadLocal(to be …)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-text">12. 伪共享问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-text">13. 锁概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">13.1 乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">13.2 公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-text">13.3 独占锁和共享锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">13.4 可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">13.5 自旋锁</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/images/wallhaven-137lo1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By bxxiao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>