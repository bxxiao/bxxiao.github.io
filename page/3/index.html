<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="bxxiao">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="bxxiao">
<meta property="og:description" content="nothing">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bxxiao">
<meta property="article:tag" content="bxxiao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>bxxiao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bxxiao" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bxxiao</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">IDEA的一些使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-25 00:23:26 / 修改时间：00:27:24" itemprop="dateCreated datePublished" datetime="2021-02-25T00:23:26+08:00">2021-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>该笔记基于IDEA-2019版本</p>
</blockquote>
<h2 id="提高运行速度"><a href="#提高运行速度" class="headerlink" title="提高运行速度"></a>提高运行速度</h2><p>在idea安装目录的bin目录下的idea.exe.vmoptions文件，调整<code>Xms</code>跟<code>Xmx</code>两个参数的值可提高运行速度，但要注意电脑的运行内存是否足够。</p>
<h2 id="恢复默认设置"><a href="#恢复默认设置" class="headerlink" title="恢复默认设置"></a>恢复默认设置</h2><p>在用户目录中，有一个<code>.IntelliJIdea2019.3</code>目录，该目录下有个<code>config</code>跟一个<code>system</code>目录，前者存放关于IDEA一些设置相关的配置文件。可以通过将这两个目录删除来实现恢复默认设置（在重启idea时会自动创建这两个文件，但之前设置的快捷键、模板等将被重置）。</p>
<h2 id="工具条"><a href="#工具条" class="headerlink" title="工具条"></a>工具条</h2><p>【View】-》【Appearance】-》【选中Tool Bar】，打开工具条。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200814222041.png"></p>
<h2 id="IDEA中的Project和Module"><a href="#IDEA中的Project和Module" class="headerlink" title="IDEA中的Project和Module"></a>IDEA中的Project和Module</h2><p>参考链接：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/65448689">https://blog.csdn.net/qq_35246620/article/details/65448689</a> </p>
</blockquote>
<p>在 IntelliJ IDEA 中<code>Project</code>是最顶级的结构单元，然后就是<code>Module</code>，一个<code>Project</code>可以有多个<code>Module</code>。</p>
<p>一个<code>Project</code>是由一个或多个<code>Module</code>组成，</p>
<ul>
<li>当为单<code>Module</code>项目的时候，这个单独的<code>Module</code>实际上就是一个<code>Project</code>；</li>
<li>当为多<code>Module</code>项目的时候，多个模块处于同一个<code>Project</code>之中，此时彼此之间具有互相依赖的关联关系。</li>
</ul>
<p>此外， IntelliJ IDEA 的<code>Project</code>是一个不具备任何编码设置、构建等开发功能的概念，其主要作用就是起到一个项目定义、范围约束、规范类型的效果，这个目录在命名上应该有其代表性的意义。在缺省情况下，IntelliJ IDEA 是默认单<code>Project</code>单<code>Module</code>的，这时<code>Project</code>和<code>Module</code>合二为一。</p>
<p>要删除Module时，需要进入<code>Project Structure</code>，在左边选择<code>Modules</code>，右边视图中选中要删除的Module，点击上方的<code>-</code>（或右键delete）即可。此时在项目中移除了对应Module，但在磁盘中没有删除Module对应目录，需手动删除。</p>
<p><strong>在一个Module中，可以通过在本Module的imi文件中配置引入其他Module的内容</strong>。可以使用<code>Alt+Enter</code>的提示功能自动配置。</p>
<h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><h3 id="鼠标悬停显示文档"><a href="#鼠标悬停显示文档" class="headerlink" title="鼠标悬停显示文档"></a>鼠标悬停显示文档</h3><p>【Settings】-》【Editor】-》【General】-》【视图右边滑到最下面，勾上<code>show quik documentation on mouse move</code>】</p>
<p>下方的Tooltip delay设置延迟时间。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145751019.png" alt="image-20200815145751019" style="zoom:67%;" />

<h3 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135642.png" style="zoom:67%;" />



<h3 id="显示方法间的分隔符"><a href="#显示方法间的分隔符" class="headerlink" title="显示方法间的分隔符"></a>显示方法间的分隔符</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135936.png"></p>
<h3 id="忽略大小写提示的差别"><a href="#忽略大小写提示的差别" class="headerlink" title="忽略大小写提示的差别"></a>忽略大小写提示的差别</h3><p>如图取消勾选即可。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815140939775.png" alt="image-20200815140939775"></p>
<p>效果：输入S跟s的提示将变的一样。</p>
<h3 id="多个文件的标签多行显示"><a href="#多个文件的标签多行显示" class="headerlink" title="多个文件的标签多行显示"></a>多个文件的标签多行显示</h3><p>打开多个文件时，让多个文件的标签分成多行显示。如图，取消勾选。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141445072.png" alt="image-20200815141445072" style="zoom:80%;" />





<h3 id="设置代码编辑区各部分样式"><a href="#设置代码编辑区各部分样式" class="headerlink" title="设置代码编辑区各部分样式"></a>设置代码编辑区各部分样式</h3><p>设置如单行注释、多行注释、方法等字体的样式。在框框内点击不同位置可自动跳转到对应的设置。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141938283.png" alt="image-20200815141938283" style="zoom: 67%;" />



<h3 id="当导入同一个包的类超过多少时使用"><a href="#当导入同一个包的类超过多少时使用" class="headerlink" title="当导入同一个包的类超过多少时使用*"></a>当导入同一个包的类超过多少时使用<code>*</code></h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815142453764.png" alt="image-20200815142453764" style="zoom: 67%;" />



<h3 id="设置类的头部信息"><a href="#设置类的头部信息" class="headerlink" title="设置类的头部信息"></a>设置类的头部信息</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143009247.png" alt="image-20200815143009247" style="zoom:67%;" />



<h3 id="设置编码（全局）"><a href="#设置编码（全局）" class="headerlink" title="设置编码（全局）"></a>设置编码（全局）</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143239051.png" alt="image-20200815143239051" style="zoom:67%;" />



<h3 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h3><p>也可同时勾上框框第二项，启动多模块并行编译。但会占用更多内存。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815144738928.png" alt="image-20200815144738928" style="zoom:67%;" />



<h3 id="多个代码文件垂直-水平显示"><a href="#多个代码文件垂直-水平显示" class="headerlink" title="多个代码文件垂直/水平显示"></a>多个代码文件垂直/水平显示</h3><p>右键标签页，如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145150886.png" alt="image-20200815145150886" style="zoom: 80%;" />

<p>效果：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145304470.png" alt="image-20200815145304470" style="zoom: 67%;" />

<h3 id="CTRL-插入注释时带缩进"><a href="#CTRL-插入注释时带缩进" class="headerlink" title="CTRL+/ 插入注释时带缩进"></a><code>CTRL+/</code> 插入注释时带缩进</h3><p>设置Java文件：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135428506.png" alt="image-20200818135428506" style="zoom:67%;" />

<p>XML文件同理：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135625076.png" alt="image-20200818135625076" style="zoom:67%;" />



<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/VariatioZbw/article/details/105626147">https://blog.csdn.net/VariatioZbw/article/details/105626147</a></p>
</blockquote>
<h3 id="为main方法传递参数"><a href="#为main方法传递参数" class="headerlink" title="为main方法传递参数"></a>为main方法传递参数</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013713294/article/details/53020293">https://blog.csdn.net/u013713294/article/details/53020293</a></p>
</blockquote>
<p>有时需要使用main方法的args参数，而为args参数赋值一般在命令行中，如下：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java <span class="comment">//编译</span></span><br><span class="line">java Test para<span class="name">m1</span> para<span class="name">m2</span> para<span class="name">m3</span> ... <span class="comment">//运行Test类，param是传递给main方法的参数</span></span><br></pre></td></tr></table></figure>



<p>在idea中可以设置参数，在main方法运行时把这些参数传递给它，步骤如下：</p>
<ol>
<li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213818332.png" style="zoom:80%;" />

<p>或</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213902857.png" style="zoom:80%;" />
</li>
<li><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924214508649.png" alt="image-20200924214508649"></p>
<p>点击OK，运行main方法时即会传入设置的参数。</p>
</li>
</ol>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815152625644.png" alt="image-20200815152625644" style="zoom: 80%;" />

<p>查看/修改快捷键：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815233545855.png" alt="image-20200815233545855" style="zoom: 67%;" />



<p><strong>快捷键大全</strong>：</p>
<blockquote>
<p>以下大部分来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p>
</blockquote>
<h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + F</td>
<td align="left">在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + R</td>
<td align="left">在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Z</td>
<td align="left">撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Y</td>
<td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + X</td>
<td align="left">剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + C</td>
<td align="left">复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + D</td>
<td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + W</td>
<td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + E</td>
<td align="left">显示最近打开的文件记录列表</td>
</tr>
<tr>
<td align="left">Ctrl + N</td>
<td align="left">根据输入的 <strong>类名</strong> 查找类文件</td>
</tr>
<tr>
<td align="left">Ctrl + G</td>
<td align="left">在当前文件跳转到指定行处</td>
</tr>
<tr>
<td align="left">Ctrl + J</td>
<td align="left">插入自定义动态代码模板</td>
</tr>
<tr>
<td align="left">Ctrl + P</td>
<td align="left">方法参数提示显示</td>
</tr>
<tr>
<td align="left">Ctrl + Q</td>
<td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td align="left">Ctrl + U</td>
<td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td align="left">Ctrl + B</td>
<td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td>
</tr>
<tr>
<td align="left">Ctrl + K</td>
<td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + T</td>
<td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + H</td>
<td align="left">显示当前类的层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + O</td>
<td align="left">选择可重写的方法</td>
</tr>
<tr>
<td align="left">Ctrl + I</td>
<td align="left">选择可继承的方法</td>
</tr>
<tr>
<td align="left">Ctrl + +</td>
<td align="left">展开代码</td>
</tr>
<tr>
<td align="left">Ctrl + -</td>
<td align="left">折叠代码</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + [</td>
<td align="left">移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td align="left">Ctrl + ]</td>
<td align="left">移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td align="left">Ctrl + F1</td>
<td align="left">在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td align="left">Ctrl + F3</td>
<td align="left">调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td align="left">Ctrl + F4</td>
<td align="left">关闭当前编辑文件</td>
</tr>
<tr>
<td align="left">Ctrl + F8</td>
<td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td align="left">Ctrl + F9</td>
<td align="left">执行 Make Project 操作</td>
</tr>
<tr>
<td align="left">Ctrl + F11</td>
<td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td align="left">Ctrl + F12</td>
<td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td align="left">Ctrl + Tab</td>
<td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td align="left">Ctrl + Enter</td>
<td align="left">智能分隔行</td>
</tr>
<tr>
<td align="left">Ctrl + End</td>
<td align="left">跳到文件尾</td>
</tr>
<tr>
<td align="left">Ctrl + Home</td>
<td align="left">跳到文件头</td>
</tr>
<tr>
<td align="left">Ctrl + Space</td>
<td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Delete</td>
<td align="left">删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + BackSpace</td>
<td align="left">删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + 1,2,3…9</td>
<td align="left">定位到对应数值的书签位置</td>
</tr>
<tr>
<td align="left">Ctrl + 左键单击</td>
<td align="left">在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td align="left">Ctrl + 光标定位</td>
<td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td align="left">Ctrl + 左方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 右方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 前方向键</td>
<td align="left">等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td align="left">Ctrl + 后方向键</td>
<td align="left">等效于鼠标滚轮向后效果</td>
</tr>
</tbody></table>
<h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + `</td>
<td align="left">显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td align="left">Alt + Q</td>
<td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td align="left">Alt + F1</td>
<td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td align="left">Alt + F2</td>
<td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td align="left">Alt + F3</td>
<td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td align="left">Alt + F7</td>
<td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td align="left">Alt + F8</td>
<td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td align="left">Alt + Home</td>
<td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td align="left">Alt + Enter</td>
<td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Alt + Insert</td>
<td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td align="left">Alt + 左方向键</td>
<td align="left">按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 右方向键</td>
<td align="left">按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 前方向键</td>
<td align="left">当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 后方向键</td>
<td align="left">当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 1,2,3…9</td>
<td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
<tr>
<td align="left">Alt + 7</td>
<td align="left">显示当前类的所有方法、成员变量等</td>
</tr>
</tbody></table>
<h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Shift + F1</td>
<td align="left">如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td align="left">Shift + F2</td>
<td align="left">跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td align="left">Shift + F3</td>
<td align="left">在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td align="left">Shift + F4</td>
<td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td align="left">Shift + F6</td>
<td align="left">对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td align="left">Shift + F7</td>
<td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td align="left">Shift + F8</td>
<td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td align="left">Shift + F9</td>
<td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F10</td>
<td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F11</td>
<td align="left">弹出书签显示层</td>
</tr>
<tr>
<td align="left">Shift + Tab</td>
<td align="left">取消缩进</td>
</tr>
<tr>
<td align="left">Shift + ESC</td>
<td align="left">隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td align="left">Shift + End</td>
<td align="left">选中光标到当前行尾位置</td>
</tr>
<tr>
<td align="left">Shift + Home</td>
<td align="left">选中光标到当前行头位置</td>
</tr>
<tr>
<td align="left">Shift + Enter</td>
<td align="left">在当前行的下一行另起新行</td>
</tr>
<tr>
<td align="left">Shift+Alt+Enter</td>
<td align="left">在当前行的上一行另起新行</td>
</tr>
<tr>
<td align="left">Shift + 左键单击</td>
<td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
<tr>
<td align="left">Shift + 滚轮前后滚动</td>
<td align="left">当前文件的横向滚动轴滚动</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Alt + L</td>
<td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + O</td>
<td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + I</td>
<td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + T</td>
<td align="left">对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + J</td>
<td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + H</td>
<td align="left">调用层次</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + B</td>
<td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + V</td>
<td align="left">快速引进变量</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Y</td>
<td align="left">同步、刷新</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + S</td>
<td align="left">打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F7</td>
<td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F11</td>
<td align="left">切换全屏模式</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Enter</td>
<td align="left">光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Home</td>
<td align="left">弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Space</td>
<td align="left">类名自动完成</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 左方向键</td>
<td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 右方向键</td>
<td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 前方向键</td>
<td align="left">在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 后方向键</td>
<td align="left">在查找模式下，跳到下个查找的文件</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + F</td>
<td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + R</td>
<td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + J</td>
<td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Z</td>
<td align="left">取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + W</td>
<td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + N</td>
<td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + U</td>
<td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + T</td>
<td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + C</td>
<td align="left">复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + E</td>
<td align="left">显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + H</td>
<td align="left">显示方法层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + B</td>
<td align="left">跳转到类型声明处</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + I</td>
<td align="left">快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + A</td>
<td align="left">查找动作 / 设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + /</td>
<td align="left">代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + [</td>
<td align="left">选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + ]</td>
<td align="left">选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + +</td>
<td align="left">展开所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + -</td>
<td align="left">折叠所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F7</td>
<td align="left">高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F8</td>
<td align="left">在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F9</td>
<td align="left">编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F12</td>
<td align="left">编辑器最大化</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Space</td>
<td align="left">智能代码提示</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Enter</td>
<td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">退回到上次修改的地方</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 1,2,3…9</td>
<td align="left">快速添加指定数值的书签</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 前方向键</td>
<td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 后方向键</td>
<td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + Shift + N</td>
<td align="left">选择 / 添加 task</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td align="left">Alt + Shift + C</td>
<td align="left">查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">添加到收藏夹</td>
</tr>
<tr>
<td align="left">Alt + Shift + I</td>
<td align="left">查看项目当前文件</td>
</tr>
<tr>
<td align="left">Alt + Shift + F7</td>
<td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td align="left">Alt + Shift + F9</td>
<td align="left">弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + F10</td>
<td align="left">弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + 左键双击</td>
<td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td align="left">Alt + Shift + 前方向键</td>
<td align="left">移动光标所在行向上移动</td>
</tr>
<tr>
<td align="left">Alt + Shift + 后方向键</td>
<td align="left">移动光标所在行向下移动</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + Alt + V</td>
<td align="left">无格式黏贴</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + N</td>
<td align="left">前往指定的变量 / 方法</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + S</td>
<td align="left">打开当前项目设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + C</td>
<td align="left">复制参考信息</td>
</tr>
</tbody></table>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">F2</td>
<td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">F3</td>
<td align="left">在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td align="left">F4</td>
<td align="left">编辑源</td>
</tr>
<tr>
<td align="left">F7</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td align="left">F8</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td align="left">F9</td>
<td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td align="left">F11</td>
<td align="left">添加书签</td>
</tr>
<tr>
<td align="left">F12</td>
<td align="left">回到前一个工具窗口</td>
</tr>
<tr>
<td align="left">Tab</td>
<td align="left">缩进</td>
</tr>
<tr>
<td align="left">ESC</td>
<td align="left">从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td align="left">连按两次Shift</td>
<td align="left">弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody></table>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>查看/设置模板：</p>
<p>Live Templates中可以查看、<strong>编辑、添加以及删除</strong>模板：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142838850.png" alt="image-20200816142838850" style="zoom:80%;" />



<p>Postfix Completion中只能查看、禁用。下图的Before框表示模板的预定义形式，After表示输出效果。比如下图的例子，输入<code>foo.forr</code>，摁下enter。将输出after框的模板。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142928743.png" alt="image-20200816142928743" style="zoom:67%;" />



<h3 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816153643738.png" alt="image-20200816153643738" style="zoom: 80%;" />

<p>如上图操作，输入模板组名，确定。选中创建的模板组，点击<code>+</code>，点击<code>Live Template</code>在组中添加新模板。</p>
<p>设置新模板：</p>
<ul>
<li>1处填写模板缩写</li>
<li>2处填写模板的描述</li>
<li>3处定义模板内容。<strong>例子中模板的意义：</strong>输入test按下enter出现模板后，光标会跳至<code>$var1$</code>位置，输入完成后按enter，光标跳至<code>$var2$</code>处。</li>
</ul>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154245765.png" alt="image-20200816154245765"></p>
<p>下一步，点击define，选择java：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154543995.png" alt="image-20200816154543995" style="zoom:67%;" />



<p>点击OK即可。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200821195633214.png" alt="image-20200821195633214" style="zoom:67%;" />



<h3 id="idea自带模板"><a href="#idea自带模板" class="headerlink" title="idea自带模板"></a>idea自带模板</h3><table>
<thead>
<tr>
<th>Before</th>
<th align="left">After</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>psvm</code></td>
<td align="left"><code>public static void main(String[] args) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>sout</code></td>
<td align="left"><code>System.out.println();</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>soutm</code></td>
<td align="left"><code>System.out.println(&quot;当前方法的全限定名&quot;);</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>soutp</code></td>
<td align="left"><code>System.out.println(&quot;c = &quot; + c);</code></td>
<td align="left">以<code>valueName=value</code><br>的形式输出</td>
</tr>
<tr>
<td><code>soutv</code></td>
<td align="left">与上同</td>
<td align="left">输出某一变量</td>
</tr>
<tr>
<td><code>variable.sout</code></td>
<td align="left"><code>System.out.println(variable);</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>fori</code> （<strong>递增</strong>）</td>
<td align="left"><code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></td>
<td align="left">输入完成后光标跳至第一个i后<br>可改变变量名；按enter光标跳至&lt;后<br>再按enter跳至<code>&#123;&#125;</code>中</td>
</tr>
<tr>
<td><code>arrs/List/Set.fori</code></td>
<td align="left"><code>for (int i = 0; i &lt; xxx.size(); i++) &#123;&#125;</code></td>
<td align="left">可对数组、集合使用。</td>
</tr>
<tr>
<td><code>forr</code>（递减）</td>
<td align="left">与上同理</td>
<td align="left"></td>
</tr>
<tr>
<td><code>arrs/List/Set.forr</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td><code>iter</code></td>
<td align="left"><code>for (T t : arrs) &#123;&#125;</code></td>
<td align="left">对某一数组使用forEach循环</td>
</tr>
<tr>
<td><code>arrs.iter</code></td>
<td align="left">同上</td>
<td align="left">对指定数组使用forEach循环</td>
</tr>
<tr>
<td><code>itar</code></td>
<td align="left"><code>for (int i = 0; i &lt; arr.length; i++) &#123;int i1 =arr[i];&#125;</code></td>
<td align="left">对代码中上一个数组使用普通for循环</td>
</tr>
<tr>
<td><code>ifn</code></td>
<td align="left"><code>if (xxx == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>value.null</code></td>
<td align="left"><code>if (value == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>inn</code> （if not null）</td>
<td align="left"><code>if (st != null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>value.nn</code></td>
<td align="left"><code>if (value == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>prsf</code></td>
<td align="left"><code>private static final</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psfi</code></td>
<td align="left"><code>public static final int</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psfs</code></td>
<td align="left"><code>public static final String</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psf</code></td>
<td align="left"><code>public static final</code></td>
<td align="left"></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="快捷创建Mybatis主配置文件"><a href="#快捷创建Mybatis主配置文件" class="headerlink" title="快捷创建Mybatis主配置文件"></a>快捷创建Mybatis主配置文件</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130058653.png" alt="image-20200914130058653" style="zoom: 80%;" />



<p>填写Name以及文件类型（Extension），并在方框内写入初始代码：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130320437.png" alt="image-20200914130320437"></p>
<p>Apply，即完成模板设置。</p>
<p>右键New创建文件时，即可看到创建的模板：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130454583.png" alt="image-20200914130454583" style="zoom:80%;" />





<h2 id="版本控制（git）"><a href="#版本控制（git）" class="headerlink" title="版本控制（git）"></a>版本控制（git）</h2><h3 id="克隆GitHub的项目到idea中"><a href="#克隆GitHub的项目到idea中" class="headerlink" title="克隆GitHub的项目到idea中"></a>克隆GitHub的项目到idea中</h3><p>1.先在idea中配置好git安装目录：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817131825434.png" style="zoom: 67%;" />



<p>2.添加GitHub账户</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817132350071.png" alt="image-20200817132350071" style="zoom: 67%;" />



<p>3.从GitHub上clone仓库：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134058705.png" alt="image-20200817134058705" style="zoom:80%;" />

<p>或者：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134723950.png" alt="image-20200817134723950" style="zoom:80%;" />

<p>4.填写仓库信息</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134256096.png" alt="image-20200817134256096" style="zoom:80%;" />



<p>5.是否为clone的仓库创建新项目，选择yes：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134413600.png" alt="image-20200817134413600" style="zoom:67%;" />

<p>后面是创建项目的一些选项，此处省略。</p>
<p>完成。</p>
<p>6.clone后，在idea中左侧的项目框右键：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135922566.png" alt="image-20200817135922566" style="zoom:67%;" />

<p>即可看到git的各种操作。</p>
<p>没有add的文件在idea中会显示为红色。</p>
<h3 id="将本地项目Share到GitHub"><a href="#将本地项目Share到GitHub" class="headerlink" title="将本地项目Share到GitHub"></a>将本地项目Share到GitHub</h3><p>这种方式将会在GitHub创建一个仓库，并将项目push到该仓库。</p>
<p>步骤：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135325861.png" alt="image-20200817135325861" style="zoom:80%;" />



<p>后续步骤简单，省略。</p>
<h2 id="Idea自带的文件修改历史功能"><a href="#Idea自带的文件修改历史功能" class="headerlink" title="Idea自带的文件修改历史功能"></a>Idea自带的文件修改历史功能</h2><p>右键一个文件-》【Local History】=》【show History】，即可看到文件的修改历史。</p>
<p>本地历史的相关信息保存在<code>C:\User\.IntelliJIdea2019.3\system\LocalHistory</code>下。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>调试的界面和各种按钮，<strong>鼠标悬停在按钮上可查看快捷键信息</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141152314.png" alt="image-20200817141152314" style="zoom:80%;" />

<p><strong>各种操作的含义</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817140516654.png" alt="image-20200817140516654" style="zoom: 67%;" />



<h3 id="为断点添加条件"><a href="#为断点添加条件" class="headerlink" title="为断点添加条件"></a>为断点添加条件</h3><p>即在该断点停止的条件是满足设置的条件。</p>
<p>例子：</p>
<p>创建一个for循环，并在输出语句添加断点：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141741524.png" alt="image-20200817141741524" style="zoom:80%;" />

<p>右键断点，在condition中设置条件：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141829128.png" alt="image-20200817141829128" style="zoom:80%;" />

<p>启动Debug，停止时i的值是60：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817142010635.png" alt="image-20200817142010635" style="zoom:67%;" />



<h3 id="调试过程中查看变量的值"><a href="#调试过程中查看变量的值" class="headerlink" title="调试过程中查看变量的值"></a>调试过程中查看变量的值</h3><p>基本数据类型的值可直接在界面上查看，如上述例子。对于引用类型变量，若要查看具体的属性信息，可将鼠标悬停在变量上，点击<code>+</code>即可查看。</p>
<h2 id="创建Javadoc文档"><a href="#创建Javadoc文档" class="headerlink" title="创建Javadoc文档"></a>创建Javadoc文档</h2><p>步骤：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817150847896.png" alt="image-20200817150847896" style="zoom:80%;" />



<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817151557958.png" alt="image-20200817151557958" style="zoom:67%;" />



<p><strong>PS</strong>：命令行参数中，指定的字符集要和项目的字符集一致。</p>
<h2 id="清除缓存和索引"><a href="#清除缓存和索引" class="headerlink" title="清除缓存和索引"></a>清除缓存和索引</h2><p>IDEA首次加载项目时会创建索引。</p>
<p>IntelliJ IDEA的缓存和索引<strong>主要是用来加快文件查询， 从而加快各种查找、代码提示等操作的速度</strong>。但是， IntelliJ IDEA的索引和缓存并不是一直会良好地支持IntelliJ IDEA的，某些特殊条件下， IntelliJ IDEA的缓存和索引文件也是会损坏的， 比如：断电、蓝屏引起的强制关机， 当你重新打开IntelliJ IDEA， 很可能Intell IDEA会报各种莫名其妙错误。这种情况可以清理下缓存和索引。如下：</p>
<p>【File】-》【Invalidate cache/Restart】，选择invalidate and restart。</p>
<p>或者将<code>C:\User\.IntelliJIdea2019.3\system</code>文件删除（需要idea先关闭），并再次启动idea，等待其重新创建索引即可。</p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="下载maven导入jar包的源码和依赖"><a href="#下载maven导入jar包的源码和依赖" class="headerlink" title="下载maven导入jar包的源码和依赖"></a>下载maven导入jar包的源码和依赖</h3><p>点击右侧边栏的maven，如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215147737.png" alt="image-20200820215147737" style="zoom:80%;" />

<p>选择<code>Download Sources</code>下载源码的jar包；选择<code>Download Documentation</code>下载说明文档（javadoc文件）；或者两者都下载。</p>
<p>打开maven的仓库目录，按下图找到对应目录：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215358815.png" alt="image-20200820215358815" style="zoom: 80%;" />



<p>如该图中到仓库下的<code>com\google\protobuf\protobuf-java\3.11.4</code>目录下，可看见下载的javadoc和sources的jar包。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215629801.png" alt="image-20200820215629801" style="zoom: 80%;" />



<h3 id="maven项目构建可执行jar包（包含导入的依赖）"><a href="#maven项目构建可执行jar包（包含导入的依赖）" class="headerlink" title="maven项目构建可执行jar包（包含导入的依赖）"></a>maven项目构建可执行jar包（包含导入的依赖）</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dzblog/p/6913809.html">https://www.cnblogs.com/dzblog/p/6913809.html</a></p>
</blockquote>
<ol>
<li><p>pom.xml文件中配置插件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此处指定main方法入口的class --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>包含main方法的入口类全限定名<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行package命令：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924215425450.png" alt="image-20200924215425450"></p>
</li>
<li><p>在target目录下即可看见项目的包含依赖的可执行jar包。</p>
</li>
</ol>
<blockquote>
<p>不包含依赖、包含部分依赖的打包方式见参考链接。</p>
</blockquote>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">多线程笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 00:21:20" itemprop="dateCreated datePublished" datetime="2021-02-25T00:21:20+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:06:42" itemprop="dateModified" datetime="2021-03-20T20:06:42+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>一个程序进入内存运行时，即变成一个进程。进程是代码在数据集合上的一次运行活动；<strong>进程是系统进行资源分配和调度的一个独立单位</strong>。 </p>
<p>进程的三个特征：</p>
<ul>
<li><strong>独立性</strong>：拥有独立的资源、私有的地址空间。未经允许的情况下，一个进程不能直接访问其他的进程。</li>
<li><strong>动态性</strong>：程序是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程具有自己的生命周期和各种不同状态。</li>
<li><strong>并发性</strong>：多个进程可以在单个处理器上并发执行，进程之间不会互相影响。</li>
</ul>
<p>并发和并行：</p>
<ul>
<li>并发：指同一时刻，只有一条指令执行，但多个进程指令快速轮换执行。<strong>CPU执行指令即为并发执行</strong>。“<strong>微观串行，宏观并行</strong>”。（单核CPU）</li>
<li>并行：同一时刻多个指令同时执行（多核CPU）。</li>
<li>对于多核OS，既有并行又有并发。</li>
</ul>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2) 线程"></a>2) 线程</h4><p><strong>线程是进程中的一个实体，线程本身是不会独立存在的</strong>。线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p>
<p>操作系统在分配资源时是把资源分配给进程的的， 但是<strong>CPU资源是被分配到线程的， 因为真正要占用CPU运行的是线</strong>程，所以也说<strong>线程是CPU分配的基本单位</strong>。在Java中，<strong>当启动main函数时其实就启动了一个JVM的进程， 而main函数所在的线程就是这个进程中的一个线程，也称主线程</strong>。</p>
<p>&emsp;&emsp;</p>
<p>一个进程可以同时并发处理多个任务（即执行多个线程）。线程也被称作轻量级进程。线程是进程的执行单元。<strong>线程是一个指令流</strong>。</p>
<p><strong>于绝大多数的应用程序来说，通常仅要求有一个主线程，但也可以在该进程内创建多条顺序执行流，这些顺序执行流就是线程，每个线程也是互相独立的。</strong>   </p>
<ul>
<li><strong>线程拥有自己的堆栈、自己的程序计数器和自己的局部变量</strong>，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。多个线程共享父进程里的全部资源，需要确保线程不会妨碍同一进程里的其他线程。</li>
<li>线程是独立运行的，它并不知道进程中是否还有其他线程存在。<strong>线程的执行是抢占式</strong>(当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。)</li>
<li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li>
<li>多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行.</li>
<li>线程的调度和管理由进程本身负责完成。</li>
<li>一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程.</li>
</ul>
<p><strong><em>归纳</em></strong>：<br><strong>操作系统可以同时执行多个任务，每个任务即为一个进程；进程可同时执行多个任务，每个任务即为一个线程。单线程只有一个顺序执行流，多线程有多个，多个顺序流之间互不干扰。</strong></p>
<h3 id="多线程相比于多进程的优势"><a href="#多线程相比于多进程的优势" class="headerlink" title="多线程相比于多进程的优势"></a>多线程相比于多进程的优势</h3><p>（为什么使用多线程而不是用多进程）</p>
<ul>
<li>进程中线程隔离程度小，使得多线程程序并发性高。</li>
<li>进程之间不能共享内存，而线程可以，运行效率高。</li>
<li>创建进程系统需为该进程分配独立内存空间，并分配大量资源，而创建线程代价小得多。</li>
<li>Java语言内置多线程功能支持。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>从方法调用的角度来讲，</p>
<ul>
<li>如果需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p>同步在多线程中还有另外一层意思，是让多个线程步调一致</p>
<p>&emsp;&emsp;</p>
<h3 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h3><ul>
<li>windows<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程 </li>
<li>tasklist 查看进程 </li>
<li>taskkill 杀死进程</li>
</ul>
</li>
<li>linux<ul>
<li><code>ps -fe</code> 查看所有进程 </li>
<li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程 </li>
<li><code>kill</code> 杀死进程 </li>
<li><code>top</code> 按大写 H 切换是否显示线程 </li>
<li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li>
</ul>
</li>
<li>Java<ul>
<li>jps 命令查看所有 Java 进程 </li>
<li>jstack &lt;PID&gt; 查看某个 Java 进程（PID）的所有线程状态 </li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<hr>
<h2 id="线程的3种创建方式"><a href="#线程的3种创建方式" class="headerlink" title="线程的3种创建方式"></a>线程的3种创建方式</h2><p>Java使用<strong>Thread类</strong>代表线程，每个线程对象都是Thread类实例或Thread类的子类实例。<br>每个线程的作用是完成一定的任务，即执行一段程序流。Java使用线程执行体来代表这段程序流。</p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>定义Thread类子类，重写run()方法。<strong>run()<em>方法的方法体代表线程要完成的任务</em></strong>。  </p>
<p>Thread类常用方法：</p>
<ul>
<li>run()</li>
<li>start()</li>
<li>getName()<br>获取调用该方法的线程的名字</li>
<li>Thread.currentThread()<br>Thread类的静态方法，返回<strong>当前正在执行</strong>的线程对象（返回值为Thread）。</li>
</ul>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">				<span class="keyword">new</span> FirstTread().start();</span><br><span class="line">				<span class="keyword">new</span> FirstTread().start();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或使用匿名内部类方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;thread is running...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><strong>使用继承Thread类的方法创建线程时，多个线程之间无法共享线程类的实例变量（每个线程都是独立的）</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Runnable接口是一个函数式接口，包含一个<code>run()</code>方法。<strong>通过实现该接口来创建线程任务</strong>。</p>
<p>eg:</p>
<p>1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByRunnable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Runnable runnable = () -&gt; log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(; i &lt; <span class="number">100</span> ;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> +i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">		    <span class="comment">//通过该方法创建线程，要获取线程名称只能通过currentThread()调用getName()</span></span><br><span class="line">		    <span class="comment">//无法通过this引用直接调用getName()</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">				SecondThread st = <span class="keyword">new</span> SecondThread();</span><br><span class="line">				<span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line">				<span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>该例子的两个子线程共享i变量（两个子线程输出的i变量是连续的）。</strong><br><strong>即采用同一个Runnable变量创建的线程可共享线程类的实例变量。</strong></p>
<p>&emsp;&emsp;</p>
<p>使用该方法将线程和任务分开，更加灵活。</p>
<p>&emsp;&emsp;</p>
<h3 id="使用FutureTask"><a href="#使用FutureTask" class="headerlink" title="使用FutureTask"></a>使用FutureTask</h3><p>FutureTask的继承关系：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210115247727.png" alt="image-20210210115247727"></p>
<p>FutureTask中封装了一个Callable接口。</p>
<p>Callable接口<strong>提供一个call()方法作为线程执行体</strong>，与run()方法相比：</p>
<ul>
<li>call()方法有返回值。</li>
<li>call()方法可以抛出异常。</li>
</ul>
<p>Callable接口的call()方法并不是直接调用，而是作为线程执行体被调用。</p>
<p>Future的几个控制与他关联的Callable任务公共方法：</p>
<ol>
<li><code>boolean cancel( boolean maylnterruptlfrunnin)</code>：试图取消该Future里关联的 Callable任务。</li>
<li><code>V get()</code>:返回 Callable任务里call()方法的返回值。<strong>调用该方法将导致程序阻塞，必须等到子线程结束后才会得到返回值（其他线程将被阻塞，直到该子线程执行完毕并返回对应值）</strong>。</li>
<li><code>V get(long timeout， Timeunit unit)</code>:返回 Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出Timeoutexception异常。</li>
<li><code>boolean isCancelled()</code>:如果在Callable任务正常完成前被取消，则返回true。</li>
<li><code>boolean isDone()</code>:如果 Callable任务已完成，则返回true。  </li>
</ol>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread&#x27;s running...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;the return value of the task: &quot;</span> + task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程的返回值通过FutureTask对象的get()方法获取，<strong>且当调用该方法时当前线程会阻塞，直到FutureTask执行完毕才返回，若是在调用线程的<code>start()</code>方法之前调用get方法，会陷入死锁</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="三种方式优缺点"><a href="#三种方式优缺点" class="headerlink" title="三种方式优缺点"></a>三种方式优缺点</h3><p>通过实现Runnable、Callable接口创建多线程的优缺点：  </p>
<ul>
<li>线程类只是实现了对应接口，可继承其他的类。</li>
<li>多个线程可以共享一个target对象。适合多个相同线程处理同一份资源的情况。<strong>可以将CPU、代码和数据分开，形成清晰的模型，体现面向对象的思想</strong>。</li>
<li>劣势：编程稍稍复杂，访问当前线程只能用<code>Thread.currentThread()</code>方法。  </li>
</ul>
<p>继承Thread方法的优缺点：</p>
<ul>
<li>劣势：<strong>不可继承其他父类</strong>。</li>
<li>优势：编写简单。<strong>使用当前线程可直接使用this</strong>。</li>
</ul>
<p>Runnable、继承Thread都不能获取线程返回值，使用FutrueTask可以获取返回值，且<code>call()</code>方法可以抛出异常。</p>
<p><strong>推荐方法为实现Runnable接口、Callable接口</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="线程中的常用方法"><a href="#线程中的常用方法" class="headerlink" title="线程中的常用方法"></a>线程中的常用方法</h2><h3 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h3><p>wait、notify、notifyAll是<strong>Object类中的实例方法</strong>。</p>
<p>3个api：</p>
<ul>
<li><code>wait()</code> 让进入 object 监视器的线程到 waitSet <strong>一直</strong>等待 </li>
<li><code>wait(long n)</code> 等待直到时间超时后进入EntryList</li>
<li><code>notify()</code> 在 object 上正在 waitSet 等待的线程中随机唤醒一个。<strong>interrupt()可以叫醒wait中的线程</strong>。</li>
<li><code>notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210216174346353.png" alt="image-20210216174346353"></p>
<ul>
<li><p>Owner 线程发现条件不满足时，<strong>调用 wait 方法，进入 WaitSet 变为 WAITING 状态，等待被唤醒</strong> 。</p>
</li>
<li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </p>
</li>
<li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </p>
</li>
<li><p>而WAITING 线程只能<strong>在 Owner 线程中调用 notify 或 notifyAll 唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</strong>。</p>
</li>
<li><p><strong><font color="red">当前线程必须拥有对象的monitor才能调用这些api，否则抛出IllegalMonitorStateException异常</font></strong>。<code>wait()</code>的JavaDoc：</p>
<p><code>The current thread must own this object&#39;s monitor  </code> </p>
<blockquote>
<p>注意是1个对象对应1个monitor</p>
</blockquote>
</li>
<li><p><strong>当前线程调用<code>wait()</code>只会释放当前该共享变量的锁，而该线程的其他锁是不会释放的</strong>。</p>
</li>
<li><p>被唤醒的线程不能马上从wait方法返回并继续执行， 它<strong>必须在获取了共享对象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行</strong>。</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h4 id="使用的正确姿势"><a href="#使用的正确姿势" class="headerlink" title="使用的正确姿势"></a>使用的正确姿势</h4><p><strong>sleep和 wait的异同</strong>：</p>
<ol>
<li><p>sleep 是 Thread 方法，而 wait 是 Object 的方法 </p>
</li>
<li><p>sleep 不需要强制和 synchronized 配合使用，<strong>但 wait 需要 和 synchronized 一起用</strong> </p>
</li>
<li><p><strong><font color="red">sleep在睡眠的同时不会释放对象锁，但 wait 在等待的时候会释放对象锁 </font></strong>。</p>
</li>
<li><p>它们状态都是TIMED_WAITING。</p>
</li>
</ol>
<p>&emsp;&emsp;</p>
<p>以下姿势对应的demo在<code>practice/useWaitNotifyOBBK</code>包下。</p>
<p><strong>姿势1</strong>：某些条件不满足时调用sleep会占用锁，使用wait更合理。</p>
<p><strong>姿势2</strong>：若是有多个线程在WaitSet，则不宜使用<code>notify()</code>，它只能随机唤醒一个，不能唤醒满足条件的线程。应使用<code>notifyAll()</code>（显然会唤醒部分不满足条件的线程）。</p>
<p><strong>姿势3</strong>：使用循环进行<code>wait()</code>，不满足条件则一直等。<strong>一个线程即使没有被其他线程调用<code>notify()</code>、<code>notifyAll()</code>方法进行通知、或者被中断、或者等待超时，也可以被唤醒，这就是所谓的虚假唤醒</strong>。虽然虚假唤醒很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	<span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">		lock.wait();</span><br><span class="line">	&#125; <span class="comment">// 干活 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程 </span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	lock.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="park、unpark"><a href="#park、unpark" class="headerlink" title="park、unpark"></a>park、unpark</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>它们是 LockSupport 类中的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程 </span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行 </span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>

<p>与 Object 的 wait &amp; notify 相比 </p>
<ul>
<li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p>
</li>
<li><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 </p>
</li>
<li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><strong>每个线程都关联一个 Parker 对象</strong>，由三部分组成 _counter ， _cond 和 _mutex</p>
<ul>
<li>_counter ：值为0或1，调用park时若<code>_count</code>为0则当前线程阻塞，为1则将其减1并继续运行，无需阻塞。</li>
<li>_cond：相当于阻塞队列。</li>
<li>_mutex：互斥锁，操作<code>_count</code>时需要获取该锁？。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>先调用<code>park()</code>，再调用<code>unpark()</code>过程解析：</p>
<ul>
<li>调用<code>park()</code>：</li>
</ul>
<ol>
<li><p>当前线程调用 Unsafe.park() 方法 </p>
</li>
<li><p>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁 </p>
</li>
<li><p>线程<strong>进入 _cond 条件变量阻塞</strong> </p>
</li>
<li><p><strong>设置 _counter = 0</strong> </p>
</li>
</ol>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217142957852.png" alt="image-20210217142957852" style="zoom: 67%;" />

<ul>
<li>调用<code>unpark()</code>：</li>
</ul>
<ol>
<li><p>设置 _counter 为 1 </p>
</li>
<li><p>唤醒 _cond 条件变量中的 Thread_0 </p>
</li>
<li><p>Thread_0 恢复运行 </p>
</li>
<li><p>设置 _counter 为 0</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143224158.png" alt="image-20210217143224158" style="zoom:67%;" />

</li>
</ol>
<p>&emsp;&emsp;</p>
<p>先调用<code>unpark()</code>，再调用<code>park()</code>过程解析：</p>
<ol>
<li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 </p>
</li>
<li><p>当前线程调用 Unsafe.park() 方法 </p>
</li>
<li><p><strong>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</strong>  </p>
</li>
<li><p>设置 _counter 为 0</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143503716.png" alt="image-20210217143503716" style="zoom:67%;" />

</li>
</ol>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>以下api都是Thread类的方法。</p>
<ul>
<li><p><code>interrupt()</code>：中断线程，<strong style="color:red">但其实只是将线程的中断标志置为true，线程还是会继续运行</strong>。</p>
<ul>
<li><strong>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记</strong> ；</li>
<li>否则，<strong>仅仅设置打断标记 ，但并不会使线程停止（即调用interrupt只是让线程知道有人要终止它，它可以先进行某些处理后再自行终止线程）</strong>。</li>
<li>被<code>LockSurpport.park()</code><strong>暂停</strong>的线程被打断则会继续运行，<strong>且会设置打断标记为true</strong>。</li>
</ul>
<p>**demo见<code>JavaConcurrentDemo/trhead_basic/TestInterrupt</code>**。</p>
</li>
<li><p><code>isInterrupted()</code>：返回中断标志，<strong>不清除中断标志</strong>。</p>
</li>
<li><p><code>static interrupted()</code>：判断当前线程是否被打断。<strong>清除中断标记（即将中断标志置false）</strong>。<strong>注意是静态方法</strong>。</p>
<ul>
<li><p>该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要注意返回的是<font color="red">“当前线程”</font>的中断标志</strong>。</p>
</li>
</ul>
</li>
<li><p><code>private native boolean isInterrupted(boolean ClearInterrupted)</code>：私有方法，返回中断标志，并根据ClearInterrupted参数决定是否清除中断标志，上面2个方法都是调用了该方法。</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="Thread类方法"><a href="#Thread类方法" class="headerlink" title="Thread类方法"></a>Thread类方法</h3><ul>
<li><p><code>start()</code>：启动一个新线程，在新的线程运行run方法中的代码。<strong>start方法只是让线程进入就绪，里面代码不一定立刻运行</strong>（CPU的时间片还没分给它）。<strong>每个线程对象的 start方法只能调用一次</strong>，如果调用了多次会出IllegalThreadStateException</p>
</li>
<li><p><code>run()</code>：如果在构造Thread对象时传递了 Runnable 参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为。</p>
</li>
<li><p><code>join()</code> ：<strong>在当前线程中阻塞，直到指定线程运行结束，<font color="red">注意此时当前线程是在指定线程对象上的monitor等待（即在该monitor的WaitSet上）</font></strong>。其他线程调用因<code>join()</code>阻塞线程的<code>interrupt()</code>方法时，被打断程序会抛出InterruptedException 并返回。</p>
</li>
<li><p><code>join(long n) </code>：等待线程运行结束,最多等待 n 毫秒</p>
</li>
<li><p><code>setPriority(int)</code> ：线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用。</p>
</li>
<li><p><code>isAlive()</code>：线程是否存活 （还没有运行完毕）</p>
</li>
<li><p><code>sleep()</code>：</p>
</li>
<li><p>在一些<code>while(true)</code>中可以使用sleep来避免占用过多的cpu用于空转。</p>
<ul>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） </li>
<li><strong>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时线程会抛出 InterruptedException并返回</strong> 。</li>
<li>睡眠结束后的线程未必会立刻得到执行 </li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。如<code>TimeUnit.SECONDS.sleep(2);</code>表示睡眠2s。</li>
</ul>
</li>
<li><p><code>static currentThread()</code>：获取当前正在执 行的线程</p>
</li>
<li><p><code>static yield()</code>：提示线程调度器让出当前线程对 CPU的使用，<strong>线程调度器可以无视这个提示</strong>。<strong>调用该方法时，当前线程会进入就绪状态，线程调度器会重新执行调度，当然有可能重新调度到执行yeild的线程</strong>。</p>
<ul>
<li>示例：若没有<code>Thread.yield();</code>，则两个线程打印的count数相差不大；加上<code>Thread.yield();</code>，可以看到线程1明显打印的更快。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----&gt;1 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">               Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;              ----&gt;2 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp; </p>
<p>其他方法：</p>
<ul>
<li><p><code>getState()</code></p>
</li>
<li><p><code>getId()</code> </p>
</li>
<li><p><code>getName()</code> </p>
</li>
<li><p><code>setName(String)</code> </p>
</li>
<li><p><code>getPriority() </code></p>
</li>
</ul>
<p>停止线程使用“两阶段停止模式”（demo TestTwoPhaseTermination），而不要使用以下过时方法：</p>
<ul>
<li>stop() </li>
<li>suspend() </li>
<li>resume() static </li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="理解线程上下文切换"><a href="#理解线程上下文切换" class="headerlink" title="理解线程上下文切换"></a>理解线程上下文切换</h2><p>在多线程编程中线程个数一般都大于CPU个数， 而每个CPU同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行的， CPU资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片， 线程在时间片内占用CPU执行任务。<strong>当前线程使用完时间片后就会处于就绪状态并让出CPU让其他线程占用， 这就是上下文切换</strong>。</p>
<p>在切换线程上下文时需要保存当前线程的执行现场，当再次执行时根据保存的执行现场信息恢复执行现场。</p>
<p>&emsp;&emsp;</p>
<p>概括来说就是：<strong>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>线程上下文切换的时机有：</p>
<ul>
<li>当前线程的CPU时间片使用完处于就绪状态时。</li>
<li>当前线程被其他线程中断时。</li>
</ul>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>&emsp;&emsp;</p>
<h2 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h2><p><strong>Java中的线程分为两类， 分别为daemon线程(守护线程) 和user线程(用户线程)</strong> 。在JVM启动时会调用main函数， main函数所在的线程就是一个用户线程， 其实在JVM内部同时还启动了好多守护线程，比如垃圾回收线程。</p>
<p><strong>当最后一个非守护线程结束时， JVM会正常退出， 而不管当前是否有守护线程， 也就是说， 只要有一个用户线程还没结束，正常情况下JVM就不会退出</strong>。</p>
<p>创建的线程默认是用户线程，可以通过Thread的<code>setDeamon(true)</code>可将线程设置为守护线程。</p>
<p>示例demo：TestDeamon。</p>
<p>&emsp;&emsp;</p>
<h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><h3 id="从OS层面"><a href="#从OS层面" class="headerlink" title="从OS层面"></a>从OS层面</h3><p>从操作系统层面，线程的生命周期包括<strong>新建（New），就绪（Ready），运行（Running），阻塞（Blocked），死亡（Dead）</strong>。CPU在多个线程之间切换时，线程状态也在Ready、Running之间切换。</p>
<h4 id="新建与就绪状态"><a href="#新建与就绪状态" class="headerlink" title="新建与就绪状态"></a>新建与就绪状态</h4><p><strong>使用new关键字创建一个线程时，该线程即处于新建状态</strong>，此时JVM仅为它分配内存，初始化成员变量的值（与new普通对象一样）。<br><strong>调用start()方法后，线程处于就绪状态</strong>，<strong>JVM为其创建方法调用栈和程序计数器</strong>，<strong>此时线程并没有运行，只是表示其可以运行</strong>，何时运行取决于JVM里线程调度器的调度。 </p>
<p>&emsp;&emsp;</p>
<h4 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h4><p>处于就绪状态的线程获得CPU，开始执行run()方法，则<strong>处于运行状态</strong>。如果只有一个CPU，则每个时刻只有一个线程在运行状态。<br>线程调度策略：</p>
<ul>
<li><strong>抢占式策略</strong>：系统给每个线程一小段时间处理任务，时间用完后，系统剥夺该线程所占用的资源，让给其他线程。选择下一个线程时，系统会考虑线程优先级。</li>
<li><strong>协作式调度策略</strong>：只有一个线程调用它的sleep()或yield()方法后才会放弃所占用的资源——即必须由线程主动放弃资源。  </li>
</ul>
<p>发生以下情况时，<strong>线程进入阻塞状态</strong>：</p>
<ul>
<li>线程调用sleep()。</li>
<li>线程调用一个阻塞式IO方法，在该方法返回之前。</li>
<li>线程试图获取一个同步监视器，但该监视器被其他线程所持有。</li>
<li>线程在等待某个通知（notify）。</li>
<li>线程调用suspend()方法将该线程挂起。（该方法<strong>容易导致死锁</strong>）  </li>
</ul>
<p>当线程被阻塞，其他线程即可获得CPU。被阻塞的线程在合适的时候进入就绪状态（而不是运行状态，解除阻塞后，必须重新等待线程调度器调用它）。<br>发生以下情况时，阻塞的线程进入就绪状态（对应上面的情况）：</p>
<ul>
<li>sleep()方法超过指定时间。</li>
<li>IO方法已返回。</li>
<li>获得同步监视器。</li>
<li>线程正在等待通知时，其他线程发出了一个通知。</li>
<li>被挂起的线程调用resume()恢复方法。</li>
</ul>
<h4 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h4><p>线程以如下三种方式结束时死亡：</p>
<ul>
<li>run()或call()方法执行完毕。</li>
<li>抛出Exception或Error。</li>
<li>调用线程的stop()方法。（<strong>容易导致死锁</strong>）  </li>
</ul>
<p>判断某个线程是否已死亡可调用线程的isAlive()方法（<strong>处于新建、死亡状态返回false</strong>，处于就绪、运行、阻塞返回true）。</p>
<blockquote>
<ul>
<li><strong>主线程结束时，其他线程不受影响。一旦子线程启动，就拥有与主线程相同地位</strong>。</li>
<li>不要对一个已死亡的线程调用start()。  </li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<h3 id="从Java-API方面"><a href="#从Java-API方面" class="headerlink" title="从Java API方面"></a>从Java API方面</h3><p>（以下图片来自JavaGuide）</p>
<p>在<strong>Thread中的State枚举类里定义了线程的6种状态</strong>：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215044761.png" alt="image-20210210215044761"></p>
<p>其中，将OS层面的就绪（Ready）和运行（Running）状态统称为 <strong>RUNNABLE（可运行）</strong> 状态 。</p>
<blockquote>
<p>在idea中debug时，BLOCKED状态显示为MONITOR</p>
</blockquote>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>Java 线程状态变迁如下图（<strong>大概情况</strong>）：（这里join方法应是来自Thread类）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215151522.png" alt="image-20210210215151522" style="zoom: 80%;" />

<p>其中的一些情况补充：</p>
<ul>
<li><p>WAITING &lt;–&gt; RUNNABLE：调用 <code>obj.notify()  obj.notifyAll()  t.interrupt()</code> 时线程不是直接进入RUNNABLE状态，而是进入EntryList后再竞争锁（<i>对于join、park等应该也是</i>）：</p>
<ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE </li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
<li><p>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING。<strong><font color="red">注意是当前线程在t 线程对象的监视器上（具体是在WaitSet上）等待</font></strong>。<br>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
<li><p>RUNNABLE &lt;–&gt; BLOCKED：</p>
<ul>
<li>t 线程用 <code>synchronized(obj)</code> <strong>获取对象锁时如果竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED </li>
<li><strong>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争</strong>，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="变量的线程安全"><a href="#变量的线程安全" class="headerlink" title="变量的线程安全"></a>变量的线程安全</h2><h3 id="成员变量和静态变量"><a href="#成员变量和静态变量" class="headerlink" title="成员变量和静态变量"></a>成员变量和静态变量</h3><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 <ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li>局部变量是线程安全的 </li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的 </li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p>对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul>
<li>String、Integer：String、Integer 等都是不可变类，因为<strong>其内部的状态不可以改变</strong>，因此它们的方法都是线程安全的。对于String的replace，substring 等方法，其实质是返回一个新的字符串。</li>
<li>StringBuffer</li>
<li>Random </li>
<li>Vector</li>
<li>Hashtable </li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong>。它们的每个方法是原子的，<strong>但注意它们多个方法的组合不是原子的</strong>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable(); </span><br><span class="line"><span class="comment">// 线程1，线程2 </span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="keyword">null</span>) &#123; </span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种线程不安全的执行示例：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210213172057961.png" alt="image-20210213172057961"></p>
<p>&emsp;&emsp;</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>死锁是指<strong>两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。发生死锁时，整个程序不会发生任何异常，也不会给出任何提示，如果没有外力作用，这些线程会一直等待，无法继续运行</strong>。</p>
<p><strong style="color:red">发生死锁的4个条件</strong>：</p>
<ul>
<li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li>
<li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程一资源的环形链，即线程集合{T0，T1，T2，…，Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>避免死锁可以通过破坏4个条件的至少一个实现，<strong>而目前只有请求并持有和环路等待条件是可破坏的</strong>。造成死锁的原因和资源申请顺序关系很大，可以使用资源的有序性申请来避免死锁（<strong>破坏环路等待条件</strong>）。有序性即：<strong>假如线程A和线程B都需要资源1，2，3，…，n时，对资源进行排序，<font color="red">线程A和线程B只有在获取了资源n-1时才能去获取资源n</font></strong>。</p>
<p>&emsp;&emsp;</p>
<p>一种死锁示例：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">* t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁</span></span><br><span class="line"><span class="comment">* t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                sleep(<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="检测死锁的工具"><a href="#检测死锁的工具" class="headerlink" title="检测死锁的工具"></a>检测死锁的工具</h3><h4 id="jstack命令"><a href="#jstack命令" class="headerlink" title="jstack命令"></a>jstack命令</h4><p>运行上述示例代码，在cmd输入<code>jps</code>，查看线程id，再执行<code>jstack thread_id</code>输出检测结果。</p>
<p>输出结果的部分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">  waiting to <span class="keyword">lock</span> monitor <span class="number">0x000000000297c178</span> (<span class="keyword">object</span> <span class="number">0x00000000d6b65178</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held <span class="keyword">by</span> <span class="string">&quot;t1&quot;</span></span><br><span class="line"><span class="string">&quot;t1&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">to</span> <span class="keyword">lock</span> monitor <span class="number">0x000000000297e488</span> (<span class="keyword">object</span> <span class="number">0x00000000d6b65188</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held <span class="keyword">by</span> <span class="string">&quot;t2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Java</span> stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;t2&quot;</span>:</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock.lambda$<span class="keyword">main</span>$<span class="number">1</span>(TestDeadLock.java:<span class="number">34</span>)</span><br><span class="line">        - waiting <span class="keyword">to</span> <span class="keyword">lock</span> &lt;<span class="number">0x00000000d6b65178</span>&gt; (a java.lang.Object)</span><br><span class="line">        - <span class="keyword">locked</span> &lt;<span class="number">0x00000000d6b65188</span>&gt; (a java.lang.Object)</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock$$Lambda$<span class="number">2</span>/<span class="number">1879034789.</span>run(<span class="literal">Unknown</span> <span class="keyword">Source</span>)</span><br><span class="line">        <span class="keyword">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">&quot;t1&quot;</span>:</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock.lambda$<span class="keyword">main</span>$<span class="number">0</span>(TestDeadLock.java:<span class="number">23</span>)</span><br><span class="line">        - waiting <span class="keyword">to</span> <span class="keyword">lock</span> &lt;<span class="number">0x00000000d6b65188</span>&gt; (a java.lang.Object)</span><br><span class="line">        - <span class="keyword">locked</span> &lt;<span class="number">0x00000000d6b65178</span>&gt; (a java.lang.Object)</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock$$Lambda$<span class="number">1</span>/<span class="number">942986815.</span>run(<span class="literal">Unknown</span> <span class="keyword">Source</span>)</span><br><span class="line">        <span class="keyword">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Found</span> <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p>进入cmd，输入<code>jconsole</code>，连接线程。</p>
<p>在线程窗口点击检测死锁，可看到相关信息：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217170359984.png" alt="image-20210217170359984"></p>
<p>&emsp;&emsp;</p>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>5个哲学家围在圆桌上用餐，有5根筷子，只有拥有两根筷子才能吃饭，吃完饭会放下筷子思考，如此反复。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217171857739.png" alt="image-20210217171857739" style="zoom:67%;" />

<p>代码：demo位于<code>lock/deadlock/v1/TestPhilosopher.java</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//　尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p>
<p>示例：（demo：<code>lock/TestLiveLock.java</code>）</p>
<p>t1要将count减到0，t2要加到20，由于它们的运算速度相近，导致一直执行不结束。</p>
<p><strong>可以使用随机sleep时间避免等</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个线程由于优先级太低（或者说长时间运行不了），始终得不到 CPU 调度执行，也不能够结束。</p>
<p>&emsp;&emsp;</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量，JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 **<code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，</strong>即创建一个变量，每一个线程访问该变量获取的都是该变量在该线程的副本**。</p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p><code>sleep(int i)</code>表示睡眠i s</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String str = <span class="string">&quot;str from t1&quot;</span>;</span><br><span class="line">            threadLocal.set(str);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 获取的是自己放置的str，获取不到t2放置的</span></span><br><span class="line">            String str1 = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str after 2s: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获取的str为null，不能获取到t1放置的str</span></span><br><span class="line">            String str = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            String str1 = <span class="string">&quot;str from t2&quot;</span>;</span><br><span class="line">            threadLocal.set(str1);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Thread类包含一个ThreadLocal.ThreadLocalMap成员变量，其实质是一个Map，映射类型是 ThreadLocal-Object，存放多个ThreadLocal的本地副本，</p>
<p>从Thread类源码开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>即<strong>Thread类中有一个threadLocals和一个inheritableThreadLocals， 它们都是ThreadLocalMap类型（<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类）的变量</strong>， 而<strong>ThreadLocalMap是一个定制化的map，存放多个ThreadLocal变量在当前线程的副本，<code>ThreadLocalMap</code>存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</strong>。</p>
<p>在默认情况下， 每个线程中的这两个变量都为nll， <strong>只有当前线程第一次调用Thread Local的<code>set()</code>或者<code>get()</code>方法时才会创建它们</strong>。</p>
<p>从上面可以看出，<strong style="color:red">每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</strong>。<strong>Thread Local就是一个工具壳， 通过它来从当前线程的threadLocals中获取值或放入值</strong>。</p>
<p>如果调用线程一直不终止， 那么这个本地变量会一直存放在调用线程的thread Locals变量里面， 所以当不需要使用本地变量时可以通过调用Thread Local变量的<code>remove()</code>方法， 从当前线程的thread Locas里面删除该本地变量，避免内存泄漏。</p>
<p>&emsp;&emsp;</p>
<p><code>set()</code>、<code>get()</code>的源码简单分析：</p>
<p><code>set()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// threadLocalMap不为null，修改值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 第一次调用则创建当前线程对应的threadLocalMap，并将value放进去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><code>get()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 不为null则从中尝试获取值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前ThreadLocal对象为key，从线程的threadLocalMap中尝试获取值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map为null或其中没有当前ThreadLocal对应的值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong style="color:red">可以看到<code>set()</code>、<code>get()</code>方法都是先从当前线程中获取ThreadLocalMap对象</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p><code>setInitialValue()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();<span class="comment">//该方法只是返回一个null</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="comment">// map不为null（表示其中没有当前ThreadLocal对应的值）</span></span><br><span class="line">    <span class="comment">// 放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 否则创建一个ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 并同样放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><code>createMap()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>Thread、ThreadLoacal、ThreadLoacalMap的关系图解：（图片来自JavaGuide）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210218180050123.png" alt="image-20210218180050123" style="zoom:80%;" />



<h3 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h3><p><strong><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry</strong>。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。<strong>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</strong>。</p>
<blockquote>
<p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放但又无法使用，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
</blockquote>
<p>ThreadLocalMap的静态内部类Entry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="InheritableThreadLocal-to-be-…"><a href="#InheritableThreadLocal-to-be-…" class="headerlink" title="InheritableThreadLocal(to be …)"></a>InheritableThreadLocal(to be …)</h3><p>&emsp;&emsp;</p>
<h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h2><p>CPU与主内存之间会添加一级或多级高速缓冲存储器，即Cache。</p>
<p><strong>在Cache内部是按行存储的， 其中每一行称为一个Cache行</strong>。Cache行是<strong>Cache与主内存进行数据交换的单位</strong>，Cache行的大小一般为2的幂次数字节。当CPU访问某个变量时， 首先会去看CPU Cache内是否有该变量， 如果有则直接从中获取，否则就去主内存里面获取该变量， <strong style="color:red">然后把该变量所在内存区域的一个Cache行大小的内存块（局部性原理）复制到Cache中</strong>。</p>
<p><strong>由于存放到Cache行的是内存块而不是单个变量， 所以可能会把多个变量存放到一个Cache行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</strong>。</p>
<p>比如CPU1、CPU2读取了同一个缓存行，若CPU1对其中的一个变量修改，在缓存一致性协议下，CPU2中对应的缓存行就会失效，即破坏了CPU2的一级缓存，CPU2需要到二级缓存查找（甚至到主存），造成性能下降。</p>
<p>&emsp;&emsp;</p>
<p>比如有4个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure>

<p>假设缓存行大小32字节，一个long类型8个字节，当CPU访问a时，会把a及附近的b、c、d一起放入缓存行。</p>
<p><strong style="color:red">也就是地址连续的多个变量才有可能会被放到一个缓存行中</strong>。比如创建数组时，数组里面的多个元素就会被放入同一个缓存行。</p>
<p>在正常情况下单线程访问时将数组元素放入一个或者多个缓存行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p>
<p>测试缓存行demo见<code>test/TestCacheLine</code>。</p>
<p>&emsp;&emsp;</p>
<p>JDK8之前使用声明多个填充变量的方法来避免伪共享问题，让一个缓存行只有一个有用变量：</p>
<p>该例中，若缓存行大小是64B，则value+p1-6是56B，对象头是8B，所以共64B。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>JDK8提供了一个注解<code>@sun.misc.Contended</code>解决伪共享问题，它可以自行执行填充。上面代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<blockquote>
<p>需要注意的是， 在默认情况下， @Contended注解只用于Java核心类， 比如rt包下的类。如果用户类路径下的类需要使用这个注解， 则需要添加JVM参数：<code>-XX:-RestrictContended</code>。填充的宽度默认为128，要自定义宽度则可以设置</p>
<p><code>-XX:ContendedPaddingWidth</code>参数。</p>
</blockquote>
<h2 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。</p>
<p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以<strong>在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态</strong>。</p>
<blockquote>
<p>悲观锁的<strong>实现往往依靠数据库提供的锁机制</strong>，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以<strong>在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测</strong>。比如根据update返回的行数让用户决定如何去做。</p>
<p>乐观锁并不会使用数据库提供的锁机制， 一般在表中添加version字段（<strong>每次根据id和version修改记录，若修改成功，将version+1</strong>）或者使用业务状态来实现。乐观锁直到提交时才锁定，所以不会产生任何死锁。</p>
<p>&emsp;&emsp;</p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，</p>
<ul>
<li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的。</li>
<li>非公平锁则是先来不一定先得。</li>
</ul>
<p>Reentrant Lock提供了公平和非公平锁的实现。</p>
<ul>
<li>公平锁：<code>Reentrant Lock pair Lock=nhew Reentrant Lock(true)</code> 。</li>
<li>非公平锁：<code>Reentrant Lock pair Lock=new Reentrant Lock(false) </code>。如果构造函数不传递参数，则默认是非公平锁。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p><strong>独占锁表示一个锁只能被一个线程获取，共享锁则可以被多个线程获取</strong>。</p>
<p><strong>独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性</strong>，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<p>&emsp;&emsp;</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>当一个线程可以再次获取它已经获取了的锁，则该锁是可重入的。synchronized内部锁和ReentrantLock都是可重入锁。</p>
<p>&emsp;&emsp;</p>
<p>可重入锁的原理是<strong>在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器</strong>。一开始计数器值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁时，计数器的值会变成1，这时其他线程再来获取该锁时<strong>会发现锁的所有者不是自己而被阻塞挂起</strong>。但是当<strong>获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+1</strong>，当释放锁后计数器值-1。当计数器值为0时， 锁里面的线程标示被重置为null， 这时候被阻塞的线程会被唤醒来竞争获取该锁。</p>
<p>&emsp;&emsp;</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>由于Java中的线程是与操作系统中的线程一一对应的，<strong>所以当一个线程在获取锁(比如独占锁)失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。<font color="red">而从用户状态切换到内核状态的开销是比较大的</font>，在一定程度上会影响并发性能</strong>。</p>
<p>自旋锁是<strong>当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取</strong>（默认次数是10，可以使用<code>-XX：PreBlockSpinsh</code>参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。</p>
<p>由此看来自旋锁是使用CPU时间换取线程阳塞与调度的开销， <strong>但是很有可能这些CPU时间白白浪费了</strong>。</p>
<p>&emsp;&emsp;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">JVM垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 13:20:53" itemprop="dateCreated datePublished" datetime="2021-02-18T13:20:53+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:51:21" itemprop="dateModified" datetime="2021-03-20T20:51:21+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<p>对于程序计数器、虚拟机栈、本地方法栈，这几个区域的内存分配和回收都具有确定性，它们随着线程结束或方法结束时回收内存。<strong>而堆和方法区则有很大的不确定性：只有到运行期才能知道程序要创建哪些对象，创建多少对象，它们的内存分配和回收是动态的</strong>。</p>
<p>&emsp;&emsp;</p>
<p>Java 的自动内存管理<strong>主要是针对对象内存的回收和对象内存的分配</strong>。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong> </p>
<p><strong>堆空间的基本结构</strong>（图片来自javaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129095613698.png" alt="image-20210129095613698"></p>
<p>&emsp;&emsp;</p>
<h2 id="判断对象已死"><a href="#判断对象已死" class="headerlink" title="判断对象已死"></a>判断对象已死</h2><p>垃圾收集器对堆回收之前需要判断哪些对象存活，哪些死亡（<strong>即不能再被任何途径使用的对象</strong>）。有<strong>引用计数算法和可达性分析算法</strong>两种判断方式。</p>
<p>&emsp;&emsp;</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；<strong>任何时候计数器为 0 的对象就是不可能再被使用的</strong>。</p>
<p>这个方法实现简单，效率高，但是目前<strong>主流的虚拟机中并没有选择这个算法</strong>来管理内存，其最主要的原因是它<strong>很难解决对象之间相互循环引用的问题</strong>。</p>
<p>循环依赖示例：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，<strong>于是引用计数算法无法通知 GC 回收器回收他们</strong>。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是<strong>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的</strong>。</p>
<p><strong>可作为 GC Roots 的对象</strong>包括下面几种:</p>
<ul>
<li><strong>虚拟机栈</strong>(栈帧中的本地变量表)中引用的对象</li>
<li><strong>本地方法栈</strong>(Native 方法)中引用的对象</li>
<li><strong>方法区</strong>中<strong>类静态属性引用</strong>的对象</li>
<li><strong>方法区</strong>中<strong>常量引用的对象</strong> </li>
<li>Java虚拟机内部引用，如基本类型对应的Class对象，系统类加载器、常驻异常对象等。</li>
<li>被同步锁（synchronized关键字）持有的对象。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p><strong>JDK1.2 之前</strong>，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p><strong>JDK1.2 以后</strong>，Java 对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种（<strong>引用强度逐渐减弱</strong>）。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。<strong>在任何情况下，只要这个强引用存在，垃圾回收器绝不会回收它</strong>。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>&emsp;&emsp;</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述一些<strong><font color="red">还有用，但非必须的对象</font></strong>。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存</strong>。</p>
<p>软引用<strong>可以和一个引用队列（ReferenceQueue）联合使用</strong>，如果<strong>软引用所引用的对象被垃圾回收</strong>，JAVA 虚拟机就会<strong>把这个软引用</strong>加入到与之关联的引用队列中。后续可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。</p>
<p>&emsp;&emsp;</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，<strong style="color:red">它只能生存到下一次垃圾收集发生</strong>。</p>
<p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>&emsp;&emsp;</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<font color="red">虚引用主要用来跟踪对象被垃圾回收的活动</font></strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用<strong>必须和引用队列</strong>（ReferenceQueue）<strong>联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<strong>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收</strong>。程序如果发现某个虚引用已经被加入到引用队列，那么就<strong>可以在所引用的对象的内存被回收之前采取必要的行动</strong>。</p>
<p>&emsp;&emsp;</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="“非死不可”？"><a href="#“非死不可”？" class="headerlink" title="“非死不可”？"></a>“非死不可”？</h3><p><strong>即使在可达性分析法中不可达的对象，也并非是“非死不可”的</strong>，这时候它们暂时处于“缓刑阶段”，要<strong>真正宣告一个对象死亡，至少要经历两次标记过程</strong>：可达性分析法中不可达的对象被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p><strong>被判定为需要执行的对象将会被放在一个队列中，并由一个低优先级线程去执行它们的<code>finalize()</code>方法</strong>，除非这个对象在<code>finalize()</code>方法中与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<p><strong style="color:red">这种“自救”不推荐被使用</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p><strong>方法区也是垃圾回收的对象区域</strong>，这里的垃圾收集主要包含两部分内容：<strong>废弃的常量和不再使用的类型</strong>。方法区的垃圾收集通常“性价比”比较低。</p>
<h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><p>运行时常量池主要回收的是废弃的常量。判断一个常量是否废弃：</p>
<p><strong>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了</strong>。</p>
<p>&emsp;&emsp;</p>
<p><strong><font color="red">关于常量池，方法区，元空间</font></strong>：</p>
<ol>
<li>JDK1.7 <strong>之前</strong>运行时常量池逻辑包含字符串常量池存放在方法区， 此时 HotSpot 虚拟机对方法区的实现为永久代</li>
<li><strong>JDK1.7  字符串常量池 被从方法区拿到了堆中</strong>， 这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区， 也就是 HotSpot 中的永久代 。</li>
<li>JDK1.8 HotSpot 移除了永久代用元空间(Metaspace)取而代之，<strong><font color="red"> 这时候字符串常量池还在堆， 运行时常量池还在方法区， 只不过方法区的实现从永久代变成了元空间</font></strong>(Metaspace)。</li>
</ol>
<p>&emsp;&emsp;</p>
<h4 id="回收类"><a href="#回收类" class="headerlink" title="回收类"></a>回收类</h4><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p>
<p>类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<blockquote>
<p>在大量使用反射、动态代理、CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 通常都需要Java虚拟机具备类型卸载的能力， <strong>以保证不会对方法区造成过大的内存压力</strong>。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集理论的3个经验法则：</p>
<ul>
<li><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p>
</li>
<li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
</li>
<li><p>跨代引用假说：跨代引用相对于同代引用来说占极少数。</p>
<blockquote>
<p>假如要进行一次只局限于新生代区域内的收集(Minor GC) ， <strong>但新生代中的对象是完全有可能被老年代所引用的</strong>， 为了找出该区域中的存活对象， 不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。但无疑会为内存回收带来很大的性能负担。为了解决这个问题，于是添加了第3个经验法则。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p>分代收集理论放到具体的JVM中，设计者一般至少把Java堆划分为新生代和老年代。在Java堆划分出不同的区域之后，<strong>垃圾收集器才可以每次只回收其中某一个或者某些部分的区域</strong>——因而有了“Minor GC”、“Major GC”、“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。</p>
<p>&emsp;&emsp;</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</strong>。（或者反过来标记不需要回收的对象）</p>
<p>它是<strong>最基础的收集算法，后续的算法都是对其不足进行改进得到</strong>。这种垃圾收集算法会带来两个明显的问题：</p>
<ul>
<li><p><strong>效率问题</strong>。如果堆中很多对象需要回收，这时必须进行大量清除和标记的动作。</p>
</li>
<li><p><strong>内存碎片问题（标记清除后会产生大量不连续的碎片）</strong> </p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。<strong>它将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收</strong>。</p>
<p>这样实现简单，运行高效，<strong>缺陷也明显，可用内存缩小了一半，且当对象存活率较高时，该算法效率较低</strong>。</p>
<p>&emsp;&emsp;</p>
<p>针对内存浪费太多的改进（Appel式回收）：<strong>把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间</strong>。HotSpot虚拟机<strong>默认Eden和Survivor的大小比例是8：1</strong>， 只有10%的新生代是会被“浪费”的。</p>
<p>但也没有办法保证每次回收都只有不多于10%的对象存活， 因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计， 当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（<strong>实际上大多就是老年代</strong>）进行分配担保(Handle Promotion) </p>
<p>&emsp;&emsp;</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法不适合老年代，因为老年代的回收率低，需要复制的对象太多。<strong style="color:red">标记-整理算法是针对老年代的</strong>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<strong>而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</strong>。</p>
<p>图示（来自JavaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129150506762.png" alt="image-20210129150506762"></p>
<p>&emsp;&emsp;</p>
<p>标记-清除、标记-整理的<strong>本质区别在于是不是移动式的回收算法</strong>。是否移动对象都存在弊端：</p>
<ul>
<li>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，<strong>移动存活对象并更新所有引用这些对象的地方</strong>将会是一种极为负重的操作，<strong>而且这种对象移动操作必须全程暂停用户应用程序才能进行</strong>（“<strong style="color:red">Stop The World</strong>”）。</li>
<li>但如果完全不考虑移动和整理存活对象，<strong>弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配策略来解决</strong>。</li>
</ul>
<p><strong>移动则内存回收时会更复杂，不移动则内存分配时会更复杂</strong>。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是<strong style="color:red">从总的来说，移动对象会更划算</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块</strong>。一般将 java 堆分为新生代和老年代，<strong style="color:red">这样就可以根据各个年代的特点选择合适的垃圾收集算法</strong>。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<blockquote>
<p> <strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？根据上面的对分代收集算法的介绍回答。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器。这个收集器是一个<strong>单线程收集器</strong>。它的 <strong>“单线程” 的意义</strong>不仅仅意味着它<strong>只会使用一条垃圾收集线程去完成垃圾收集工作</strong>，<strong style="color:red">而且它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束</strong>。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。如图（来自《深入理解JVM》</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155016436.png" alt="image-20210129155016436"></p>
<p>Serial不是已无用的”鸡肋“，<strong>它是HotSpot运行在客户端模式下的默认<font color="red">新生代</font>收集器</strong>。它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器<strong>没有线程交互的额外开销</strong>，可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
<p>&emsp;&emsp;</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样</strong>。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。（图片来自JavaGuide)</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155850631.png" alt="image-20210129155850631" style="zoom:80%;" />

<p><strong>它是许多运行在 Server 模式下的虚拟机的首要选择</strong>，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。</p>
<p><strong>在谈论垃圾收集器的上下文语境中，并行和并发概念可理解为：</strong> </p>
<ul>
<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，通常默认<strong>此时用户线程仍然处于等待状态</strong>。</li>
<li><strong>并发（Concurrent）</strong>：指<strong>用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行）</strong>，用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器也是<strong>使用复制算法的新生代多线程收集器，看上去几乎和 ParNew 一样</strong>。</p>
<p>其不同点在于：CMS 等垃圾收集器的关注点更多的是用户线程的<strong>停顿时间</strong>，而<strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）</strong>。停顿时间短，可以让用户有更好的体验；高吞吐量则可以充分利用处理器资源，<strong>适合在后台运算而不需要过多交互的任务</strong>。</p>
<p>所谓<strong>吞吐量</strong>就是 <strong>CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值</strong>。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合<strong>自适应调节策略</strong>，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性</strong>。</p>
<p>  &emsp;&emsp;</p>
<p><strong>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old</strong>，如果指定了<code>-XX:+UseParallelGC</code> 参数，则默认指定了</p>
<p><code>-XX:+UseParallelOldGC</code>，可以使用<code>-XX:-UseParallelOldGC</code> 来禁用该功能。</p>
<p>  &emsp;&emsp;</p>
<p>新生代采用复制算法，老年代采用标记-整理算法。（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130154438990.png" alt="image-20210130154438990"></p>
<p>&emsp;&emsp;</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial收集器的老年代版本，使用标记-整理算法，它同样是一个单线程收集器</strong>。该收集器主要也是供客户端模式下的HotSpot使用。如果在<strong>服务端模式下，主要有两大用途</strong>：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<p>&emsp;&emsp;</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法</strong>。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器组合使用。</p>
<p>&emsp;&emsp;</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep，并发标记清除）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用</strong>。CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它<strong style="color:red">第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。（并发收集、低停顿）</p>
<p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<strong>整个过程分为四个步骤</strong>：</p>
<ul>
<li><strong>初始标记</strong>（<strong style="color:red">STW</strong>）： 暂停所有的其他线程，并记录下<strong>直接与 root 相连的对象</strong>，速度很快 ；</li>
<li><strong><font color="red">并发</font>标记</strong>： <strong>GC 和用户线程一起并发运行，从GC Roots的直接关联对象开始遍历整个对象图</strong>。但在这个阶段结束，并不能保证扫描完当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以<strong>这个算法里会跟踪记录这些发生引用更新的地方</strong>。</li>
<li><strong>重新标记</strong>（<strong style="color:red">STW</strong>）： 重新标记阶段就是为了<strong>修正并发标记期间因为用户程序继续运行而导致标记产生变动</strong>的那一部分对象的<strong>标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</strong>。</li>
<li><strong><font color="red">并发</font>清除</strong>： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130162109512.png" alt="image-20210130162109512"></p>
<p>&emsp;&emsp;</p>
<p><strong>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的</strong>。</p>
<p>&emsp;&emsp;</p>
<p>CMS收集器有下面三个明显的缺点：</p>
<ul>
<li><p><strong>对 CPU 资源敏感；</strong> </p>
</li>
<li><p><strong>无法处理浮动垃圾； 且在垃圾收集阶段还需要预留足够内存空间提供给用户线程使用</strong>， 在JDK 5的默认设置下， CMS收集的阈值是68%。JDK 6时，阈值默认提升至92%。但如果预留的内存无法满足程序分配新对象的需要， 就会出现一次“<strong>并发失败</strong>”(Concurrent Mode Failure) ， <strong>这时虚拟机将启动后备预案：冻结用户线程的执行， 临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了</strong>。</p>
<blockquote>
<p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
</blockquote>
</li>
<li><p><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</strong>。它开创了<strong>收集器面向局部收集</strong>的设计思路和<strong>基于Region的内存布局</strong>形式。</p>
<blockquote>
<p>JDK9发布时，G1取代Parallel Scavenge+Parallel Old组合，是服务端模式下的默认收集器，而CMS被声明为不被推荐。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>基于Region的内存布局</strong>：</p>
<p>在G1收集器出现之前的所有其他收集器， 包括CMS在内， 垃圾收集的目标范围要么是整个新生代(MinorGC) 、整个老年代(Major GC) 、或整个Java堆(Full GC) 。<strong>而G1可以面向堆内存任何部分来组成回收集(Collection Set， 一般简称CSet) 进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大</strong>， 这就是G1收集器的Mixed GC模式。</p>
<p>G1仍是遵循分代收集理论，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分， <strong>而是把连续的Java堆划分为多个大小相等的独立区域(Region) ， 每一个Region都可以根据需要， 扮演新生代的Eden空间、Survivor空间，或者老年代空间</strong>。</p>
<blockquote>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围为1MB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中， </p>
</blockquote>
<p>&emsp;&emsp;</p>
<p>总结G1的一些特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的</strong>。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，停顿时间模型即<strong>支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>G1 收集器的运作大致分为以下几个步骤（具体P101）：</p>
<ul>
<li><strong>初始标记</strong> （<strong style="color:red">短暂STW</strong>）</li>
<li><strong>并发标记</strong> </li>
<li><strong>最终标记</strong> （<strong style="color:red">短暂STW</strong>）</li>
<li><strong>筛选回收</strong> （<strong style="color:red">STW</strong>）</li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（这也就是它的名字 Garbage-First 的由来）</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p>&emsp;&emsp;</p>
<h3 id="Shenandoah收集器-to-be…"><a href="#Shenandoah收集器-to-be…" class="headerlink" title="Shenandoah收集器(to be…)"></a>Shenandoah收集器(to be…)</h3><p>&emsp;&emsp;</p>
<h3 id="ZGC收集器-to-be…"><a href="#ZGC收集器-to-be…" class="headerlink" title="ZGC收集器(to be…)"></a>ZGC收集器(to be…)</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a> </p>
<p>&emsp;&emsp;</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide-Note</a> </p>
<p>《深入理解JVM》第3版</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">类加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-17 17:57:24" itemprop="dateCreated datePublished" datetime="2021-02-17T17:57:24+08:00">2021-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:51:57" itemprop="dateModified" datetime="2021-03-20T20:51:57+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><strong>类的生命周期</strong>：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210123141452535.png" alt="image-20210123141452535"></p>
<p>类的加载、连接和初始化都是在<strong><font color="red">程序运行期间</font></strong>完成的。这为Java程序提供更大的灵活性。</p>
<p>&emsp;&emsp;</p>
<p>以下<strong>几种情况</strong>，生命周期将结束：</p>
<ul>
<li>执行了<code>System.exit()</code>或<code>Runtime.getRuntime().exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
<li>JVM进程被终止。</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Class文件需要加载到虚拟机中之后才能运行和使用，当程序<strong>主动使用</strong>某个类时，若该类未被加载到内存中（<strong>即首次主动使用</strong>），则系统<strong>通过加载、连接、初始化3个步骤来对该类进行初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p>类加载过程图示：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210118171003597.png" alt="image-20210118171003597" style="zoom:80%;" />

<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载指<strong>将类的class文件读入内存</strong>，将其<strong>放在运行时数据区的方法区内</strong>，并<strong>为之创建一个<code>java.lang.Class</code>对象</strong>，<strong>用来封装类在方法区内的数据结构，并提供了方法区内的数据结构的接口</strong>。（JVM规范并未说明Cass对象位于哪里， HotSpot虚拟机将其放在了方法区中）</p>
<p>加载阶段主要完成下面3件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口</strong></li>
</ol>
<p>加载class文件的方式：</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载cass文件</li>
<li>从zjp，jar等归档文件中加载class文件</li>
<li>将Java源文件<strong>动态编译</strong>为class文件（如动态代理）</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><strong>连接阶段负责把类的二进制数据合并到JRE中</strong>。</p>
<ul>
<li><p>验证：检验被加载的类是否有正确的内部结构并和其他类协调一致。</p>
<ul>
<li><p><strong>Class文件不一定由Java文件编译而来，需要对其进行验证，防止加载错误或恶意的字节码流。</strong> </p>
</li>
<li><p>类的验证的部分内容：类文件的结构检查；语义检查；字节码验证；二进制兼容性的验证等。</p>
</li>
<li><p>图片来自JavaGuide：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210227110905036.png" alt="image-20210227110905036"></p>
</li>
</ul>
</li>
<li><p><strong>准备</strong>：为<strong>类的类变量</strong>分配内存，<strong>并设置默认初始值</strong>。<strong><font color="red">通常情况下，不管有无为静态变量指定初始值，在准备阶段都会先将其初始化为零值</font></strong>。而若是类字段的字段属性表中存在ConstantValue属性，则会初始化为该属性指定的初始值，如使用了final static的情况。</p>
</li>
<li><p><strong>解析</strong>：将类的二进制数据中的<strong>符号引用替换为直接引用</strong>。</p>
<ul>
<li><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符</strong>7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是<strong>直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong>。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。(<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">JavaGuide-类的加载过程</a> )</p>
</li>
<li><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，它们必须按顺序的开始（<strong><font color="red">注意开始的意思是，这些阶段通常都是互相交叉的混合进行，会在一个阶段执行的过程中调用、激活另一个阶段</font></strong>），而解析阶段不一定，<strong><font color="red">它可以在初始化阶段之后再开始</font></strong>。</p>
</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段，虚拟机对类进行初始化，<strong>主要是对类变量进行初始化（赋指定的值）</strong>。JVM会<strong>按顺序</strong>执行类文件中的初始化语句（static）。</p>
<p>初始化一个类包含以下步骤：</p>
<ul>
<li>若该类还没被加载和连接，则对该类进行加载和连接。</li>
<li><strong>若该类的直接父类没有被初始化，对该父类执行初始化</strong>。</li>
<li>若类中有初始化语句，则依次执行这些语句。</li>
</ul>
<p><strong>执行第2个步骤时，对父类的初始化步骤同样遵循这3个步骤</strong>。若父类有直接父类，则进行同样操作，以此类推。<strong>所以JVM最先初始化的总是<code>java.lang.Object</code>类</strong>。</p>
<p><strong>只有<font color="red">主动使用类时</font>才会对类执行初始化操作</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><p>当 Mysample类被加载、连接和初始化后，它的生命周期就开始了。<strong>当代表MySample类的Class对象不再被引用，即不可触及时该Class对象就会被JVM垃圾回收机制回收，结束生命周期</strong>， Mysample类在方法区内的数据也会被卸载，从而结束 Mysample类的生命周期。</p>
<p><strong><font color="red">类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</font></strong>。</p>
<blockquote>
<ul>
<li>每一个类加载器包含被它所加载的Class对象的引用。</li>
<li>程序中的每一个对象包含一个其所属类对应的Class对象的引用。（<code>obj.class</code>）</li>
</ul>
<p>这两种引用不存在时类才会被卸载。即不存在指向相关类加载器的引用，和不存在Class对应的对象的情况。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载</strong>。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。<strong>而由用户自定义的类加载器所加载的类是存在被卸载的可能的</strong>。</p>
<p>&emsp;&emsp;</p>
<p>验证示例：</p>
<p>使用<code>类加载器</code>中的MyClassLoader，编写测试代码，运行时添加JVM参数<code>-XX:+TraceClassUnloading</code>（跟踪卸载）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;E:\\AAAFrequently-used\\temp\\&quot;</span>;</span><br><span class="line">    MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">    loader.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;classloader.MyTest1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    loader = <span class="keyword">null</span>;</span><br><span class="line">    clazz =<span class="keyword">null</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//没有任何引用指向MyTest1的Class对象，执行垃圾回收，MyTest1的Class对象将被卸载</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把loader、clazz、obj都置为null，调用<code>System.gc()</code>执行垃圾回收，</p>
<p>会导致MyTest1的Class对象被卸载，输出：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Unloading <span class="class"><span class="keyword">class</span> <span class="title">classloader</span>.<span class="title">MyTest1</span> 0<span class="title">x0000000100061028</span>]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="主动使用和被动使用"><a href="#主动使用和被动使用" class="headerlink" title="主动使用和被动使用"></a>主动使用和被动使用</h2><h3 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h3><p><strong>《JVM规范》严格规定<font color="red">有且只有</font>以下6种情况需要立即对类进行初始化</strong>：</p>
<ul>
<li><strong>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时</strong>，对应以下情况：<ul>
<li>创建类的示例。（JVM执行<strong>new指令</strong>）。</li>
<li>访问某个类的静态变量（JVM执行<strong>getstatic指令</strong>），或为其静态变量赋值（jvm执行<strong>putstatic指令</strong>）（静态常量除外）。</li>
<li>调用类的静态方法（jvm执行<strong>invokestatic指令</strong>）。</li>
<li><strong style="color:red">注意</strong>：<strong>访问静态内部类的static遍历，创建静态内部类的实例不会造成外部类的初始化</strong>。这些情况下的<code>new</code>、<code>getstatic</code>等针对的是这个静态内部类，只会触发静态内部类的初始化。</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行<strong>反射调用</strong>时。如<code>Class.forname(&quot;...&quot;)</code>，<code>newInstance()</code>等等。</li>
<li>初始化一个子类时，<strong>若父类未初始化，先触发该父类的初始化</strong>。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (<strong>包含 main 方法的类</strong>)，<strong>虚拟机会先初始化这个类</strong>。</li>
<li>当使用JDK 7新加人的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_get Static、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个<strong>接口</strong>中定义了JDK8新加入的<strong>默认方法</strong>（被default关键字修饰的接口方法）时，<strong>如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p><strong>这六种场景的行为称为对一个类型进行主动引用，其他情况的引用都称为被动引用，不会引起初始化</strong>。</p>
<h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p><strong>除了以上情况，其他情况视为对类的被动使用，不会触发对类的初始化</strong>。一些被动使用的情况：</p>
<ul>
<li><p>通过子类访问父类的静态变量，不会导致子类的初始化。<strong>访问静态变量，只有定义了该变量的类才会被初始化</strong>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">&quot;hello，world&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent1&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str1 = <span class="string">&quot;shit&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Child的static块没有执行</span></span><br><span class="line">        <span class="comment">//访问静态字段，只有定义了该字段的类才会吧被初始化</span></span><br><span class="line">        <span class="comment">// System.out.println(Child.str);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Parent1和Child1的static都执行了</span></span><br><span class="line">        <span class="comment">//访问一个类的静态变量属于主动使用该类，所以初始化了Child</span></span><br><span class="line">        <span class="comment">//初始化一个类的子类时相当于主动访问了其所有父类，所以Parent1被初始化（一个类初始化时，要求其所有父类都要初始化完成）</span></span><br><span class="line">        System.out.println(Child.str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但此时Child可能会被加载</strong>。在运行程序时添加jvm参数<code>-XX:+TraceClassLoading</code>可查看类加载信息。其中可看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Loaded classloader.Child from file:/E:.....]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>创建数组实例时</strong>不会造成数组元素类型的初始化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent3[] parent3s = <span class="keyword">new</span> Parent3[<span class="number">3</span>];</span><br><span class="line">        System.out.println(parent3s.getClass());</span><br><span class="line">        Parent3[][] parent3s1 = <span class="keyword">new</span> Parent3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        System.out.println(parent3s1.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(parent3s.getClass().getSuperclass());</span><br><span class="line">        System.out.println(parent3s1.getClass().getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent3</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent3.static initializer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> [<span class="title">Lclassloader</span>.<span class="title">Parent3</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">Lclassloader</span>.<span class="title">Parent3</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，数组的类型并不是Parent3。</p>
<p>对于数组实例来说，<strong><font color="red">其类型是由JVM在运行期动态生成的</font>，表示为<code>[L + 数组元素全限定名 + ;</code>，二维数组则是<code>[[...</code>，且其父类就是<code>java.lang.Object</code>类。即并没有访问数组元素对应的类，因此不会造成其初始化</strong>。</p>
</li>
<li><p>调用ClassLoader的<code>loadClass()</code>方法。</p>
</li>
</ul>
<p>还有一种final static的情况，如下。</p>
<h3 id="关于final-static"><a href="#关于final-static" class="headerlink" title="关于final static"></a>关于final static</h3><p>对于一个<strong>final修饰的静态变量</strong>，<strong><font color="red">若该变量的值在编译时就可以确定</font>，那么该变量相当于“宏变量”。Java编译器会在编译时直接把这个类变量出现的地方替换为它的值。该常量在编译阶段会存入到<font color="red">调用这个常量的方法所在的类的常量池中</font>，本质上，调用类并没有直接引用到定义常量的类，而是在调用常量池中的常量，因此并不会触发定义常量的类的初始化</strong>，且在把常量放入常量池之后，访问常量的类与定义该常量的类已经没有关系，此时将常量所在类的class文件删除仍然能运行。</p>
<p>&emsp;&emsp;</p>
<p>示例：（MyTest2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(FinalStatic.a);<span class="comment">//不会导致类的初始化，static块不执行</span></span><br><span class="line">        System.out.println(FinalStatic.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//。。。。。。</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//ojbk</span></span><br><span class="line"><span class="comment">//FinalStatic&#x27;s static block</span></span><br><span class="line"><span class="comment">//obbk</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalStatic</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String a = <span class="string">&quot;ojbk&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String b = <span class="string">&quot;obbk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalStatic&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从字节码方面看</strong>：</p>
<p>访问非final的静态变量或变量的值编译时不能确定的final static变量，jvm执行的是getstatic指令（在字节码文件中使用getstatic助记符），而对于宏变量则不是。</p>
<p>使用javap命令反编译FinalStaticTest：<code>javap -c FinalStaticTest.class</code> ，在输出的字节码中可看到</p>
<p><code>System.out.println(FinalStatic.b);</code>对应的是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11: getstatic     #6                  // Field classloader/FinalStatic.b:Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<p>而<code>System.out.println(FinalStatic.a);</code>对应的是 <code> 3: ldc           #4                  // String ojbk</code></p>
<p>即String类型的宏变量对应助记符<code>ldc</code>。<strong>即并没用调用getstatic指令，因此不会触发类的初始化</strong>。</p>
<p>&emsp;&emsp;</p>
<p>而若是<strong><font color="red">final static变量的值在编译时不能确定</font></strong>，访问该值依旧会使用getstatic指令，所以会造成类的初始化。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalStatic2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalStatic2&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(FinalStatic2.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap命令可看到：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field classloader/FinalStatic2.str:Ljava/lang/String;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="关于准备、初始化阶段的示例"><a href="#关于准备、初始化阶段的示例" class="headerlink" title="关于准备、初始化阶段的示例"></a>关于准备、初始化阶段的示例</h2><p>定义类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">        System.out.println(count1);</span><br><span class="line">        System.out.println(count2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;count1 = &quot;</span> + singleton.count1);</span><br><span class="line">        System.out.println(<span class="string">&quot;count2 = &quot;</span> + singleton.count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">count1 = <span class="number">2</span></span><br><span class="line">count2 = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>解析：在使用了Singleton的静态方法<code>getInstance()</code>时，引起了对Singleton的初始化，而初始化之前需要进行加载和连接，其中，<strong><font color="red">在连接阶段的准备阶段，为count1和count2分配了内存，并赋默认值（0）</font></strong>，在<strong>随后的初始化阶段</strong>，<strong>按顺序执行初始化语句，</strong>count被赋值为1，随后执行<code>new Singleton()</code>，将count1、2++，此时的值为2、1，<strong>最后执行<code>count2 = 0</code>，所以最后两个变量的值是2，0</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="关于接口的初始化"><a href="#关于接口的初始化" class="headerlink" title="关于接口的初始化"></a>关于接口的初始化</h2><p><strong>类的初始化规则不全部适用于接口</strong>，对于接口：</p>
<ul>
<li><strong>当一个接口在初始化时，不会触发其父接口的初始化</strong>，只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会执行父接口的初始化。<strong>即使调用实现类的实现方法也不会触发接口的初始化</strong>。</li>
<li><strong><font color="red">若是一个接口包含default方法，则当其实现类被初始化时，会先初始化接口</font></strong>。（若还没初始化）</li>
<li><strong>在初始化一个类时并不会初始化该类的实现接口（<font color="red">除非该接口包含default方法</font>）</strong>。</li>
<li><strong>接口中的成员变量默认被<code>public static final</code>修饰，所以对于接口变量同样适用上述宏变量的情况</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>示例：（若是接口被初始化，则接口中的new Thread()会执行，输出语句）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IParent</span></span>&#123;</span><br><span class="line">    String a = UUID.randomUUID().toString();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IParent.instance initializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IChild</span> <span class="keyword">extends</span> <span class="title">IParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">    String str = UUID.randomUUID().toString();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IChild.instance initializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imp</span> <span class="keyword">implements</span> <span class="title">IParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Imp.static initializer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.访问宏变量，没有引起两个接口的初始化，output：</span></span><br><span class="line">        <span class="comment">//6</span></span><br><span class="line">        <span class="comment">// System.out.println(IChild.b);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.IChild被初始化，但其父接口并没有被初始化，output：</span></span><br><span class="line">        <span class="comment">//IChild.instance initializer</span></span><br><span class="line">		<span class="comment">//caac858a-e095-4152-abf4-b75f41a24873</span></span><br><span class="line">        <span class="comment">// System.out.println(IChild.str);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.类的初始化并不会触发其实现接口的初始化，output：</span></span><br><span class="line">        <span class="comment">//Imp.static initializer</span></span><br><span class="line">		<span class="comment">//6</span></span><br><span class="line">        System.out.println(Imp.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.bilibili.com/video/BV187411B7iv" target="_blank"> 深入理解JVM虚拟机视频</a> </p>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">Guide-类的加载过程</a> </p>
<p><a href="https://gu_chun_bo.gitee.io/java-construct/#/jvm%E5%AD%A6%E4%B9%A0/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">jvm-类加载过程</a> </p>
<p>《疯狂Java讲义》</p>
<p>《深入理解JVM》</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/Java/JVM/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/Java/JVM/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" class="post-title-link" itemprop="url">Java内存区域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-17 17:57:24" itemprop="dateCreated datePublished" datetime="2021-02-17T17:57:24+08:00">2021-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:53:19" itemprop="dateModified" datetime="2021-03-20T20:53:19+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相比于C/C++，Java虚拟机拥有自动内存管理机制，不需要为每一个new操作配对对应的delete/free代码，不容易出现内存泄漏和内存溢出问题。而正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>
<p>&emsp;&emsp;</p>
<h2 id="运行时数据区域划分"><a href="#运行时数据区域划分" class="headerlink" title="运行时数据区域划分"></a>运行时数据区域划分</h2><p>Java 虚拟机<strong>在执行 Java 程序的过程中</strong>会把它<strong>管理的内存划分成若干个不同的数据区域</strong>。<strong>对于jdk1.8和之前的版本，内存的划分有一些不同</strong>，如下（图片来自JavaGuide）：</p>
<p>jdk1.8之前：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="JVM运行时数据区域"></p>
<p>jdk1.8：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/jdkJava%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" alt="jdkJava运行时数据区域JDK1.8"></p>
<p>&emsp;&emsp;</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。其作用是：</p>
<ul>
<li><strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>。<strong>分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</strong>。</li>
<li><strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了（<strong>上下文切换</strong>）。</li>
</ul>
<p>程序计数器是一块“<strong>线程私有</strong>”的内存区域：</p>
<p><strong>为什么程序计数器是线程私有</strong>：</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p>
<p>&emsp;&emsp;</p>
<p><strong>若线程正在执行一个Java方法，则计数器记录的是正在执行的方法对应字节码指令的地址</strong>。而若是在<strong>执行native方法，则计数器为空</strong>（Undefined）。**程序计数器不会抛出<code>OutOfMemoryError错误</code>**（《JVM规范》没有规定这种情况）</p>
<p>&emsp;&emsp;</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型：<font color="red">每个Java方法被执行的时候， Java虚拟机都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态连接、方法出口等信息</font>。每一个方法被调用直至执行完毕的过程，就<font color="red">对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</font></strong>。</p>
<p>递归调用时，每一次递归都在栈顶创建一个栈帧。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<p>&emsp;&emsp;</p>
<p>Java内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈通常指这里的虚拟机栈，或者<strong>更多情况下只是指虚拟机栈中局部变量表部分</strong>。 </p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p>&emsp;&emsp;</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈所发挥的作用相似，区别是： <strong><font color="red">虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中本地方法栈和 Java 虚拟机栈合二为一</font></strong>。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，<strong>也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong><font color="red">此内存区域的唯一目的就是存放对象实例</font><strong>，</strong>几乎所有的对象实例以及数组都在这里分配内存</strong>。</p>
<blockquote>
<p>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆</strong>（Garbage Collected Heap）</p>
<p>在垃圾回收机制中，有时会对堆进行划分，如“新生代”，“老年代”等，<strong>但这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已， 而非某个Java虚拟机具体实现的固有内存布局， 更不是《Java虚拟机规范》里对Java堆的进一步细致划分</strong>。</p>
<p>根据JVM规范，<strong>Java堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的</strong>。Java堆可以被实现为固定大小，也可实现为可扩展，当前主流JVM都是可扩展的（参数<code>-Xmx、-Xms</code>），<strong>若堆内存中没有空间可分配且不可扩展，则抛出OOM异常</strong>。</p>
<p>（来自JavaGuide）</p>
<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" alt="JVM堆内存结构-JDK7"></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" alt="JVM堆内存结构-JDK8"></p>
<p>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</p>
<p>&emsp;&emsp;</p>
<blockquote>
<p>to be continue….   <a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_24-%e5%a0%86">https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_24-%e5%a0%86</a></p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与 Java 堆一样，是<strong>各个线程共享的内存区域、可以不连续的内存和大小可扩展</strong>，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>&emsp;&emsp;</p>
<h3 id="方法区与永久代的关系"><a href="#方法区与永久代的关系" class="headerlink" title="方法区与永久代的关系"></a>方法区与永久代的关系</h3><p>JDK1.8以前，方法区经常被称为永久代，JVM规范只是定义了方法区这个概念和它的作用，并没有定义永久代，永久代是Hotsp对方法区的一个具体实现，但这种实现方式Java应用更容易遇到内存溢出问题。从JDK1.6开始HotSpot逐渐放弃永久代，<strong><font color="red">到JDK1.8已完全放弃永久代的概念，改用在本地内存中实现元空间（Meta-space）（<span style="font-size:25px">元空间也是方法区的一种实现</span>）</font></strong>。</p>
<p>永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而<strong>元空间使用的是直接内存，默认情况下其上限是系统的物理内存大小（unlimited），内存溢出几率很小</strong>。可以通过<code>MaxMetaspaceSize</code>参数指定元空间大小。</p>
<blockquote>
<p>元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code> </p>
</blockquote>
<p>&emsp;&emsp;</p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>JDK1.8之前通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>

<p>JDK 1.8 之后</p>
<p>下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<p><code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<p>&emsp;&emsp;</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p><strong>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量和符号引用</strong>。运行时常量池是方法区的一部分，受到方法区内存的限制，<strong>当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误</strong>。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>， Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置人Class文件中常量池的内容才能进入方法区运行时常量池，<strong>运行期间也可以将新的常量放人池中</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是会受到本机总内存大小以及处理器寻址空间的限制。</p>
<p>&emsp;&emsp;</p>
<h1 id="HotSpot虚拟机中的对象"><a href="#HotSpot虚拟机中的对象" class="headerlink" title="HotSpot虚拟机中的对象"></a>HotSpot虚拟机中的对象</h1><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p>创建对象在Java代码中通常只是一个new关键字，而在虚拟机中的过程如下：</p>
<h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>&emsp;&emsp;</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<strong>对象所需的内存大小在类加载完成后便可确定</strong>，为对象分配空间的任务等同于<strong>把一块确定大小的内存从 Java 堆中划分出来</strong>。</p>
<p>划分堆内存的两种方式：</p>
<ul>
<li><strong>指针碰撞（Bump The Pointer）</strong>。假设Java堆中内存是绝对规整的，所有<strong>被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离， 这种分配方式即为“指针碰撞”。（GC收集器：Serial、ParNew）</li>
<li><strong>空闲列表（Free List）</strong>。如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，虚拟机就必须<strong>维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</strong>，这种分配方式称为“空闲列表” 。（GC收集器：CMS）</li>
</ul>
<p><strong>选择哪种分配方式由 Java 堆是否规整决定，<font color="red">而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</font>（或者说，Java 堆是否规整取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”））</strong>。</p>
<p>&emsp;&emsp;</p>
<p><strong><font color="red">线程安全问题</font></strong>：</p>
<p><strong>分配内存的操作在并发环境下并不是线程安全的</strong>，在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的。通常虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> <strong>为每一个线程预先在Java堆中分配一小块内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB）</strong>。哪个线程要分配内存，就在其对应TLAB中分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li>
</ul>
<blockquote>
<p>虚拟机是否采用TLAB，可通过参数<code>-XX:+/-UseTLAB</code>设定。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p><strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值</strong>（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<blockquote>
<p>若使用了TLAB，则可以提前至TLAB分配时顺便进行。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上哈希码会延迟到调用<code>Object.hashCode()</code>方法时才调用）、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>&emsp;&emsp;</p>
<h3 id="执行init方法（构造函数）"><a href="#执行init方法（构造函数）" class="headerlink" title="执行init方法（构造函数）"></a>执行init方法（构造函数）</h3><p>在上面工作都完成之后，<strong>从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零</strong>。一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<blockquote>
<p><strong>是否接着执行init方法，由字节码流中new指令后面是否跟随invokespecial指令所决定</strong>， Java编译器会在遇到new关键字的地方同时生成这两条字节码指令， 但如果直接通过其他方式产生的则不一定如此。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="对象在堆中的内存布局"><a href="#对象在堆中的内存布局" class="headerlink" title="对象在堆中的内存布局"></a>对象在堆中的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<ul>
<li><p><strong>HotSpot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
</li>
<li><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。<strong>无论是从父类继承的还是在子类中定义的字段都必须记录在这部分</strong>。</p>
</li>
<li><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位符作用。</strong> HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 <strong>8 字节的整数倍</strong>，换句话说就是对<strong>象的大小必须是 8 字节的整数倍</strong>。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p>&emsp;&emsp;</p>
</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对象，<strong>Java程序通过栈上的 reference 数据来操作堆上的具体对象</strong>。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ul>
<li><p><strong>句柄：</strong> 如果使用句柄的话， Java 堆中将会<strong>划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>。如图：（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210128110202532.png" alt="image-20210128110202532"></p>
</li>
<li><p><strong>直接指针</strong>（HotSpot主要使用这种方式，也有例外情况）： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。<strong>即reference直接指向堆中对象所在内存</strong>。如图：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210128110402759.png" alt="image-20210128110402759"></p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p>这两种方式的优势：</p>
<ul>
<li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，<strong>在对象被移动时（如垃圾收集时对象经常移动）只会改变句柄中的实例数据指针，而 reference 本身不需要修改</strong>。</li>
<li>使用直接指针访问方式最大的好处就是速度快，它<strong>节省了一次指针定位的时间开销</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<h1 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h1><p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%e5%9b%9b-%e9%87%8d%e7%82%b9%e8%a1%a5%e5%85%85%e5%86%85%e5%ae%b9">补充内容</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/17/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">类加载器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-17 17:57:24" itemprop="dateCreated datePublished" datetime="2021-02-17T17:57:24+08:00">2021-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:52:30" itemprop="dateModified" datetime="2021-03-20T20:52:30+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>类的 加载阶段 由类加载器完成</strong>。Java支持以下4种类型的类加载器：</p>
<p>前3种是Java虚拟机内置的类加载器，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ul>
<li><p><strong>启动（根）类加载器</strong>（<strong>BootstrapClassLoader</strong>）：最顶层的加载类，没有继承<code>java.ang.ClassLoader</code>类。<strong>由C++实现</strong>，主要负责加载Java核心类库，加载<code>%JAVA_HOME%/lib</code>目录下的**<code>rt.jar</code>**、<code>resources.jar、charsets.jar和class</code>等（是按文件名识别的）。或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类（系统属性<code>sun.boot.class.path</code>）。</p>
</li>
<li><p><strong>扩展类加载器</strong>（<strong>ExtensionClassLoader</strong>）：它的<strong>父加载器为根类加载器</strong>。它从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或者从JDK的安装目录的 <code>jre\lib\ext</code>子目录下加载jar和class文件。<strong>这个文件夹可以用于放置具有通用性的类库</strong>，以扩展JavaE功能。</p>
</li>
<li><p><strong>应用（系统）类加载器</strong>（<strong>System/AppClassLoader</strong>）：它的<strong>父加载器为扩展类加载器</strong>。它<strong>从环境变量classpath或者系统属性<code>java.class.path</code>所指定的目录中加载类</strong>（jdk默认的<code>java.class.path</code>是<code>.</code>，即当前目录，在idea中运行时会为该属性添加其他路径）。AppClassLoader是<strong>用户自定义的类加载器的默认父加载器</strong>。</p>
</li>
<li><p>用户自定义类加载器。通过创建<code>java.lang.ClassLoader</code>的子类实现，用户可定制类的加载方式。</p>
</li>
</ul>
<p>4种类加载器的<strong>层次关系</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210121142323383.png" alt="image-20210121142323383" style="zoom:80%;" />

<p>&emsp;&emsp;</p>
<p>一般认为上一层加载器是下一层加载器的父加载器，除了BootstrapClassLoader之外，所有的加载器都是有父加载器的。</p>
<p><strong>双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的</strong>。源码体现：在ClassLoader中关于父加载器的定义：<code>private final ClassLoader parent;</code> </p>
<p>&emsp;&emsp;</p>
<p><strong>Ext loader、App loader以及<code>java.lang.ClassLoader</code>是由启动类加载器加载的</strong>。</p>
<p>类加载器并<strong>不需要等到某个类被“首次主动使用”时再加载它</strong>，JVM规范允许类加载器<strong>在预料某个类将要被使用时就预先加载它</strong>，如果在预先加载的过程中遇到了. class文件缺失或存在错误，类加载器<strong>必须在程序首次主动使用该类时才报告错误</strong>（Linkage Error错误）<strong>如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</strong>。</p>
<p>&emsp;&emsp;</p>
<blockquote>
<p>查看3个JVM类加载器中3个属性包含的路径：执行，可以看到java.class.path的输出中包含当前项目的classes路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span></span><br><span class="line"></span><br><span class="line">    String property = System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line">    String property1 = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">    String property2 = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">    print(property);</span><br><span class="line">    print(property1);</span><br><span class="line">    print(property2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String property)</span></span>&#123;</span><br><span class="line">    String[] properties = property.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : properties) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<p>可通过修改系统属性java.system.class.loader来将自定义类加载器作为app loader。</p>
</blockquote>
<p>相关demo：（JVMDemo/classloader/MyTest16   JVMDemo\classloader\MyTest13）</p>
<p>&emsp;&emsp;</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。当一个类不能通过JVM内置3个类加载器加载时，比如需要通过网络加载，则需要继承ClassLoader创建子类，自定义类加载器。</p>
<p>获取ClassLoader的几种方式：</p>
<ul>
<li>获得当前类的Clas Loader：<code>clazz.getClassloader</code> </li>
<li>获得当前线程上下文ClassLoader：<code>Thread. currentThread().getContextClassLoader()</code> </li>
<li>获得系统ClassLoader：<code>Classloader.getSystemClassLoader()</code>（获取AppClassLoader）</li>
<li><strong>获得调用者的ClassLoader</strong>：<code>DriverManager.getCallerClassLoader()</code> </li>
</ul>
<blockquote>
<p>调用ClassLoader的<code>loadClass()</code>方法时，只会对类进行加载和连接，不会执行初始化操作。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>ClassLoader的部分javadoc及其翻译★</strong>：一些点</p>
<ul>
<li><strong>数组的Class对象不是由类加载器创建，而是在JVM运行时自动创建的</strong>。</li>
<li><strong>调用数组的Class对象的getClassLoader()方法返回的类加载器，与其数组元素返回的一样。而如果其数组元素是原生类型，则该数组没有类加载器</strong>。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">class</span> loader is an <span class="keyword">object</span> that is responsible <span class="keyword">for</span> loading classes. The <span class="keyword">class</span> ClassLoader is an </span><br><span class="line"></span><br><span class="line">abstract <span class="keyword">class</span>. Given the binary name <span class="keyword">of</span> a <span class="keyword">class</span>， a <span class="keyword">class</span> loader should attempt <span class="keyword">to</span> locate <span class="keyword">or</span> generate data that constitutes a definition <span class="keyword">for</span> the <span class="keyword">class</span>. </span><br><span class="line">A typical strategy is <span class="keyword">to</span> transform the name into a file name <span class="keyword">and</span> <span class="keyword">then</span> read a <span class="string">&quot;class file&quot;</span> <span class="keyword">of</span> that name from a file system.</span><br><span class="line">一种典型的策略是，将给定的name转换为文件名，并从文件系统中读取对应的<span class="keyword">class</span>文件。</span><br><span class="line">Every Class <span class="keyword">object</span> contains a reference <span class="keyword">to</span> the ClassLoader that defined it.</span><br><span class="line">每一个Class对象包含一个定义了该Class对象的ClassLoader的引用</span><br><span class="line"></span><br><span class="line">Class objects <span class="keyword">for</span> <span class="built_in">array</span> classes are not created by <span class="keyword">class</span> loaders， but are created automatically <span class="keyword">as</span> required by the Java runtime. </span><br><span class="line">数组的Class对象不是由类加载器创建，而是在JVM运行时自动创建的。</span><br><span class="line">The <span class="keyword">class</span> loader <span class="keyword">for</span> an <span class="built_in">array</span> <span class="keyword">class</span>， <span class="keyword">as</span> returned by <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>get<span class="constructor">ClassLoader()</span> is the same <span class="keyword">as</span> the <span class="keyword">class</span> loader <span class="keyword">for</span> its element <span class="keyword">type</span>; <span class="keyword">if</span> the element <span class="keyword">type</span> is a primitive <span class="keyword">type</span>， <span class="keyword">then</span> the <span class="built_in">array</span> <span class="keyword">class</span> has no <span class="keyword">class</span> loader.</span><br><span class="line">调用数组的Class对象的get<span class="constructor">ClassLoader()</span>方法返回的类加载器，与其数组元素返回的一样。而如果其数组元素是原生类型，则该数组没有类加载器。</span><br><span class="line"></span><br><span class="line">Applications implement subclasses <span class="keyword">of</span> ClassLoader <span class="keyword">in</span> order <span class="keyword">to</span> extend the manner <span class="keyword">in</span> which the Java <span class="keyword">virtual</span> machine dynamically loads classes.</span><br><span class="line">应用程序实现类加载器的子类，来扩展JVM动态加载类的方式。</span><br><span class="line"></span><br><span class="line">Class loaders may typically be used by security managers <span class="keyword">to</span> indicate security domains.</span><br><span class="line"></span><br><span class="line">The ClassLoader <span class="keyword">class</span> uses a delegation model <span class="keyword">to</span> search <span class="keyword">for</span> classes <span class="keyword">and</span> resources. </span><br><span class="line">ClassLoader类使用委托机制来寻找类和资源</span><br><span class="line"></span><br><span class="line">Each instance <span class="keyword">of</span> ClassLoader has an associated parent <span class="keyword">class</span> loader. When requested <span class="keyword">to</span> find a <span class="keyword">class</span> <span class="keyword">or</span> resource， a ClassLoader instance will delegate the search <span class="keyword">for</span> the <span class="keyword">class</span> <span class="keyword">or</span> resource <span class="keyword">to</span> its parent <span class="keyword">class</span> loader before attempting <span class="keyword">to</span> find the <span class="keyword">class</span> <span class="keyword">or</span> resource itself. </span><br><span class="line">每一个ClassLoader的实例都有一个与之关联的父ClassLoader。当被要求寻找一个类或资源时，ClassLoader实例在尝试自己寻找之前，会先委托给父ClassLoader去执行。</span><br><span class="line"></span><br><span class="line">The <span class="keyword">virtual</span> machine&#x27;s built-<span class="keyword">in</span> <span class="keyword">class</span> loader， called the <span class="string">&quot;bootstrap class loader&quot;</span>， does not itself have a parent but may serve <span class="keyword">as</span> the parent <span class="keyword">of</span> a ClassLoader instance.</span><br><span class="line">JVM有一个内建ClassLoader叫做bootstrap <span class="keyword">class</span> loader，它本身没有父类，但可以作为类加载器实例的父类</span><br><span class="line"></span><br><span class="line">Class loaders that support concurrent loading <span class="keyword">of</span> classes are known <span class="keyword">as</span> parallel capable <span class="keyword">class</span> loaders <span class="keyword">and</span> are required <span class="keyword">to</span> register themselves at their <span class="keyword">class</span> initialization time by invoking the <span class="module-access"><span class="module"><span class="identifier">ClassLoader</span>.</span></span>registerAsParallelCapable <span class="keyword">method</span>. </span><br><span class="line">Note that the ClassLoader <span class="keyword">class</span> is registered <span class="keyword">as</span> parallel capable by default.</span><br><span class="line">However， its subclasses still need <span class="keyword">to</span> register themselves <span class="keyword">if</span> they are parallel capable. </span><br><span class="line">支持并发加载的ClassLoader被称为可并行的类加载器，</span><br><span class="line">且它们被要求在初始化时通过调用<span class="module-access"><span class="module"><span class="identifier">ClassLoader</span>.</span></span>registerAsParallelCapable方法进行注册。</span><br><span class="line">注意ClassLoader类默认会被注册。然而它的子类依然需要自行进行注册（如果需要并行能力）</span><br><span class="line"></span><br><span class="line">In environments <span class="keyword">in</span> which the delegation model is not strictly hierarchical， <span class="keyword">class</span> loaders need <span class="keyword">to</span> be parallel capable， otherwise <span class="keyword">class</span> loading can lead <span class="keyword">to</span> deadlocks because the loader lock is held <span class="keyword">for</span> the duration <span class="keyword">of</span> the <span class="keyword">class</span> loading process (see loadClass methods).</span><br><span class="line"></span><br><span class="line">Normally， the Java <span class="keyword">virtual</span> machine loads classes from the local file system <span class="keyword">in</span> a platform-dependent manner. For example， on UNIX systems， the <span class="keyword">virtual</span> machine loads classes from the directory defined by the CLASSPATH environment variable.</span><br><span class="line"></span><br><span class="line">However， some classes may not originate from a file; they may originate from other sources， such <span class="keyword">as</span> the network， <span class="keyword">or</span> they could be constructed by an application.</span><br><span class="line">然而，某些<span class="keyword">class</span>文件不是来源于文件，可能是来自其他来源，如网络、或者被程序创建。</span><br><span class="line">The <span class="keyword">method</span> defineClass converts an <span class="built_in">array</span> <span class="keyword">of</span> <span class="built_in">bytes</span> into an instance <span class="keyword">of</span> <span class="keyword">class</span> Class. Instances <span class="keyword">of</span> this newly defined <span class="keyword">class</span> can be created using <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>newInstance.</span><br><span class="line">defineClass方法可以将一个字节数组转换为一个Class对象，且可以通过<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance()</span>方法来创建这个Class对应的类实例。</span><br><span class="line"></span><br><span class="line">The methods <span class="keyword">and</span> constructors <span class="keyword">of</span> objects created by a <span class="keyword">class</span> loader may reference other classes. To determine the <span class="keyword">class</span>(es) referred <span class="keyword">to</span>， the Java <span class="keyword">virtual</span> machine invokes the loadClass <span class="keyword">method</span> <span class="keyword">of</span> the <span class="keyword">class</span> loader that originally created the <span class="keyword">class</span>.</span><br><span class="line">类加载器创建的对象的方法和构造函数可以引用其他类。要确定引用的类，Java虚拟机调用最初创建类的类装入器的loadClass方法</span><br><span class="line">For example， an application could create a network <span class="keyword">class</span> loader <span class="keyword">to</span> download <span class="keyword">class</span> files from a server. Sample code might look like:</span><br><span class="line">     ClassLoader loader = <span class="keyword">new</span> <span class="constructor">NetworkClassLoader(<span class="params">host</span>， <span class="params">port</span>)</span>;</span><br><span class="line">     Object main = loader.load<span class="constructor">Class(<span class="string">&quot;Main&quot;</span>， <span class="params">true</span>)</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line">          . . .</span><br><span class="line">   </span><br><span class="line">The network <span class="keyword">class</span> loader subclass must define the methods findClass <span class="keyword">and</span> loadClassData <span class="keyword">to</span> load a <span class="keyword">class</span> from the network. Once it has downloaded the <span class="built_in">bytes</span> that make up the <span class="keyword">class</span>， it should use the <span class="keyword">method</span> defineClass <span class="keyword">to</span> create a <span class="keyword">class</span> instance. </span><br><span class="line">网络类加载器的子类必须定义find<span class="constructor">Class()</span>和load<span class="constructor">ClassData()</span>方法（也可其他命名）用于加载来源于网络的类，用于从网络中加载类。一旦它下载了组成类的字节，它就应该使用defineClass方法来创建对应的Class对象。</span><br><span class="line">A sample implementation is:（示例）</span><br><span class="line">       <span class="keyword">class</span> NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">           String host;</span><br><span class="line">           <span class="built_in">int</span> port;</span><br><span class="line">  </span><br><span class="line">           public Class find<span class="constructor">Class(String <span class="params">name</span>)</span> &#123;</span><br><span class="line">               byte<span class="literal">[]</span> b = load<span class="constructor">ClassData(<span class="params">name</span>)</span>;</span><br><span class="line">               return define<span class="constructor">Class(<span class="params">name</span>， <span class="params">b</span>， 0， <span class="params">b</span>.<span class="params">length</span>)</span>;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="keyword">private</span> byte<span class="literal">[]</span> load<span class="constructor">ClassData(String <span class="params">name</span>)</span> &#123;</span><br><span class="line">               <span class="comment">// load the class data from the connection</span></span><br><span class="line">                . . .</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每一个类都有一个对应它的类加载器。系统中的ClassLoder在工作时<strong>默认</strong>使用 <strong>双亲委派机制</strong> ：</p>
<ul>
<li>当一个类加载器收到加载类的请求时，<strong>它不会直接去加载指定的类，而是首先判断当前类是否被加载过</strong>。已经被加载的类会直接返回，<strong>否则才会尝试加载</strong>。</li>
<li><strong><font color="red">加载时，类加载器首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理</font>（若检查到父类加载器为null，则使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器，并让其尝试加载指定类）</strong>。所有的请求最终都传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li><strong>如果父类加载器无法处理，才由自己调用<code>findClass()</code>方法尝试加载类</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p><strong>即自底向上检查是否被加载过，再自顶向下尝试加载</strong>。</p>
<p>（<strong>当ClassLoder的parent为null时，表示其parent为BootstrapClassLoader</strong>）</p>
<p>图片来自Guide哥文档（<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?id=%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e6%80%bb%e7%bb%93">链接</a>）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="classloader_WPS图片"></p>
<blockquote>
<p>加载类的类加载器称为定义类加载器，返回已经被加载的类的类加载器称为初始化类加载器。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong><font color="red">双亲委派机制在ClassLoader的<code>loadClass()</code>方法中体现</font></strong>：（来自Guide哥文档<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?id=%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e6%80%bb%e7%bb%93">链接</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name， <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name， <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><strong>每个Class对象都对应一个加载它的类加载器，每个类加载器都有一个父类加载器（若为null表示父类加载器为BootstrapClassLoader）</strong>。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = MyTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>b6d3586</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>自定义的类由AppClassLoader加载，AppClassLoader的父类加载器是ExtClassLoader，ExtClassLoader的父类加载器是BootstrapClassLoader（表示为null）</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="双亲委托机制的优点"><a href="#双亲委托机制的优点" class="headerlink" title="双亲委托机制的优点"></a>双亲委托机制的优点</h3><ul>
<li><strong>双亲委派机制保证了Java程序的稳定运行，可以避免类的重复加载</strong>（JVM 区分不同类的方式是根据类的全限定名（binary name）和用于加载该类的定义类加载器）。当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。</li>
<li><strong>保证了安全性，使 Java 的核心 API 不被篡改</strong>。因为在该机制下，用户自定义类加载器不能加载应由根类加载器加载的核心类库，防止不可靠或恶意代码代替Java核心类库。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="打破双亲委托机制"><a href="#打破双亲委托机制" class="headerlink" title="打破双亲委托机制"></a>打破双亲委托机制</h3><p>自定义加载器需要继承 <code>ClassLoader</code> 。如果不想打破双亲委派机制，重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，因为默认的loadClass()实现会调用该方法（当父加载器无法加载指定类时）。无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p><strong>如果想打破双亲委派机制则需要重写 <code>loadClass()</code> 方法</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="loadClass-、findClass-、definclass-区别"><a href="#loadClass-、findClass-、definclass-区别" class="headerlink" title="loadClass()、findClass()、definclass()区别"></a>loadClass()、findClass()、definclass()区别</h3><ul>
<li>loadClass() 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。</li>
<li>findClass() 根据名称或位置加载.class字节码文件</li>
<li>definclass() 把字节码转化为Class对象</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="类加载器命名空间"><a href="#类加载器命名空间" class="headerlink" title="类加载器命名空间"></a>类加载器命名空间</h2><ul>
<li><strong>每个类加载器都有自己的命名空间，命名空间由<font color="red">该加载器及所有父加载器所加载的类</font>组成</strong>。</li>
<li><strong>一个类在JVM中的唯一性由这个类本身和它的类加载器决定</strong>。</li>
<li>在同一个命名空间中，不会出现类的全限定名相同的两个类。</li>
<li>在不同的命名空间中，有可能会出现全限定名相同的两个类。</li>
<li><strong>子加载器所加载的类能够访问父加载器所加载的类</strong>。</li>
<li><strong>父加载器所加载的类无法访问到子加载器所加载的类</strong>。</li>
<li>如果两个类加载器之间没有间接或直接的父子关系，则被这两个类加载器所加载的类互不可见。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>若是自定义了多个类加载器，则可能会出现同一个类加载多次的情况，<strong>JVM 是根据类的全限定名（binary name）和用于加载该类的定义类加载器区分不同类的，如果相同全限定名的类是由两个不同的加载器所加载，那么这些类就是不同的，即使class文件的字节码完全一样，并且从相同的位置加载</strong>。（验证示例见JVMDemo/test14）</p>
<p>&emsp;&emsp;</p>
<p><strong>默认情况下，<font color="red">如果一个类由A类加载器加载，则该类的依赖类也由A加载（若被依赖类未被加载）</font></strong>。这时可能会出现以下异常情况：（见<code>JVMDemo\classloader\test12</code>）</p>
<ul>
<li>内外两个类位于不同命名空间的情况，<strong>即被不同的类加载器加载</strong>。</li>
<li><strong>被包含类不能被加载成功的情况</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="自定义类加载器示例"><a href="#自定义类加载器示例" class="headerlink" title="自定义类加载器示例"></a>自定义类加载器示例</h2><p>示例（使用双亲委派机制）：</p>
<p>自定义类加载器：</p>
<ul>
<li>重写ClassLoader的<code>findClass(String name)</code>方法，<strong>在使用该类加载器加载类时，该方法会被<code>loadClass()</code>方法调用</strong>。</li>
<li>当父类加载器无法加载指定类时，会由该类加载器进行加载，此时<code>loadClass()</code>方法会调用<code>findClass(String name)</code>方法，在该方法中又调用<code>loadClassData()</code>方法来从指定路径读取 .class文件，返回对应的字节数组。</li>
<li>再通过<code>defineClass()</code>（<strong>继承自ClassLoader的方法，底层由C++实现</strong>）方法加载类，返回对应的Class对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//默认使用系统类加载器作为双亲委托</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent， String classLoaderName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//自行指定双亲委托</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.classLoaderName + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//★★</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClassLoader.findClass&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name， data， <span class="number">0</span>， data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//★★</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] loadClassData(String name)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;self define loadCLassData&quot;</span>);</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        name = name.replace(<span class="string">&quot;.&quot;</span>， <span class="string">&quot;\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.path + name + <span class="keyword">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span> != (ch=is.read()))&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>测试：（若父类加载器无法加载MyTest1类，则在E:\AAAFrequently-used\temp\路径下读取MyTest1类的 .class 文件并创建Class对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;E:\\AAAFrequently-used\\temp\\&quot;</span>;</span><br><span class="line">    MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">    loader.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;classloader.MyTest1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    System.out.println(<span class="string">&quot;class: &quot;</span> + clazz.hashCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;class loader: &quot;</span> + obj.getClass().getClassLoader());</span><br><span class="line">    System.out.println(<span class="string">&quot;class&#x27; instance: &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;loader2&quot;</span>);<span class="comment">//---1----</span></span><br><span class="line">    loader2.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">&quot;classloader.MyTest1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object obj2 = clazz2.newInstance();</span><br><span class="line">    System.out.println(<span class="string">&quot;class: &quot;</span> + clazz2.hashCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;class loader: &quot;</span> + obj2.getClass().getClassLoader());</span><br><span class="line">    System.out.println(<span class="string">&quot;class&#x27; instance: &quot;</span> + obj2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时loader1、loader2的父类加载器都是系统类加载器，运行结果：</p>
<ul>
<li><p>若是当前项目的classpath路径下有MyTest1的 .class 文件时，<strong>根据双亲委派机制</strong>，MyTest1将由系统类加载器进行加载，因此创建的两个Class实例相同：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">460141958</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@4554617c</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">460141958</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@74a14482</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把classpath下的MyTest1.class移除，放到<code>E:\AAAFrequently-used\temp\classloader</code>路径下，重新运行程序。<strong>因为loader1、loader2的父类加载器都无法加载MyTest1，所以最后会由它们进行加载，此时会加载出两个MyTest1的Class对象</strong>：</p>
<p><strong><font color="red">这两个Class位于不同的命名空间</font></strong>。</p>
<p>输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self define loadCLassData</span><br><span class="line">MyClassLoader.findClass</span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">1956725890</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader1]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@1540e19d</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self define loadCLassData</span><br><span class="line">MyClassLoader.findClass</span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">2133927002</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader2]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@6d6f6e28</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把–1–处代码改为<code>MyClassLoader loader2 = new MyClassLoader(loader， &quot;loader2&quot;);</code>，即loader2的父类加载器是loader1。重新运行程序。<strong>根据双亲委派机制，因为其父类加载器loader1已完成MyTest1的加载，所以loader2不会重新加载类，返回loader1创建的Class对象</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self define loadCLassData</span><br><span class="line">MyClassLoader.findClass</span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">1956725890</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader1]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@1540e19d</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">1956725890</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader1]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@677327b6</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
</li>
</ul>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>线程上下文类加载器（Thread Context ClassLoader，<strong>since jdk1.2</strong>）可用于解决某些双亲委托机制无法适应的情况，主要为了解决SPI（Service Provider Interface，服务提供接口）的问题。</p>
<p>SPI即一组接口或抽象类，没有具体实现。jdk中的一些SPI的具体实现由Java核心类库提供，这些SPI和具体实现都可以被启动类加载器所加载。而对于某些SPI，如jdbc的SPI，其具体实现由第三方提供，<strong>若是遵循双亲委托机制，则它们无法通过启动类加载器来加载，这时可以就可以使用线程上下文类加载器来加载这些具体实现</strong>。Context ClassLoade破坏了双亲委托机制。</p>
<p>即<strong><font color="red">当高层提供了统一的接口让低层实现，同时又需要在高层加载这些具体实现，则需要使用Context ClassLoader来寻找并加载这些类</font></strong>。</p>
<p>Context ClassLoader通过<code>Thread.currentThread().getContextClassLoader()</code>获取，<strong>若无显式指定，则默认为系统类加载器</strong>。</p>
<p>Context ClassLoade的一般使用模式是：获取-》使用-》还原：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	Thread.currentThread().setContextClassLoader(targetTccl);</span><br><span class="line">	myMethod();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//还原</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，在<code>myMethod();</code>中通过<code>Thread.currentThread().getContextClassLoader();</code>获取线程上下文类加载器来加载某些类（服务提供者）。</p>
<p>ServiceLoader类是jdk提供的一个用于加载服务具体实现的类，具体见源码分析笔记。</p>
<p>&emsp;&emsp;</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>深入理解JVM虚拟机视频</p>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">Guide-类的加载过程</a> </p>
<p><a href="https://gu_chun_bo.gitee.io/java-construct/#/jvm%E5%AD%A6%E4%B9%A0/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">jvm-类加载过程</a> </p>
<p>《疯狂Java讲义》</p>
<p>《深入理解JVM》</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6kedGPZP4iTDuK-Wuzym4Q">十个双亲委派问题</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/Java/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/Java/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">深拷贝、浅拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 22:25:18" itemprop="dateCreated datePublished" datetime="2020-12-02T22:25:18+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:46:06" itemprop="dateModified" datetime="2021-03-20T20:46:06+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;  </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>定义两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String majorName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Major major;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p><strong>浅拷贝</strong>即在拷贝对象时，<strong>对于对象中的引用类型成员变量，只复制该成员变量的对象引用</strong>，而<strong>该引用地址指向的实际对象空间其实只有一份</strong>。如图（图片来自参考链接）：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201202195036253.png" alt="image-20201202195036253" style="zoom:67%;" />



<p>深拷贝即对于引用类型字段所指向的对象，也会在内存中也<strong>创建一个副本</strong>。如图（图片来自参考链接）：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201202195739338.png" alt="image-20201202195739338" style="zoom: 67%;" />

<p>&emsp;  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>要拷贝的类实现<code>Cloneable</code>接口，重写Object的<code>clone()</code>方法，<strong>并使用其默认实现来实现浅拷贝</strong>（<strong>Object类的<code>clone()</code>方法的默认实现就是浅拷贝，且该方法是一个<code>native</code>方法</strong>）。</p>
<blockquote>
<p><code>Cloneable</code>接口是一个空接口，与Serializable接口类似，只是一个标记。通过实现该接口，使实现类支持使用Object类的<code>clone()</code>方法，否则会抛出CloneNotSupportedException异常。</p>
</blockquote>
<p>&emsp;  </p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Major major;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Major major = <span class="keyword">new</span> Major(<span class="string">&quot;软件工程&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, major);</span><br><span class="line"></span><br><span class="line">    Student student2 = (Student) student1.clone();</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">    System.out.println(student2);</span><br><span class="line">    System.out.println(<span class="string">&quot;student1==student2 &quot;</span> + (student1==student2));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;两个student的major是否相同：&quot;</span> + (student1.getMajor()==student2.getMajor()));</span><br><span class="line"></span><br><span class="line">    major.setId(<span class="number">666</span>);</span><br><span class="line">    major.setMajorName(<span class="string">&quot;信息安全&quot;</span>);</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">    System.out.println(student2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line"><span class="attribute">student1</span>==student2 <span class="literal">false</span></span><br><span class="line">两个student的major是否相同：<span class="literal">true</span></span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个student不相同，说明拷贝了一个新的对象。</li>
<li>修改major对象后，两个student中的major都改变，说明两个major指向同一对象。</li>
</ul>
<p>&emsp;  </p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝可以有两种实现方式：</p>
<ul>
<li>同样使用<code>Cloneable</code>接口，但与浅拷贝不同，需要对引用对象实现进行深度遍历式拷贝。</li>
<li>使用反序列化实现。</li>
</ul>
<p>&emsp;  </p>
<h4 id="使用Cloneable接口"><a href="#使用Cloneable接口" class="headerlink" title="使用Cloneable接口"></a>使用Cloneable接口</h4><p>Major类也需要实现Cloneable接口。<strong>Major中的成员变量都是值类型，所以使用<code>clone()</code>方法默认实现即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>在<strong>顶层的</strong>调用类中（Student）重写<code>clone</code>方法，来调用引用类型字段的<code>clone()</code>方法实现深度拷贝：</p>
<ul>
<li>先通过浅拷贝拷贝出一个student。</li>
<li>再创建一个major的副本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Student cloneStu = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">if</span>(major!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            cloneStu.major = (Major) major.clone();<span class="comment">//!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneStu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用相同的测试代码，输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line"><span class="attribute">student1</span>==student2 <span class="literal">false</span></span><br><span class="line">两个student的major是否相同：<span class="literal">false</span></span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h4 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h4><p><strong>Major</strong>、Student都实现Serializable接口，在Student中编写<code>clone()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream objectOutputStream  = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">            objectOutputStream.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            ObjectInputStream objectInputStream = </span><br><span class="line">                <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray()));</span><br><span class="line">            <span class="keyword">return</span> (Student2) objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样使用相同的测试代码，输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line"><span class="attribute">student1</span>==student2 <span class="literal">false</span></span><br><span class="line">两个student的major是否相同：<span class="literal">false</span></span><br><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h3 id="深拷贝List集合"><a href="#深拷贝List集合" class="headerlink" title="深拷贝List集合"></a>深拷贝List集合</h3><blockquote>
<p>来自参考链接</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">deepCopy</span><span class="params">(List&lt;T&gt; src)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">    out.writeObject(src);</span><br><span class="line"></span><br><span class="line">    ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray());</span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">    List&lt;T&gt; dest = (List&lt;T&gt;) in.readObject();</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247489983&idx=1&sn=fc1f623d49f3673e9e36510e769143ea&chksm=fddecf7bcaa9466de6e4de09012da3655f5bcb90bcf3359ca43631d5364b078e430bb8c271e6&mpshare=1&scene=1&srcid=120228fwNNHkIf13gg1jHqiu&sharer_sharetime=1606885191820&sharer_shareid=c7195d3c2809169af1ff4a6ce14ea626&key=cb86f5f7c317358fa51edff104c24ff634b46281c76208d61c0da26500b632ec1bc519f53f13e64e10c4c4dbcb00e1897ce2c3b5ff89ad6c9877da0455264e07dd5819acf815823a979bbd11a89688b7a979c0a4987cf0bd183eaa697ee91a97baa6639fad0a40fdffad5e561f56db83c21730ac04f27485a84fb4c4163b5773&ascene=1&uin=MzQwMjIxNDEyNw%3D%3D&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AUxwIEKoH5HA9BYrhguEofc%3D&pass_ticket=jNiOuUtB%2FWAFhQVzmTR2GW6ojOsx%2FZYdzbTSCYuZFBdnXx1pPMpWSkKvQI0C32rs&wx_header=0" target="_blank">程序羊-深拷贝、浅拷贝</a> </p>
<p><a href="https://blog.csdn.net/demonliuhui/article/details/54572908" target="_blank">java List复制：浅拷贝与深拷贝</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/13/%E6%A1%86%E6%9E%B6/Spring%E4%B8%AD%E5%A4%84%E7%90%86json%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/13/%E6%A1%86%E6%9E%B6/Spring%E4%B8%AD%E5%A4%84%E7%90%86json%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">Spring中处理json数据的总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-13 00:45:26" itemprop="dateCreated datePublished" datetime="2020-11-13T00:45:26+08:00">2020-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-03 23:46:33" itemprop="dateModified" datetime="2020-12-03T23:46:33+08:00">2020-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>总结一下Spring中一些解析json数据的技巧。</p>
<h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h2><p><code>@RequestBody</code>注解常用来处理<code>content-type</code>不是默认的<code>application/x-www-form-urlcoded</code>编码的内容，比如<code>application/json</code>或者是<code>application/xml</code>等。<strong>一般情况下来说常用其来处理<code>application/json</code>类型</strong>。</p>
<p><code>@RequestBody</code>的修饰对象的控制器方法形参，一般用于修饰JavaBean形参，其<strong>可以将请求体中的JSON字符串绑定到修饰的bean上</strong>。也可以修饰字符串，会将请求体的参数以<code>key1=value1&amp;key2=value2&amp;...</code>的格式复制给String控制器参数。</p>
<p>&emsp;  </p>
<p><strong>修饰JavaBean时，json字符串要与JavaBean的属性对应</strong>，<strong><font color="red">且可以修饰List集合类型的形参，这时前端要以json数组的形式发送数据，且要指定<code>content-type</code>为<code>application/json</code>类型</font></strong>。</p>
<h3 id="接收json对象字符串示例"><a href="#接收json对象字符串示例" class="headerlink" title="接收json对象字符串示例"></a>接收json对象字符串示例</h3><p>JavaBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line"> 	<span class="comment">//getter、setter、toString</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">	<span class="comment">//getter、setter、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataResolveController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/doJsonObject&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">resolveJsonObject</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span></span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>在前端发送Ajax：</p>
<ul>
<li>**注意发送ajax请求时，contentType要指定为<code>application/json</code>**。</li>
<li>person对象的属性与Person类一一对应，<strong>其中roles的属性值是一个json对象数组</strong>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Test @RequestBody<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;send&quot;</span>&gt;</span>send ajax<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#send&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> person = &#123;</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;name&quot;</span>:<span class="string">&quot;白小纯&quot;</span>, </span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;age&quot;</span>:<span class="string">&quot;20&quot;</span>, </span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;roles&quot;</span>:[</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;医生&quot;</span>&#125;, </span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;2&quot;</span>,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;老师&quot;</span>&#125;</span></span><br><span class="line">                ]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                type: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="javascript">                url: <span class="string">&quot;doJsonObject&quot;</span>,</span></span><br><span class="line"><span class="javascript">                contentType: <span class="string">&quot;application/json; charset=utf-8&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data: <span class="built_in">JSON</span>.stringify(person),</span></span><br><span class="line"><span class="javascript">                dataType: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>点击按钮，后台输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;<span class="attribute">name</span>=<span class="string">&#x27;白小纯&#x27;</span>, <span class="attribute">age</span>=20, roles=[Role&#123;<span class="attribute">id</span>=1, <span class="attribute">roleName</span>=<span class="string">&#x27;医生&#x27;</span>&#125;, Role&#123;<span class="attribute">id</span>=2, <span class="attribute">roleName</span>=<span class="string">&#x27;老师&#x27;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收json数组示例"><a href="#接收json数组示例" class="headerlink" title="接收json数组示例"></a>接收json数组示例</h3><p>控制器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/sendarray&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testReceiveArray</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Integer&gt; array)</span></span>&#123;</span><br><span class="line">    System.out.println(array);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>Ajax代码（jQuery）：</p>
<ul>
<li>这里发送json数组可以直接使用字符串形式，如下。也可以先创建一个变量<code>var array = [1,2,3,5]</code>，再通过<code>JSON.stringify(array)</code>转换为json数据。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#btn1&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//var array = [1,2,3,5];</span></span><br><span class="line">        <span class="comment">//JSON.stringify(array)</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">&quot;sendarray&quot;</span>,</span><br><span class="line">            type: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">            data: <span class="string">&quot;[1,2,3]&quot;</span>,</span><br><span class="line">            dataType: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">            contentType: <span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; </span><br><span class="line">                alert(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>服务端输出：<code>[1, 2, 3]</code>。</p>
<p><strong><font color="red">List的元素也可以是其他的JavaBean</font></strong>。</p>
<p>&emsp;  </p>
<h2 id="使用Jackson处理json"><a href="#使用Jackson处理json" class="headerlink" title="使用Jackson处理json"></a>使用Jackson处理json</h2><h3 id="Jackson简介"><a href="#Jackson简介" class="headerlink" title="Jackson简介"></a>Jackson简介</h3><blockquote>
<p>来自参考连接</p>
</blockquote>
<p>Jackson 是当前用的比较广泛的，用来序列化和反序列化 json 的 Java 的开源框架。Jackson 社区相对比较活跃，更新速度也比较快， 从 Github 中的统计来看，Jackson 是最流行的 json 解析器之一 。 Spring MVC 的默认 json 解析器便是 Jackson。 Jackson 优点很多。 Jackson 所依赖的 jar 包较少 ，简单易用。与其他 Java 的 json 的框架 Gson 等相比， Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。</p>
<p>Jackson 的 1.x 版本的包名是 org.codehaus.jackson ，当升级到 2.x 版本时，包名变为 com.fasterxml.jackson。</p>
<p>Jackson 的核心模块由三部分组成。</p>
<ul>
<li>jackson-core，核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。 Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</li>
<li>jackson-annotations，注解包，提供标准注解功能；</li>
<li>jackson-databind ，数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API （JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</li>
</ul>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>对于SpringMVC项目，需要导入依赖（maven）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于SpringBoot项目，依赖<code>spring-boot-starter-web</code>中就包括了Jackson的依赖。所以无需导入。</p>
<p>&emsp;  </p>
<h3 id="JSON字符串-》对象"><a href="#JSON字符串-》对象" class="headerlink" title="JSON字符串-》对象"></a>JSON字符串-》对象</h3><p>Jackson的一个主要类就是<code>ObjectMapper</code>，通过该类的<code>readValue()</code>方法可以将json字符串解析为指定对象。</p>
<p>&emsp;  </p>
<p>示例：</p>
<p>JavaBean使用上述的Person和Role。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testJackson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    String personJson = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;白小纯\&quot;, \&quot;age\&quot;:\&quot;20\&quot;, \&quot;roles\&quot;:[&#123;\&quot;id\&quot;:\&quot;1\&quot;,\&quot;roleName\&quot;:\&quot;医生\&quot;&#125;, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;2\&quot;,\&quot;roleName\&quot;:\&quot;老师\&quot;&#125;]&#125;&quot;</span>;</span><br><span class="line">    Person person = mapper.readValue(personJson, Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;<span class="attribute">name</span>=<span class="string">&#x27;白小纯&#x27;</span>, <span class="attribute">age</span>=20, roles=[Role&#123;<span class="attribute">id</span>=1, <span class="attribute">roleName</span>=<span class="string">&#x27;医生&#x27;</span>&#125;, Role&#123;<span class="attribute">id</span>=2, <span class="attribute">roleName</span>=<span class="string">&#x27;老师&#x27;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h3 id="对象-》json字符串"><a href="#对象-》json字符串" class="headerlink" title="对象-》json字符串"></a>对象-》json字符串</h3><p>通过<code>ObjectMapper</code>对象的<code>writeValueAsString()</code>方法实现。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectToJson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    </span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    List&lt;Role&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Role role1 = <span class="keyword">new</span> Role();</span><br><span class="line">    Role role2 = <span class="keyword">new</span> Role();</span><br><span class="line"></span><br><span class="line">    role1.setId(<span class="number">1</span>);</span><br><span class="line">    role1.setRoleName(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    role2.setId(<span class="number">2</span>);</span><br><span class="line">    role2.setRoleName(<span class="string">&quot;班长&quot;</span>);</span><br><span class="line">    roles.add(role1);</span><br><span class="line">    roles.add(role2);</span><br><span class="line"></span><br><span class="line">    person.setAge(<span class="number">20</span>);</span><br><span class="line">    person.setName(<span class="string">&quot;王大锤&quot;</span>);</span><br><span class="line">    person.setRoles(roles);</span><br><span class="line"></span><br><span class="line">    String personStr = mapper.writeValueAsString(person);</span><br><span class="line">    System.out.println(personStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;王大锤&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">20</span>,<span class="attr">&quot;roles&quot;</span>:[&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;roleName&quot;</span>:<span class="string">&quot;学生&quot;</span>&#125;,&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;roleName&quot;</span>:<span class="string">&quot;班长&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h3 id="JSON数组《-》Lsit"><a href="#JSON数组《-》Lsit" class="headerlink" title="JSON数组《-》Lsit"></a>JSON数组《-》Lsit</h3><p><strong><code>readValue()</code>方法可以解析JSON对象数组字符串为List集合，同样的，<code>writeValueAsString()</code>方法可以将List集合中的多个对象解析为Json对象数组字符串</strong>。</p>
<p>示例：</p>
<p>注意<code>readValue()</code>方法的第二个参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonTOList</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    String rolesStr = <span class="string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;roleName\&quot;:\&quot;快递员\&quot;&#125;,&#123;\&quot;id\&quot;:2,\&quot;roleName\&quot;:\&quot;程序员\&quot;&#125;]&quot;</span>;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    List&lt;Role&gt; roles = mapper.readValue(rolesStr, <span class="keyword">new</span> TypeReference&lt;List&lt;Role&gt;&gt;() &#123;&#125;);</span><br><span class="line">    System.out.println(roles);</span><br><span class="line"></span><br><span class="line">    String jsonArray = mapper.writeValueAsString(roles);</span><br><span class="line">    System.out.println(jsonArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Role&#123;<span class="attribute">id</span>=1, <span class="attribute">roleName</span>=<span class="string">&#x27;快递员&#x27;</span>&#125;, Role&#123;<span class="attribute">id</span>=2, <span class="attribute">roleName</span>=<span class="string">&#x27;程序员&#x27;</span>&#125;]</span><br><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;快递员&quot;</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:2,<span class="string">&quot;roleName&quot;</span>:<span class="string">&quot;程序员&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p><a href="https://juejin.im/post/6844904166809157639" target="_blank">Jackson使用详解–掘金 三分恶</a>（想要深入了解Jackson可以看这篇博客，巨详细）</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/04/%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88Demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/04/%E6%A1%86%E6%9E%B6/SSM%E6%95%B4%E5%90%88Demo/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-04 19:15:09" itemprop="dateCreated datePublished" datetime="2020-11-04T19:15:09+08:00">2020-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-15 17:35:14" itemprop="dateModified" datetime="2021-03-15T17:35:14+08:00">2021-03-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>本文只介绍项目中的配置文件</strong>，完整项目：<a href="https://github.com/bxxiao/SSMDemo" target="_blank">github</a>。</p>
<p>项目中使用了两张表（员工表、部门表，一个员工对应一个部门）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table dept</span><br><span class="line">(</span><br><span class="line">    dept_id   int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    dept_name varchar(255) null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table employees</span><br><span class="line">(</span><br><span class="line">    emp_id   int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    emp_name varchar(30)  null,</span><br><span class="line">    gender   char         null,</span><br><span class="line">    email    varchar(255) null,</span><br><span class="line">    d_id     int          null,</span><br><span class="line">    constraint emp_fk_dept</span><br><span class="line">        foreign key (d_id) references dept (dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>该项目是idea的maven项目，总的目录结构：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201016232015440.png" alt="image-20201016232015440" style="zoom:80%;" />

<p>&emsp;  </p>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSMIntegration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SSMIntegration Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- spring以及springMVC相关依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 事务相关配置所需依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis整合spring的jar包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池以及数据库驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis逆向工程依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis分页插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 处理json数据的jar包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- JSR303校验所需依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- servlet-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>SSMIntegration<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- mybatis逆向工程所需插件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>若在关闭tomcat服务器时会报错，见： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/bxiaoo/p/13828772.html">https://www.cnblogs.com/bxiaoo/p/13828772.html</a></p>
</blockquote>
<p>&emsp;  </p>
<h2 id="SpringMVC配置文件"><a href="#SpringMVC配置文件" class="headerlink" title="SpringMVC配置文件"></a>SpringMVC配置文件</h2><p>spring-mvc.xml（位于resources/ssm下）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在该配置文件中只配置web组件相关的bean --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 扫描controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.controller&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 两个常用配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让springmvc处理不了的请求交给tomcat，如静态资源等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 支持一些springmvc高级功能，如jsr303校验、快捷的Ajax、映射动态请求等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h2><p>spring配置文件中配置了service、dao等bean，也<strong>包括跟mybatis的整合配置</strong>。</p>
<h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p>Spring整合Mybatis通过类<code>SqlSessionFactoryBean</code>，<strong>在该bean中可以进行与Mybatis主配置文件一样的配置，即可以省略Mybatis主配置文件</strong>。也可以通过<code>configLocation</code>属性来指定主配置文件的路径。</p>
<p>spring-mybatis.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接池，这里使用德鲁伊 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接池数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最小连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接超时时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQueryTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==========================spring和MyBatis完美整合=========================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis的主配置文件中的所有配置，都可以在SqlSessionFactoryBean中进行配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定别名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ssm.bean&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置分页插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SqlSessionTemplate是线程安全的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;executorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描dao接口，将dao接口的实现类添加到ioc容器（Root WebApplicationContext）中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ssm.dao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ========================================================================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>jdbc.properties：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=com.mysql.cj.jdbc.Driver</span><br><span class="line"><span class="attr">url</span>=jdbc:mysql://locaohost:<span class="number">3306</span>/ssm?serverTimezone=UTC</span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">password</span>=admin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于SqlSessionTemplate：<a href="https://www.jianshu.com/p/7cb4777a539e" target="_blank">对于SqlSessionTemplate的理解</a> </p>
</blockquote>
<h3 id="整合spring事务管理"><a href="#整合spring事务管理" class="headerlink" title="整合spring事务管理"></a>整合spring事务管理</h3><p>关于spring中基于xml的声明式事务要注意的一个点：</p>
<p><strong><font color="red">在基于XML的声明式事务中，事务属性的tx: method是必须配置的，如果某个方法没有对应的tx: method配置，那么事务对这个方法就不生效，即不会使用默认值</font></strong> 。</p>
<p>spring-service.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置service层：扫描 service 包；配置事务管理 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- =========配置事务管理========= --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定控制的数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 也可以配置基于注解的声明式事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用 xml 配置事务管理 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务属性，即配置事务的传播行为，隔离级别等 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- advice默认指定id为transactionManager的事务管理器，所以若是配置的事务管理器id不是该值，则需显示指定</span></span><br><span class="line"><span class="comment">            事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name属性指定当前method标签配置的事务属性要应用到哪些方法</span></span><br><span class="line"><span class="comment">                如第二个method标签指定对所有get开头的方法应用只读属性（只能查询）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPoint&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.ssm.service..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPoint&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ===================================================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h3 id="spring配置文件"><a href="#spring配置文件" class="headerlink" title="spring配置文件"></a>spring配置文件</h3><p>将 mybatis、service 整合进 spring Root ApplicationContext。</p>
<p>rootApplicationContext.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入整合mybatis的相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:ssm/spring-mybatis.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入 service 相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:ssm/spring-service.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="日志配置文件"><a href="#日志配置文件" class="headerlink" title="日志配置文件"></a>日志配置文件</h2><p>log4j2的配置文件（log4j2.xml），该配置主要打印sql语句执行日志：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;PATTERN&quot;</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t-%L] %-5level</span><br><span class="line">            %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;consolePrint&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.ssm.dao&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consolePrint&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置日志的根节点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consolePrint&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="web-xml配置文件"><a href="#web-xml配置文件" class="headerlink" title="web.xml配置文件"></a>web.xml配置文件</h2><p>web.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring配置文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:ssm/rootApplicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log4j配置文件的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfiguration<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:log4j2.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 防止Spring内存溢出监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.IntrospectorCleanupListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过配置ContextLoaderListener，让其创建Spring的应用上下文（Root ApplicationContext）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 服务器关闭时关闭驱动的监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.ssm.listener.DriverMangerListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:ssm/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 字符编码过滤器，该过滤器一般位于所有过滤器之前 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter用于将post请求转换为指定请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当客户端发送PUT、DELETE、PATCH请求时，该过滤器会将其中的参数信息进行处理，以</span></span><br><span class="line"><span class="comment">        便可以通过HttpRequest对象的getParameter方法获取到参数数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.FormContentFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<blockquote>
<p>web.xml中的FormContentFilter：</p>
<p>在前端，可以通过Ajax直接发送DELETE、PUT等post、get之外的请求，但tomcat对于post之外的请求，并不会将其中的参数数据封装进request对象，从而不能通过request的getParameter方法可以获取到这些参数。而springMVC是使用getParameter方法来获取数据封装进控制器方法的JavaBean形参，所以导致了封装不了JavaBean的信息。</p>
<p>FormContentFilter可以对DELETE、PUT请求中的参数数据进行处理，让springMVC可以正常封装JavaBean形参。</p>
<p>关于IntrospectorCleanupListener：<a href="https://www.cnblogs.com/qiankun-site/p/5886673.html" target="_blank">IntrospectorCleanupListener作用</a> </p>
</blockquote>
<p>&emsp; </p>
<h2 id="Mybatis-Generator"><a href="#Mybatis-Generator" class="headerlink" title="Mybatis-Generator"></a>Mybatis-Generator</h2><p>使用mybatis逆向工程身材mapper及其配置文件。</p>
<p>配置文件（generator/generatorConfig.xml）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;mysql驱动包绝对路径&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;simple&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置生成的类不带注释 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/ssm?serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定生成的JavaBean的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ssm.bean&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定映射文件的生成位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定dao接口生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ssm.dao&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定每个表的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Employee&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Department&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.cnblogs.com/DoubleEggs/p/6243216.html" target="_blank">【SSM】Eclipse使用Maven创建Web项目+整合SSM框架</a> </p>
<p><a href="https://www.cnblogs.com/zyw-205520/p/4771253.html" target="_blank">SSM框架——详细整合教程（Spring+SpringMVC+MyBatis）</a> </p>
<p><a href="https://blog.csdn.net/z69183787/article/details/52925567" target="_blank">使用Log4j2打印Mybatis SQL语句以及结果集</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq598535550/article/details/51703190">手把手教你整合最优雅SSM框架</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/04/%E6%A1%86%E6%9E%B6/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/04/%E6%A1%86%E6%9E%B6/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" class="post-title-link" itemprop="url">Mybatis逆向工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-04 18:33:15" itemprop="dateCreated datePublished" datetime="2020-11-04T18:33:15+08:00">2020-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-07 18:04:44" itemprop="dateModified" datetime="2020-11-07T18:04:44+08:00">2020-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Mybatis逆向工程（Mybatis Generator）用于根据配置文件自动生成数据表对应的JavaBean，以及dao接口和映射文件。</p>
<p>该示例以Maven的插件形式运行Mybatis逆向工程。（Maven项目）</p>
<h2 id="pom-xml中添加插件"><a href="#pom-xml中添加插件" class="headerlink" title="pom.xml中添加插件"></a>pom.xml中添加插件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="数据表示例"><a href="#数据表示例" class="headerlink" title="数据表示例"></a>数据表示例</h2><p>以dept表（部门）和employees表（员工）为例。员工的d_id指向dept的主键。</p>
<p>dept：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927200546234.png" alt="image-20200927200546234"></p>
<p>employees：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927200613315.png" alt="image-20200927200613315"></p>
<p>&emsp;  </p>
<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>创建连接数据库相关信息的<code>jdbc.properties</code>文件以及逆向工程的配置文件<code>generatorConfig.xml</code>。放在resource目录下。并将MySQL jdbc驱动包放在resource下（这里使用的是mysql-connector-java-5.1.47.jar）。</p>
<blockquote>
<p>PS：<strong>mybatis-generator插件默认在resource目录下查找<code>generatorConfig.xml</code>配置文件，所以这里的<code>generatorConfig.xml</code>配置文件要注意位置与命名</strong>。</p>
</blockquote>
<p>jdbc.properties：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/ssm?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">admin</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p><code>generatorConfig.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入properties配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">&quot;驱动包的绝对路径&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置生成的类不带注释（建议，因为生成的注释没啥用） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--jdbc的数据库连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定生成的JavaBean的包位置,</span></span><br><span class="line"><span class="comment">                用来生成含有主键key的类，记录类 以及查询Example类</span></span><br><span class="line"><span class="comment">                不用事先创建好包结构，mybatis-generator会根据配置自动创建，sqlMapGenerator同</span></span><br><span class="line"><span class="comment">            targetPackage     指定生成的JavaBean生成所在的包名</span></span><br><span class="line"><span class="comment">            targetProject     指定在该项目下所在的路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.generator.bean&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对model添加 构造函数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;constructorBased&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;immutable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定dao接口（mapper）的位置</span></span><br><span class="line"><span class="comment">                type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象</span></span><br><span class="line"><span class="comment">                type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象</span></span><br><span class="line"><span class="comment">                type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.generator.dao&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定每个表的生成策略</span></span><br><span class="line"><span class="comment">                配置数据表与JavaBean的名称映射，以及是否创建根据条件查询的sql语句等 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName指定表名，domainObjectName指定表对应的JavaBean名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Department&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Employee&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="插件相关配置"><a href="#插件相关配置" class="headerlink" title="插件相关配置"></a>插件相关配置</h2><p>在maven窗口配置一个插件运行。</p>
<ol>
<li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927200743717.png" alt="image-20200927200743717" style="zoom:80%;" />
</li>
<li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201004256.png" alt="image-20200927201004256" style="zoom:80%;" />
</li>
<li><p>分别填入项目的目录以及命令<code>mybatis-generator:generate -e</code>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201321279.png" alt="image-20200927201321279" style="zoom:80%;" />
</li>
<li><p>OK。</p>
</li>
</ol>
<p>&emsp;  </p>
<h2 id="运行Generator"><a href="#运行Generator" class="headerlink" title="运行Generator"></a>运行Generator</h2><p>打开maven窗口可看到：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201451117.png" alt="image-20200927201451117"></p>
<p>&emsp;  </p>
<p>双击即可运行generator。</p>
<p>运行后的项目目录，可看到创建了JavaBean、dao以及映射文件：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200927201609898.png" alt="image-20200927201609898" style="zoom:80%;" />



<p>&emsp; </p>
<h2 id="XxxExample的使用"><a href="#XxxExample的使用" class="headerlink" title="XxxExample的使用"></a>XxxExample的使用</h2><p>通过逆向工程生成的JavaBean中可以看到有XxxExample的类，这些类的作用是用于设置查询条件。</p>
<p>简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmployeeExample</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSession session = getSqlSession();<span class="comment">//获取SqlSession（方法具体实现省略）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个example类</span></span><br><span class="line">    EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">    <span class="comment">//查询employees表中did为1的记录</span></span><br><span class="line">    example.or().andDIdEqualTo(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">    List&lt;Employee&gt; employees = mapper.selectByExample(example);</span><br><span class="line">    <span class="keyword">for</span>(Employee e : employees)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>又如：通过模糊查询，查询EmpName包含“三”的记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">example.or().andEmpNameLike(<span class="string">&quot;%三%&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>其他的添加查询条件的方法：（来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/biandous/article/details/65630783%EF%BC%89">https://blog.csdn.net/biandous/article/details/65630783）</a></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>example.setOrderByClause(“字段名 ASC”);</td>
<td>添加升序排列条件，DESC为降序</td>
</tr>
<tr>
<td>example.setDistinct(false)</td>
<td>去除重复，boolean型，true为选择不重复的记录。</td>
</tr>
<tr>
<td>criteria.andXxxIsNull</td>
<td>添加字段xxx为null的条件</td>
</tr>
<tr>
<td>criteria.andXxxIsNotNull</td>
<td>添加字段xxx不为null的条件</td>
</tr>
<tr>
<td>criteria.andXxxEqualTo(value)</td>
<td>添加xxx字段等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxNotEqualTo(value)</td>
<td>添加xxx字段不等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxGreaterThan(value)</td>
<td>添加xxx字段大于value条件</td>
</tr>
<tr>
<td>criteria.andXxxGreaterThanOrEqualTo(value)</td>
<td>添加xxx字段大于等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxLessThan(value)</td>
<td>添加xxx字段小于value条件</td>
</tr>
<tr>
<td>criteria.andXxxLessThanOrEqualTo(value)</td>
<td>添加xxx字段小于等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxIn(List&lt;？&gt;)</td>
<td>添加xxx字段值在List&lt;？&gt;条件</td>
</tr>
<tr>
<td>criteria.andXxxNotIn(List&lt;？&gt;)</td>
<td>添加xxx字段值不在List&lt;？&gt;条件</td>
</tr>
<tr>
<td>criteria.andXxxLike(“%”+value+”%”)</td>
<td>添加xxx字段值为value的模糊查询条件</td>
</tr>
<tr>
<td>criteria.andXxxNotLike(“%”+value+”%”)</td>
<td>添加xxx字段值不为value的模糊查询条件</td>
</tr>
<tr>
<td>criteria.andXxxBetween(value1,value2)</td>
<td>添加xxx字段值在value1和value2之间条件</td>
</tr>
<tr>
<td>criteria.andXxxNotBetween(value1,value2)</td>
<td>添加xxx字段值不在value1和value2之间条件</td>
</tr>
</tbody></table>
<p>&emsp;  </p>
<p><strong>以上方法都可以通过example类的<code>or()</code>方法调用（如示例），推荐使用这种方式</strong>。</p>
<p>使用<code>or()</code>方法添加多个条件时要注意：</p>
<ul>
<li><p><strong>若是要添加多个AND条件，应是这种方式：</strong> **<code>example.or().andXxx1(xx).andXxx2(xx).addXxx3(xx);</code>**。</p>
</li>
<li><p>若是使用以下方式，添加的多个条件将是OR条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example.or().andXxx1(xx);</span><br><span class="line">example.or().andXxx2(xx);</span><br><span class="line">example.or().andXxx3(xx);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>&emsp;  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/for_my_life/article/details/51228098">https://blog.csdn.net/for_my_life/article/details/51228098</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/biandous/article/details/65630783">https://blog.csdn.net/biandous/article/details/65630783</a></p>
</blockquote>
<p>&emsp;  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bxxiao</p>
  <div class="site-description" itemprop="description">nothing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bxxiao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bxxiao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bxxiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
