<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="do nothing, nothing there">
<meta property="og:type" content="website">
<meta property="og:title" content="bxxiao">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="bxxiao">
<meta property="og:description" content="do nothing, nothing there">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bxxiao">
<meta property="article:tag" content="bxxiao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>bxxiao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bxxiao" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bxxiao</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/11/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/11/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机网络笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-11 00:33:27 / 修改时间：00:31:11" itemprop="dateCreated datePublished" datetime="2021-03-11T00:33:27+08:00">2021-03-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​        运输层的任务就是<strong>负责向两台主机中进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。由于一台主机可同时运行多个进程，因此运输层有<strong>复用和分用</strong>的功能。<strong>复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程</strong>（<strong>把信息传上去</strong>）。</p>
<p>​        运输层主要使用以下两种协议：</p>
<ul>
<li><strong>传输控制协议TCP</strong>（Transmission Control Protocol） 提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>（segment）。</li>
<li><strong>用户数据报协议UDP</strong>（User Datagram Protocol）提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是<strong>用户数据报</strong>。</li>
</ul>
<p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p>
<h3 id="为什么需要运输层"><a href="#为什么需要运输层" class="headerlink" title="为什么需要运输层"></a>为什么需要运输层</h3><p><strong>IP层的IP地址只是标识了两台主机，只能实现两个主机间的通信，而真正进行通信的是两个主机中的实体（进程），运输层通过端口来标识主机中的进程，实现进程间的通信</strong>。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP，User Datagram Protocol，用户数据报协议。</p>
<p><strong>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能， 这就是复用分用的功能以及差错检测的功能</strong>。UDP的主要特点是：</p>
<ul>
<li><strong>无连接</strong>。即发送数据之前不用建立连接。</li>
<li>UDP使用<strong>尽最大努力交付</strong>。</li>
<li>UDP是<strong>面向报文</strong>的。即应用层交下来的报文，UDP既不合并，也不拆分，只加上UDP首部后直接发送；相应的，接收时去除首部后直接上交应用层。</li>
<li><strong>没有拥塞控制</strong>。即网络的拥塞不会使源主机发送速率降低。但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信）</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li>
<li>首部开销小，8B。</li>
</ul>
<h3 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h3><p>TCP，Transmission Control Protocol，传输控制协议。</p>
<p>TCP的主要特点：</p>
<ul>
<li><strong>面向连接</strong>。即使用tcp之前（通信之前）需要建立可靠连接，通信完毕后释放连接。</li>
<li>每一个TCP连接<strong>只能有两个端点</strong>。<ul>
<li>TCP连接的端点叫做<strong>套接字（socket）</strong>，一个套接字<strong>由<code>IP地址:端口号</code>组成</strong>。<strong>一个TCP连接由两个套接字唯一确定</strong>。</li>
</ul>
</li>
<li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据， <strong>无差错、不丢失、不重复，并且按序到达</strong>。</li>
<li>TCP提供<strong>全双工通信</strong>。TCP允许<strong>通信双方的应用进程在任何时候都能发送数据</strong>。<ul>
<li><strong style="color:red">TCP连接的两端都设有发送缓存和接收缓存， 用来临时存放双向通信的数据</strong>。<strong>在发送时，应用程序在把数据传送给TCP的缓存后， 就可以做自己的事， 而TCP在合适的时候把数据发送出去。在接收时， TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</strong>。</li>
</ul>
</li>
<li><strong>面向字节流</strong>。<strong style="color:red">TCP中的“流”(stream) 指的是流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块(<strong>大小不等</strong>) ， 但TCP把应用程序交下来的数据<strong>仅仅看成是一连串的无结构的字节流</strong>。TCP并不知道所传送的字节流的含义。TCP<strong>不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</strong>。<strong>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</strong>。</li>
</ul>
<h3 id="TCP可靠传输原理"><a href="#TCP可靠传输原理" class="headerlink" title="TCP可靠传输原理"></a>TCP可靠传输原理</h3><p>（来自JavaGuide）</p>
<p>概述：</p>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待协议的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组</strong>。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就<strong>重传前面发送过的分组</strong>（认为刚才发送过的分组丢失了）。因此<strong>每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些</strong>。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。</p>
<p><strong>若收到重复分组，就丢弃该分组，但同时还要发送确认</strong>。<strong>连续 ARQ 协议</strong> 可提高信道利用率。</p>
<p><strong>3) 确认丢失和确认迟到</strong>                   </p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下<strong>两点措施</strong>：<strong>1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。</strong> </li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。<strong>处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1</strong>。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。<strong>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</strong>。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> <strong>不能向发送方反映出接收方已经正确收到的所有分组的信息</strong>。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h4 id="滑动窗口实现流量控制"><a href="#滑动窗口实现流量控制" class="headerlink" title="滑动窗口实现流量控制"></a>滑动窗口实现流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率</strong>。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p>​    </p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫<strong>拥塞</strong>。<strong>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载</strong>。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<blockquote>
<p>cwnd指拥塞窗口长度</p>
</blockquote>
<ul>
<li><p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是<strong>先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。<strong>每当出现超时的时候重新开始发送时即使用慢开始</strong>。</p>
</li>
<li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是<strong>让拥塞窗口cwnd缓慢增大</strong>，即每经过一个往返时间RTT就把发送放的cwnd加1。</p>
</li>
<li><p><strong>快重传与快恢复（fast retransmit and recovery，FRR）</strong>：采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。<strong>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认（这里已收到的报文段是指失序段之前的报文段）</strong>。</p>
<p>如图（来自《计算机网络》所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3；但却收到了M4。本来接收方可以什么都不做。<strong>但按照快重传算法，接收方必须立即发送对M2的重复确认（注意是M2）</strong>，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送Ms和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M的确认，其中后3个都是重复确认。<strong>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞</strong>。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210307172719911.png" alt="image-20210307172719911"></p>
<p>相应的，<strong>发送方知道只是丢失个别报文段，重新发送数据时不会启动慢开始，而是执行快恢复算法，即适当调整cwnd大小</strong>（如除以2），并执行拥塞避免。</p>
</li>
</ul>
<h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308171503072.png" alt="image-20210308171503072"></p>
<p>其中部分字段含义：</p>
<ul>
<li>序号（seq）。TCP 是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。<strong>序号字段值指的是本报文段所发送的数据的第一个字节的序号</strong>。</li>
<li>确认号（ack）。<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为 N ，则标识序号 1 ~ N-1 的字节都已正确收到。</li>
<li>确认 ACK （控制位） 。<strong>仅当ACK=1时确认号字段才有效</strong>。当ACK=0时， 确认号无效。TCP规定，<strong>在连接建立后所有传送的报文段都必须把ACK置1</strong>。</li>
<li>同步 SYN （控制位）。<strong>在连接建立时用来同步序号</strong>。<strong>当SYN=1而ACK=0时，表明这是一个连接请求报文段</strong>。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此， <strong>SYN置为1就表示这是一个连接请求或连接接受报文</strong>。</li>
<li>终止 FIN （控制位）。用来释放一个连接。<strong>当FIN=1时， 表明此报文段的发送方的数据已发送完毕，并要求释放运输连接</strong>。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>《计算机网络 第7版》中称为“三报文握手”。</p>
<p>图片来自《计算机网络 第7版》</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210308162534931.png" alt="image-20210308162534931"></p>
<p> A 为客户端，B 为服务器端。</p>
<blockquote>
<p>ack 指确认号字段，ACK 是6个控制位之一。</p>
</blockquote>
<ul>
<li><strong>首先 B 处于 LISTEN（监听）状态</strong>，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，（同步字段）SYN=1，（ACK=0），<strong>选择一个初始的序号 x</strong>，即 <code>SYN=1, seq=x</code> 。</li>
<li>B 收到连接请求报文，<strong>如果同意建立连接，则向 A 发送连接确认报文</strong>，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。即 <code>SYN=1, ACK=1, seq=y, ack=x+1</code> 。</li>
<li><strong>A 收到 B 的连接确认报文后，还要向 B 发出确认</strong>，确认号为 y+1，序号为 x+1。即 <code>ACK=1, ack=y+1, seq=x+1</code> 。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><strong style="color:red">为什么需要最后一次握手（确认）？</strong> </p>
<p><strong>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</strong>。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，<strong>如果不进行三次握手</strong>，那么服务器就会打开两个连接。<strong>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，服务器接不到确认也就不会打开连接</strong>。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="E:\TyporaImage\image-20210308164017342.png" alt="image-20210308164017342"></p>
<ul>
<li>A 发送连接释放报文，FIN=1，并停止发送数据。 <code>FIN=1, seq=u</code> 。<strong>A进入“终止等待状态1”</strong>。</li>
<li>B 收到之后发出确认：<code>ACK=1, ack=u+1, seq=v</code> 。<strong>此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</strong>，即从 A -》B 这个方向的连接释放了。<strong>此时 B 进入“关闭等待”状态</strong></li>
<li>A收到确认后，<strong>进入“终止等待状态2”。等待B的连接释放报文段</strong>。</li>
<li><strong>B 发出确认后会发送还没发送完的数据</strong>，当 B 已经没有要向 A 发送的数据时，<strong>发送连接释放报文，FIN=1</strong>。 <code>FIN=1, ACK=1, seq=w, ack=u+1</code> 。<strong>B 进入“最后确认”状态</strong>。</li>
<li>A 收到后发出确认： <code>ACK=1, seq=u+1, ack=w+1</code> ，<strong>进入 TIME-WAIT （时间等待）状态，此时连接还没有释放，A 会等待 2 MSL（Maximum Segment Lifetime，最大报文存活时间）后释放连接</strong>。</li>
<li><strong>B 收到 A 的确认后释放连接</strong>。</li>
</ul>
<p>客户端接收到服务器端的 FIN 报文后还需要等待一个时间计时器设置的时间 2MSL。<strong>这么做有两个理由</strong>：</p>
<ul>
<li><strong>确保最后一个确认报文能够到达</strong>。如果 B 没收到 A 发送来的确认报文，会超时重传连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生，这时 A 会重新发送确认报文，<strong>并将计时重新设置为 2 MSL</strong>。</li>
<li>等待一段时间是为了<strong>让本连接持续时间内所产生的所有报文都从网络中消失使得下一个新的连接不会出现旧的连接请求报文，如已失效的连接请求报文段</strong>。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html">运输层</a> </p>
<p>《计算机网络 第7版》</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/05/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(to%20be..)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/05/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(to%20be..)/" class="post-title-link" itemprop="url">类文件结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-05 14:25:56" itemprop="dateCreated datePublished" datetime="2021-03-05T14:25:56+08:00">2021-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:07:13" itemprop="dateModified" datetime="2021-03-20T20:07:13+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="class文件结构概述"><a href="#class文件结构概述" class="headerlink" title="class文件结构概述"></a>class文件结构概述</h2><p><strong>Class文件是一组<font color="red">以字节为基础单位</font>的二进制流， 各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</strong>，当遇到需要占用单个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个字节进行存储。</p>
<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，<strong>这种伪结构中只有两种数据类型</strong>：<strong>“无符号数”和“表”</strong>。</p>
<ul>
<li>无符号数属于基本的数据类型，以<strong><font color="red">ul、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数</font></strong>，无符号数<strong>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</strong>。</li>
<li><strong>表是由多个无符号数或者其他表作为数据项构成的复合数据类型</strong>，表的命名习惯以“info”结尾。表用于描述有层次关系的复合结构的数据。</li>
</ul>
<p>整个Class文件本质上也可以视作是一张表， 这张表由下图所示的数据项按严格顺序排列构成。<strong>该格式中的数据项，无论是顺序还是数量，都是被严格限定的</strong>。(【】内表示数量，第一列表示数据类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;【<span class="number">1</span>】 <span class="comment">//Class文件的标志（魔数）</span></span><br><span class="line">    u2             minor_version;【<span class="number">1</span>】<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;【<span class="number">1</span>】<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool【constant_pool_count-<span class="number">1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br><span class="line">    u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;【<span class="number">1</span>】<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;【<span class="number">1</span>】<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;【<span class="number">1</span>】<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces;【interfaces_count】<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;【<span class="number">1</span>】<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields;【fields_count】<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;【<span class="number">1</span>】<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods;【methods_count】<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;【<span class="number">1</span>】<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes;【attributes_count】<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class文件中，<strong>当需要描述同一类型但数量不定的多个数据项时，使用一个前置的容量计数器（u2无符号数，即两个字节）加若干个连续的数据项的形式来表示</strong>。</p>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure>

<p>每个Class文件的头4个字节称为魔数，用于<strong>标志这是一个能被JVM接受的class文件</strong>。其值为<code>0xCAFEBABE</code>。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version<span class="comment">;【1】</span></span><br><span class="line">u2             major_version<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure>

<p><strong>紧接的4个字节是class文件的版本号，第5、6为次版本号（Minor Version），第7、8为主版本号（Major Version）</strong>。</p>
<p><strong>高版本的 Java 虚拟机可以向下兼容执行低版本编译器生成的 Class 文件</strong>，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p>
<blockquote>
<p>jdk1.1对应45（十进制），往上依次递增1。如jdk1.8对应52（0x34）</p>
</blockquote>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool【constant_pool_count<span class="number">-1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br></pre></td></tr></table></figure>

<p>紧接着主、次版本号之后的是常量池， <strong>常量池可以比喻为Class文件里的资源仓库， 它是Class文件结构中与其他项目关联最多的数据</strong>。</p>
<p><strong>常量池中常量的数量是不固定的</strong>。constant_pool_count指定常量数量。<strong>这个容量计数是从1而不是0开始的</strong>，例如，若是0x0018（十进制24），即表示有24-1=23个常量。<strong>将第0项常量空出来的目的在于</strong>：<strong><font color="red">如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义， 可以把索引值设置为0来表示</font></strong>。</p>
<p>对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。</p>
<p>常量池中主要存放两大类常量：<strong>字面量和符号引用</strong>。</p>
<ul>
<li>字面量比较接近于Java语言层面的常量概念， 如文本字符串、被声明为final的常量值等。</li>
<li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul>
<li>被模块导出或者开放的包</li>
<li><strong>类和接口的全限定名</strong> </li>
<li>**字段的名称和描述符 ** </li>
<li><strong>方法的名称和描述符</strong> </li>
<li>方法句柄和方法类型</li>
<li>动态调用点和动态常量</li>
</ul>
</li>
</ul>
<blockquote>
<p>Java代码在进行Javac编译的时候， 并不像C和C++那样有“连接”这一步骤， 而是<strong>在虚拟机加载Class文件的时候进行动态连接</strong>的 。也就是说， <strong>在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存人口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</strong>。</p>
</blockquote>
<p>常量池中每一项常量都是一个表，<strong>截至JDK13</strong>， 常量表中分别有17种不同类型的常量。<strong>这些表都有一个共同的特点， 表结构起始的第一位是个u1类型的标志位</strong>(tag， 见下表标志列)，代表着当前常量属于哪种常量类型。17种类型如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志（tag）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>５</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>６</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>７</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>８</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>９</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MothodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_Dynamic_info</td>
<td>17</td>
<td>表示一个动态计算常量</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
<tr>
<td>CONSTANT_Module_info</td>
<td>19</td>
<td>表示一个模块</td>
</tr>
<tr>
<td>CONSTANT_Package_info</td>
<td>20</td>
<td>表示一个模块中开发或者导出的包</td>
</tr>
</tbody></table>
<p>常见的11种类型的结构表：（index表示指向第几个常量项）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125112646190.png" alt="image-20210125112646190"></p>
<blockquote>
<p>在读取常量池时，只要读取每个项的第一个字节（tag）就可得知其类型，得知其类型后就能知道该项占多少字节，也就可以知道下一项从哪里开始，以此类推。</p>
</blockquote>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure>

<p>常量池结束之后紧接着的两个字节代表<strong>访问标志</strong>，这个标志用于识别一些类或者接口层次的访问信息，即一个类或接口使用了哪些访问修饰符（public、abstract等）。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125113620989.png" alt="image-20210125113620989"></p>
<p>一个类或接口可拥有多个标志，<strong>这时标志值应该为这多个标志值取或</strong>。如 ACC_PUBLIC | ACC_SUPER = 0x0021。</p>
<h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><pre><code>u2             this_class;【1】//当前类
u2             super_class;【1】//父类
u2             interfaces_count;【1】//接口数量
u2             interfaces;【interfaces_count】//一个类可以实现多个接口</code></pre>
<p>类索引和父类索引都是一个u2类型的数据， 而接口索引集合是一组u2类型的数据的集合， Class文件中<strong>由这三项数据来确定该类型的继承关系</strong>。</p>
<ul>
<li><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名</strong>。Java不允许多继承， 所以父类索引只有一个， 除了java.lang.Object之外， 所有的Java类都有父类， 因此除了java.lang.Object外， 所有Java类的父类索引都不为0。<strong>这是两个索引值，指向常量池的对应项</strong>。</p>
</li>
<li><p><strong>接口索引集合</strong>描述这个类实现了哪些接口，集合第一个项是接口计数器，之后是对应数量的接口索引（若计数器为0则不再占用任何字节）。<strong>这些接口索引将按implements关键字（如果该Class文件表示接口， 则是extends）后的接口顺序从左到右排列在接口索引集合中</strong>。</p>
</li>
</ul>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><pre><code>u2             fields_count;【1】//Class 文件的字段属性
field_info     fields;【fields_count】//一个类会可以有多个字段</code></pre>
<p>字段表用于描述接口或类中声明的变量。字段<strong>包括类级变量以及实例变量</strong>，但<strong>不包括在方法内部声明的局部变量</strong>。</p>
<p>一个字段表的结构（来自javaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p>
<p>各字段解释：</p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ，<code>private</code>，<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符），可否被序列化（transient 修饰符），可变性（final），可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> <strong>对常量池的引用</strong>，表示的字段的简单名称；</li>
<li><strong>descriptor_index:</strong> <strong>对常量池的引用</strong>，表示字段和方法的描述符；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，<strong>适合使用标志位来表示。而字段叫什么名字、字段数据类型都是无法固定的，只能引用常量池中常量来描述</strong>。</p>
<p><strong>字段表中不会列出继承自父类或父接口的字段</strong>。</p>
<blockquote>
<p>关于描述符：描述符用来描述<strong>字段的数据类型</strong>，或方<strong>法的参数列表（包括数量、类型和顺序）和返回值</strong>。基本数据类型以及无返回值void都用一个大写字符表示，对应关系：</p>
<ul>
<li>B- byte， C-char， D- double， F- float， I- int， J- long， s- short， z-boolean， v- void， L-对象类型，如Ljava.lang.String</li>
<li>对于数组，一个维度对应一个 <code>[</code>， + L + 元素类型，如<code>[[I，[[Ljava.lang.String</code>。</li>
</ul>
<p>描述符描述方法时，<strong>按照先参数列表后返回值的顺序</strong>，如<code>()V 、(I)Ljava.lang.String</code>。</p>
</blockquote>
<p>access_flags表示访问标志，即字段的修饰符，其取值如下：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150405202.png" alt="image-20210125150405202"></p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><pre><code>u2             methods_count;【1】
method_info    methods;【methods_count】</code></pre>
<p>分别表示方法数量和方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构与字段表一样，如下：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p>
<p><strong>Java方法里的代码，经Javac编译成字节码之后，放在方法属性表集合中一个名为“Code”的属性里面</strong>。</p>
<p>标志位取值：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125173337287.png" alt="image-20210125173337287"></p>
<blockquote>
<p>synchronized关键字 的字节码相关： P46</p>
</blockquote>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="regexp">//</span>此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];<span class="regexp">//</span>属性表集合</span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="一些常见属性"><a href="#一些常见属性" class="headerlink" title="一些常见属性"></a>一些常见属性</h3><p>1.<strong>Code属性</strong> </p>
<p>结构：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125174146152.png" alt="image-20210125174146152" style="zoom:80%;" />

<ul>
<li><p>attribute_length表示attribute所包含的字节数，不包含 attribute name index和attribute length字段。</p>
</li>
<li><p>max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度</p>
</li>
<li><p>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量</p>
</li>
</ul>
<p>2.<strong>LineNumberTable</strong>属性</p>
<p>用于表示Code中的字节码与源码的行号对应关系（一行对应一个指令）</p>
<p>3.LocalVariableTable</p>
<p>局部变量表，记录局部变量信息，其中的变量名等会引用常量池中的utf8字符串常量。</p>
<p><strong>对于实例方法，在class文件中，每个方法内至少会有一个局部变量：this，即所属对象的引用</strong></p>
<h2 id="To-be-continue"><a href="#To-be-continue" class="headerlink" title="To be continue"></a>To be continue</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>《深入理解JVM》</p>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/?id=java">JavaGuide文档</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-04 00:01:09 / 修改时间：00:00:39" itemprop="dateCreated datePublished" datetime="2021-03-04T00:01:09+08:00">2021-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>定义：<strong>在当前进程中，通过单例模式创建的类有且只有一个实例</strong>。</p>
<p>单例有如下几个特点：</p>
<ul>
<li>在Java应用中，单例模式<strong>需要保证在一个JVM中，该对象只有一个实例存在</strong>。</li>
<li><strong>构造器必须是私有的</strong>，外部类无法通过调用构造器方法创建该实例。</li>
<li><strong>没有公开的set方法</strong>，外部类无法调用set方法创建该实例。</li>
<li>提供一个公开的get方法获取唯一的这个实例。</li>
</ul>
<p>单例模式的好处：</p>
<ul>
<li>某些类创建比较频繁，<strong>对于一些大型的对象，节省很大的系统开销</strong>。</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li>
<li>系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个，会造成系统混乱。</li>
<li>避免了对资源的重复占用</li>
</ul>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在<strong>程序启动或单例模式类被首次主动使用的时候</strong>，单例模式实例被创建。<strong>总之，饿汉式体现的是想提前把对象创建好</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式没有线程安全问题，instance是在Singleton类初始化时创建的，JVM可以保证线程安全。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式单例在第一次调用getInstance才创建实例。</p>
<h3 id="线程不安全实现"><a href="#线程不安全实现" class="headerlink" title="线程不安全实现"></a>线程不安全实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Singleton2.getInstance());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行多次，可以看到获取对象不是同一个。</p>
<p><strong>应用场景</strong>：如果这个数据是经常访问的热点数据，那我就可以在系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了；反之，数据使用频率较低，则使用懒汉式，避免资源浪费。</p>
<h3 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h3><p>getInstance加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样能保证线程安全，但是<strong>效率过低，实例被创建后调用getInstance依然需要加锁</strong>。</p>
<p>通过双检锁（double-checked）做两次判断优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意INSTANCE需要加上<code>volatile</code>关键字，避免指令重排序问题</strong>。<code>INSTANCE = new Singleton();</code>并不是原子操作，JVM可能会先执行赋值操作再执行初始化操作，</p>
<p>没加volatile时线程不安全的情况：</p>
<ul>
<li>A、B同时进入第一个if。</li>
<li>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</li>
<li>由于JVM内部的优化机制，JVM可能会<strong style="color:red">先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块</strong>。</li>
<li>随后B进入synchronized块，由于instance此时不是null，<strong>因此它马上离开了synchronized块并将结果返回给调用该方法的程序</strong>。</li>
<li>此时若B线程马上使用Singleton实例，<strong>却发现它没有被初始化，于是错误发生了</strong>。</li>
</ul>
<p>缺点：<strong>由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高</strong>。</p>
<p>可以使用静态内部类实现。</p>
<h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>使用内部类来维护单例的实现，<strong>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的</strong>。</p>
<h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举来实现单实例控制会更加<strong>简洁，而且JVM从根本上提供保障，绝对防止多次实例化</strong>，是更简洁、高效、安全的实现单例的方式。</p>
<h2 id="为什么不用静态方法而用单例模式？"><a href="#为什么不用静态方法而用单例模式？" class="headerlink" title="为什么不用静态方法而用单例模式？"></a>为什么不用静态方法而用单例模式？</h2><p>（来自参考连接）</p>
<p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，<strong>面向对象的代码提供一个更好的编程思想</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ">设计模式系列 - 单例模式</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE%E5%85%AD%E7%A7%8D%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">UML类图六种关系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-04 00:01:09 / 修改时间：00:00:56" itemprop="dateCreated datePublished" datetime="2021-03-04T00:01:09+08:00">2021-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UML类图用于<strong>描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</strong>。 </p>
<p>类之间的关系有：<strong>泛化（继承）、实现、关联、聚合、组合、依赖</strong>。</p>
<p>六种关系的耦合度大小是：<strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong>。</p>
<h2 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h2><p>泛化就是指继承关系。</p>
<p>代码体现：子类继承父类。</p>
<p>UML符号：<strong>实线+空心箭头，箭头指向父类</strong> </p>
<p>如图：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022222623274.png" alt="image-20201022222623274"></p>
<h2 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h2><p>实现关系即实现类实现接口。</p>
<p>代码体现：A类实现B接口。</p>
<p>UML符号：<strong>一条虚线+空心箭头</strong> </p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022224009475.png" alt="image-20201022224009475" style="zoom:67%;" />

<h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>关联关系指<strong>类和类之间的联系，如一对一、一对多、多对多。其中有单向关联，双向关联。</strong> </p>
<p>代码体现：成员变量</p>
<p>UML符号：<strong>双向关联，一条实线或一条实线+两个箭头；单向关联，一条实线+一个箭头</strong> </p>
<p>一对一</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225341448.png" alt="image-20201022225341448" style="zoom:67%;" />

<p>其他：（图片来自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/419192424/answer/1471808645%EF%BC%89">https://www.zhihu.com/question/419192424/answer/1471808645）</a></p>
<p><img src="https://pic2.zhimg.com/80/v2-b880e61921fcc252b58a2a8da1baf368_720w.jpg?source=1940ef5c"></p>
<h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>聚合关系（Aggregation）表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开，即部分能脱离整体而独立存在</strong>。</p>
<p>代码体现：成员变量</p>
<p>UML符号：<strong>一条实线+空心菱形</strong> </p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022225828143.png" alt="image-20201022225828143" style="zoom:67%;" />

<h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>组合也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开，部分不能脱离整体而独立存在</strong>。</p>
<p>代码体现：成员变量</p>
<p>UML符号：<strong>一条实线+实心菱形</strong> </p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230156462.png" alt="image-20201022230156462" style="zoom:67%;" />

<h2 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h2><p>是一种使用关系，一个类的实现需要另一个类的协助。即在一个类中使用了另外一个类。<strong>尽量不要使用双向依赖。以上关系都是依赖关系的特例</strong>。</p>
<p>代码体现：局部变量、方法的参数或者对静态方法的调用。</p>
<p>UML符号：<strong>一条虚线+箭头</strong> </p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201022230737289.png" alt="image-20201022230737289" style="zoom:67%;" />



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vic_/p/8057851.html">https://www.cnblogs.com/vic_/p/8057851.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/419192424/answer/1471808645">https://www.zhihu.com/question/419192424/answer/1471808645</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">设计模式七大基本原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-04 00:00:06" itemprop="dateCreated datePublished" datetime="2021-03-04T00:00:06+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 23:59:54" itemprop="dateModified" datetime="2021-03-03T23:59:54+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式的七大原则如下：</p>
<ul>
<li>单一职责原则 (Single Responsibility Principle)</li>
<li>接口隔离原则 (Interface Segregation Principle)</li>
<li>开放-关闭原则 (Open-Closed Principle)</li>
<li>里氏替换原则 (Liskov Substitution Principle)</li>
<li>依赖倒转原则 (Dependence Inversion Principle)</li>
<li>迪米特法则（Law Of Demeter）</li>
<li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li>
</ul>
<h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>通俗地说，单一职责原则即<strong>一个类只负责一项职责（不是只有一个方法）</strong>。</p>
<p>假设某个类 P 负责两个不同的职责：职责 P1 和 职责 P2，那么当职责 P1 需求发生改变而需要修改类 P，有可能会导致原来运行正常的职责 P2 功能发生故障。</p>
<p>在实际编程中比较难严格的遵守该原则，可以作一些折中处理，比如若是一个类中方法个数比较少，可以在方法级别上遵守该原则（此时在类级别上可能不遵守）。<strong>只有逻辑足够简单，才可以在代码级别上违背单一职责原则</strong>。</p>
<p>单一职责原则的作用和细节：</p>
<ul>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>通常情况下，应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ul>
<h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>接口隔离原则指：<strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</strong>：</p>
<p>被依赖的类实现一个接口，就需要实现接口的所有方法，但这个类在被使用时可能只用到其中部分方法。也就是只要接口中出现的方法，不管依赖于它的类是否需要该方法，实现类都必须去实现这些方法，这就不符合接口隔离原则。可以对接口进行拆分，让实现类只实现需要的接口。</p>
<p>示例（见来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89%EF%BC%9A">https://zhuanlan.zhihu.com/p/24614363）：</a></p>
<img src="https://pic4.zhimg.com/80/v2-ec9b282b367e9c148a7963b5b23c60e7_720w.png" style="zoom:80%;" />

<p>类 A 依赖于 接口 I 中的方法 1，2，3 ，类 B 是对类 A 的具体实现。类 C 依赖接口 I 中的方法 1，4，5，类 D 是对类 C 的具体实现。对于类B和类D来说，<strong>虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。</strong> </p>
<p>用代码表示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line">	 <span class="comment">// 类 B 只需要实现方法 1，2, 3，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;  </span><br><span class="line">	<span class="comment">// 类 D 只需要实现方法 1，4，5，而其它方法它并不需要，但是也需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        A a = <span class="keyword">new</span> A();  </span><br><span class="line">        a.depend1(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());  </span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());  </span><br><span class="line">          </span><br><span class="line">        C c = <span class="keyword">new</span> C();  </span><br><span class="line">        c.depend1(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend2(<span class="keyword">new</span> D());  </span><br><span class="line">        c.depend3(<span class="keyword">new</span> D());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以对接口根据下图进行拆分：</p>
<img src="https://pic3.zhimg.com/80/v2-7611098e41bcfbf5113d978b47fc8466_720w.png" style="zoom:80%;" />

<p>代码可修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;  </span><br><span class="line">        i.method3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 B 实现接口 I2 的方法 3&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;  </span><br><span class="line">        i.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method4();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;  </span><br><span class="line">        i.method5();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I1 的方法 1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 4&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;类 D 实现接口 I3 的方法 5&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><strong>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</strong>。</li>
<li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
</ol>
<h2 id="依赖倒转原则（DIP）"><a href="#依赖倒转原则（DIP）" class="headerlink" title="依赖倒转原则（DIP）"></a>依赖倒转原则（DIP）</h2><p>定义：<strong>高层模块不应该依赖低层模块，二者都应该依赖于抽象</strong>。进一步说，<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。<strong>依赖倒转原则的核心思想就是面向接口编程</strong>。</p>
<p>依赖倒转原则是基于这样的设计理念：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给实现类去完成。</p>
<p>示例：（来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363%EF%BC%89">https://zhuanlan.zhihu.com/p/24614363）</a></p>
<p>一个场景：母亲给孩子讲故事，只要给她一本书，她就可照着书给孩子讲故事了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Book book)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(book.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>假如有一天，给的是一份报纸，而不是一本书，让这个母亲讲下报纸上的故事，报纸的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p><strong>显然这个母亲完成不了这个任务。只有将Mother类中的Book换成Newspaper才能完成</strong>。但若是以后换成杂志等其他读物，又得进行修改。原因是 Mother 和 Book之间的耦合度太高了。<strong>可以引入一个抽象接口 IReader表示读物，让书和报纸去实现这个接口，那么无论提供什么样的读物，该母亲都能读</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个一则重要的新闻&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是一个有趣的故事&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(IReader reader)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);  </span><br><span class="line">        System.out.println(reader.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Book());  </span><br><span class="line">        mother.say(<span class="keyword">new</span> Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个例子中，Mother类代表高层模块，读物相关的类则代表低层模块，在修改示例之前，是高层依赖于低层代码，Mother类要按着Book类来；修改后则符合依赖倒转原则，低层的读物依着高层的Mother来。</p>
<p><strong>实际情况中，代表高层模块的 Mother 类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒转原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险</strong>。</p>
<h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p><strong>面向对象中继承性的问题</strong>：有一功能 P1, 由类 A 完成，现需要将功能 P1 进行扩展，扩展后的功能为 P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则<strong>子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障</strong>。</p>
<p>里氏替换原则：</p>
<ul>
<li><strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li>
<li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法</strong>。</li>
<li><strong>子类中尽量不要重写父类的方法</strong>。</li>
</ul>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而<strong>里氏替换原则就是表达了这一层含义</strong>。</p>
<p>根据该原则，对于上述的继承性问题：当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能 P2，尽量不要修改父类方法预期的行为。</p>
<h2 id="开放-关闭原则（OCP）"><a href="#开放-关闭原则（OCP）" class="headerlink" title="开放-关闭原则（OCP）"></a>开放-关闭原则（OCP）</h2><p>**开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改。(Open for extension, close for modification，对扩展开放，对修改关闭)**。</p>
<p>一个软件满足 OCP 原则后的两项优点：</p>
<ol>
<li><strong>能够扩展已存在的系统</strong>，能够提供新的功能满足新的需求，因此该软件有着很强的适应性和灵活性。</li>
<li>已存在的模块，特别是那些重要的抽象模块，不需要被修改，那么该软件就有很强的稳定性和持久性。</li>
</ol>
<p>示例：</p>
<p>有个生产电脑的公司，根据输入的类型，生产出不同的电脑，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Computer c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;macbook&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Macbook();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;surface&quot;</span>))&#123;</span><br><span class="line">            c = <span class="keyword">new</span> Surface();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的代码违背了开放 - 关闭原则，<strong>如果需要添加新的电脑产品，需要修改 produceComputer 原本已有的方法</strong>，正确的方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Macbook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MSFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">produceComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Surface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的方式应该是将 Factory 抽象成接口，让具体的工厂(如苹果工厂，微软工厂)去实现它，生产它们公司相应的产品，这样写有利于扩展，如果这是需要新增加戴尔工厂生产戴尔电脑，我们仅仅需要创建新的电脑类和新的工厂类，而不需要去修改已经写好的代码。</p>
<p>总结：</p>
<ol>
<li><strong>OCP 可以具有良好的可扩展性，可维护性</strong>。</li>
<li><strong>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它</strong>。</li>
</ol>
<h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><p>迪米特法则又称为<strong>最少知道原则</strong>，它表示<strong>一个对象应该对其它对象保持最少的了解</strong>。**<font color="red">通俗来说就是，只与直接的朋友通信</font>**。</p>
<p><strong>什么是直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，<strong>称出现在成员变量、方法参数、方法返回值中的类为直接的朋友</strong>，而<strong>出现在局部变量中的类则不是直接的朋友</strong>。根据迪米特法则，**<font color="red">陌生的类最好不要作为局部变量的形式出现在类的内部</font>**。</p>
<p><strong>对于被依赖的类来说，无论逻辑多么复杂，都尽量的将逻辑封装在类的内部，对外提供 public 方法，不对泄漏任何信息</strong>。</p>
<p>示例：</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个 SchoolManager 对象 </span></span><br><span class="line">    SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager(); </span><br><span class="line">    <span class="comment">//输出学院员工id和学校员工id</span></span><br><span class="line">    schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学校员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工管理类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回学院的所有员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;CollegeEmployee&gt; list = newArrayList&lt;CollegeEmployee&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">            <span class="comment">//这里我们增加了 10 个员工到 </span></span><br><span class="line">            list CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123; </span><br><span class="line">    <span class="comment">//返回所有学校员工 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;Employee&gt; list = newArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">            list Employee emp = <span class="keyword">new</span> Employee(); </span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工 id= &quot;</span> + i); </span><br><span class="line">            list.add(emp);</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出学校和学院员工id</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//获取到学院员工 </span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">		&#125; </span><br><span class="line">        <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以看到SchoolManager的printAllEmployee方法中，<strong>CollegeEmployee并不是SchoolManager的直接朋友，不符合迪米特法则</strong>。</p>
<p>可以将打印CollegeEmployee部分的代码封装进CollegeManager中：</p>
<p>CollegeManager中添加新的public方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//获取到学院员工 </span></span><br><span class="line">    List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (CollegeEmployee e : list1) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而可以在SchoolManager中通过CollegeManager调用该方法来打印所有学院员工id，SchoolManager.printAllEmployee方法改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出学校和学院员工id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">	sub.printEmployee();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到学校总部员工 </span></span><br><span class="line">    List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee(); </span><br><span class="line">    System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (Employee e : list2) &#123; </span><br><span class="line">        System.out.println(e.getId());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="组合-聚合复用原则（CRP）"><a href="#组合-聚合复用原则（CRP）" class="headerlink" title="组合/聚合复用原则（CRP）"></a>组合/聚合复用原则（CRP）</h2><p>组合/聚合复用原则指的是<strong>在实际开发设计中，尽量使用组合/聚合，不要使用类继承</strong>。</p>
<p>在面向对象的设计中，<strong>如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类，如果基类的实现发生了改变，则子类的实现也不得不改变</strong>。</p>
<ul>
<li><p>总体说来，组合或者聚合好过于继承。</p>
</li>
<li><p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363">https://zhuanlan.zhihu.com/p/24614363</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/" class="post-title-link" itemprop="url">IDEA快捷键大全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-25 00:26:06 / 修改时间：00:28:01" itemprop="dateCreated datePublished" datetime="2021-02-25T00:26:06+08:00">2021-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>以下绝大部分copy自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p>
</blockquote>
<h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><span style="color:red;">Ctrl + F</span></strong></td>
<td align="left">在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + R</td>
<td align="left">在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Z</td>
<td align="left">撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Y</td>
<td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + X</td>
<td align="left">剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + C</td>
<td align="left">复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + D</td>
<td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + W</td>
<td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + E</td>
<td align="left">显示最近打开的文件记录列表</td>
</tr>
<tr>
<td align="left">Ctrl + N</td>
<td align="left">根据输入的 <strong>类名</strong> 查找类文件</td>
</tr>
<tr>
<td align="left">Ctrl + G</td>
<td align="left">在当前文件跳转到指定行处</td>
</tr>
<tr>
<td align="left">Ctrl + J</td>
<td align="left">插入自定义动态代码模板</td>
</tr>
<tr>
<td align="left">Ctrl + P</td>
<td align="left">方法参数提示显示</td>
</tr>
<tr>
<td align="left">Ctrl + Q</td>
<td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td align="left">Ctrl + U</td>
<td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td align="left">Ctrl + B</td>
<td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td>
</tr>
<tr>
<td align="left">Ctrl + K</td>
<td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + T</td>
<td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left"><strong>Ctrl + H</strong></td>
<td align="left"><strong>显示当前类的层次结构</strong></td>
</tr>
<tr>
<td align="left">Ctrl + O</td>
<td align="left">选择可重写的方法</td>
</tr>
<tr>
<td align="left">Ctrl + I</td>
<td align="left">选择可继承的方法</td>
</tr>
<tr>
<td align="left">Ctrl + +</td>
<td align="left">展开代码</td>
</tr>
<tr>
<td align="left">Ctrl + -</td>
<td align="left">折叠代码</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + [</td>
<td align="left">移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td align="left">Ctrl + ]</td>
<td align="left">移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td align="left">Ctrl + F1</td>
<td align="left">在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td align="left">Ctrl + F3</td>
<td align="left">调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td align="left">Ctrl + F4</td>
<td align="left">关闭当前编辑文件</td>
</tr>
<tr>
<td align="left">Ctrl + F8</td>
<td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td align="left">Ctrl + F9</td>
<td align="left">执行 Make Project 操作</td>
</tr>
<tr>
<td align="left">Ctrl + F11</td>
<td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td align="left">Ctrl + F12</td>
<td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td align="left">Ctrl + Tab</td>
<td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td align="left">Ctrl + Enter</td>
<td align="left">智能分隔行</td>
</tr>
<tr>
<td align="left">Ctrl + End</td>
<td align="left">跳到文件尾</td>
</tr>
<tr>
<td align="left">Ctrl + Home</td>
<td align="left">跳到文件头</td>
</tr>
<tr>
<td align="left">Ctrl + Space</td>
<td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Delete</td>
<td align="left">删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + BackSpace</td>
<td align="left">删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + 1,2,3…9</td>
<td align="left">定位到对应数值的书签位置</td>
</tr>
<tr>
<td align="left">Ctrl + 左键单击</td>
<td align="left">在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td align="left">Ctrl + 光标定位</td>
<td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td align="left">Ctrl + 左方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 右方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 前方向键</td>
<td align="left">等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td align="left">Ctrl + 后方向键</td>
<td align="left">等效于鼠标滚轮向后效果</td>
</tr>
</tbody></table>
<h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + `</td>
<td align="left">显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td align="left">Alt + Q</td>
<td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td align="left">Alt + F1</td>
<td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td align="left">Alt + F2</td>
<td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td align="left">Alt + F3</td>
<td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td align="left">Alt + F7</td>
<td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td align="left">Alt + F8</td>
<td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td align="left">Alt + Home</td>
<td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td align="left">Alt + Enter</td>
<td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Alt + Insert</td>
<td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td align="left">Alt + 左方向键</td>
<td align="left">按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 右方向键</td>
<td align="left">按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 前方向键</td>
<td align="left">当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 后方向键</td>
<td align="left">当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 1,2,3…9</td>
<td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
</tbody></table>
<h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Shift + F1</td>
<td align="left">如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td align="left">Shift + F2</td>
<td align="left">跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td align="left">Shift + F3</td>
<td align="left">在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td align="left">Shift + F4</td>
<td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td align="left">Shift + F6</td>
<td align="left">对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td align="left">Shift + F7</td>
<td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td align="left">Shift + F8</td>
<td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td align="left">Shift + F9</td>
<td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F10</td>
<td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F11</td>
<td align="left">弹出书签显示层</td>
</tr>
<tr>
<td align="left">Shift + Tab</td>
<td align="left">取消缩进</td>
</tr>
<tr>
<td align="left">Shift + ESC</td>
<td align="left">隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td align="left">Shift + End</td>
<td align="left">选中光标到当前行尾位置</td>
</tr>
<tr>
<td align="left">Shift + Home</td>
<td align="left">选中光标到当前行头位置</td>
</tr>
<tr>
<td align="left">Shift + Enter</td>
<td align="left">在当前行的下一行另起新行</td>
</tr>
<tr>
<td align="left">Shift+Alt+Enter</td>
<td align="left">在当前行的上一行另起新行</td>
</tr>
<tr>
<td align="left">Shift + 左键单击</td>
<td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
<tr>
<td align="left">Shift + 滚轮前后滚动</td>
<td align="left">当前文件的横向滚动轴滚动</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><span style="color:red;">Ctrl + Alt + L</span></strong></td>
<td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + O</td>
<td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + I</td>
<td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + T</td>
<td align="left">对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + J</td>
<td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + H</td>
<td align="left">调用层次</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + B</td>
<td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + V</td>
<td align="left">快速引进变量</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Y</td>
<td align="left">同步、刷新</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + S</td>
<td align="left">打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F7</td>
<td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F11</td>
<td align="left">切换全屏模式</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Enter</td>
<td align="left">光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Home</td>
<td align="left">弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Space</td>
<td align="left">类名自动完成</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 左方向键</td>
<td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 右方向键</td>
<td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 前方向键</td>
<td align="left">在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 后方向键</td>
<td align="left">在查找模式下，跳到下个查找的文件</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + F</td>
<td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + R</td>
<td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + J</td>
<td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Z</td>
<td align="left">取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + W</td>
<td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + N</td>
<td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + U</td>
<td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + T</td>
<td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + C</td>
<td align="left">复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + E</td>
<td align="left">显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + H</td>
<td align="left">显示方法层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + B</td>
<td align="left">跳转到类型声明处</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + I</td>
<td align="left">快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + A</td>
<td align="left">查找动作 / 设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + /</td>
<td align="left">代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + [</td>
<td align="left">选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + ]</td>
<td align="left">选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + +</td>
<td align="left">展开所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + -</td>
<td align="left">折叠所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F7</td>
<td align="left">高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F8</td>
<td align="left">在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F9</td>
<td align="left">编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F12</td>
<td align="left">编辑器最大化</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Space</td>
<td align="left">智能代码提示</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Enter</td>
<td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">退回到上次修改的地方</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 1,2,3…9</td>
<td align="left">快速添加指定数值的书签</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 前方向键</td>
<td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 后方向键</td>
<td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + Shift + N</td>
<td align="left">选择 / 添加 task</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td align="left">Alt + Shift + C</td>
<td align="left">查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">添加到收藏夹</td>
</tr>
<tr>
<td align="left">Alt + Shift + I</td>
<td align="left">查看项目当前文件</td>
</tr>
<tr>
<td align="left">Alt + Shift + F7</td>
<td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td align="left">Alt + Shift + F9</td>
<td align="left">弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + F10</td>
<td align="left">弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + 左键双击</td>
<td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td align="left">Alt + Shift + 前方向键</td>
<td align="left">移动光标所在行向上移动</td>
</tr>
<tr>
<td align="left">Alt + Shift + 后方向键</td>
<td align="left">移动光标所在行向下移动</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + Alt + V</td>
<td align="left">无格式黏贴</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + N</td>
<td align="left">前往指定的变量 / 方法</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + S</td>
<td align="left">打开当前项目设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + C</td>
<td align="left">复制参考信息</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">F2</td>
<td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">F3</td>
<td align="left">在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td align="left">F4</td>
<td align="left">编辑源</td>
</tr>
<tr>
<td align="left">F7</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td align="left">F8</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td align="left">F9</td>
<td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td align="left">F11</td>
<td align="left">添加书签</td>
</tr>
<tr>
<td align="left">F12</td>
<td align="left">回到前一个工具窗口</td>
</tr>
<tr>
<td align="left">Tab</td>
<td align="left">缩进</td>
</tr>
<tr>
<td align="left">ESC</td>
<td align="left">从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td align="left">连按两次Shift</td>
<td align="left">弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/idea%E5%B8%B8%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/idea%E5%B8%B8%E7%94%A8/" class="post-title-link" itemprop="url">IDEA常用快捷键&操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 00:26:06" itemprop="dateCreated datePublished" datetime="2021-02-25T00:26:06+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 00:17:23" itemprop="dateModified" datetime="2021-03-06T00:17:23+08:00">2021-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;&emsp;</p>
<ul>
<li>ctrl+w：逐渐向外层选中</li>
<li>CTRL+shift+上下：当前行上下移</li>
<li>SHIFT+F10：运行main</li>
<li>CTRL+F2：停止运行</li>
<li>shift+esc：关闭下方窗口</li>
<li>CTRL+shift+左右：跳转至上/下一个方法（上/下一个历史光标位置）</li>
<li>CTRL+F12：弹出窗口形式查看当前类的所有方法</li>
<li>Alt+7：左边小窗口查看当前类所有方法</li>
<li>SHIFT + F2：定位到报错处（红线）</li>
<li>CTRL + R：替换指定文本。</li>
<li>SHIFT + F6：批量修改变量、方法名。</li>
<li>CTRL + ALT + V：抽取变量（<strong>已改为ALT + X</strong>）</li>
<li>CTRL + ALT + B/左键：方法具体实现</li>
<li>CTRL + ALT + M：将选中代码提取为方法</li>
<li>CTRL + ALT + P：抽取为方法参数，并修改方法被引用的地方</li>
<li>ALT + 1：打开Project 窗口。</li>
<li>CTRL + E：最近文件窗口。</li>
<li>CTRL + P：方法、构造器参数提示。</li>
<li>ALT + F7：查看指定方法/变量等被引用的次数和位置。</li>
</ul>
<p>&emsp;&emsp;</p>
<ul>
<li><p>debug时，下方的Frames窗口对应虚拟机栈，其中每个项就是一个栈帧（对应一个方法），右边的Variables对应该栈帧的局部变量表。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209202217531.png" alt="image-20210209202217531"></p>
</li>
<li><p>多个线程下调试时，右键断电，选择Thread</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212458998.png" alt="image-20210209212458998"></p>
<p>此时在此时选择线程：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210209212821981.png" alt="image-20210209212821981"></p>
</li>
<li><p>debug过程可以修改变量的值：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210222235056874.png" alt="image-20210222235056874"></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">IDEA的一些使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-25 00:23:26 / 修改时间：00:27:24" itemprop="dateCreated datePublished" datetime="2021-02-25T00:23:26+08:00">2021-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>该笔记基于IDEA-2019版本</p>
</blockquote>
<h2 id="提高运行速度"><a href="#提高运行速度" class="headerlink" title="提高运行速度"></a>提高运行速度</h2><p>在idea安装目录的bin目录下的idea.exe.vmoptions文件，调整<code>Xms</code>跟<code>Xmx</code>两个参数的值可提高运行速度，但要注意电脑的运行内存是否足够。</p>
<h2 id="恢复默认设置"><a href="#恢复默认设置" class="headerlink" title="恢复默认设置"></a>恢复默认设置</h2><p>在用户目录中，有一个<code>.IntelliJIdea2019.3</code>目录，该目录下有个<code>config</code>跟一个<code>system</code>目录，前者存放关于IDEA一些设置相关的配置文件。可以通过将这两个目录删除来实现恢复默认设置（在重启idea时会自动创建这两个文件，但之前设置的快捷键、模板等将被重置）。</p>
<h2 id="工具条"><a href="#工具条" class="headerlink" title="工具条"></a>工具条</h2><p>【View】-》【Appearance】-》【选中Tool Bar】，打开工具条。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200814222041.png"></p>
<h2 id="IDEA中的Project和Module"><a href="#IDEA中的Project和Module" class="headerlink" title="IDEA中的Project和Module"></a>IDEA中的Project和Module</h2><p>参考链接：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/65448689">https://blog.csdn.net/qq_35246620/article/details/65448689</a> </p>
</blockquote>
<p>在 IntelliJ IDEA 中<code>Project</code>是最顶级的结构单元，然后就是<code>Module</code>，一个<code>Project</code>可以有多个<code>Module</code>。</p>
<p>一个<code>Project</code>是由一个或多个<code>Module</code>组成，</p>
<ul>
<li>当为单<code>Module</code>项目的时候，这个单独的<code>Module</code>实际上就是一个<code>Project</code>；</li>
<li>当为多<code>Module</code>项目的时候，多个模块处于同一个<code>Project</code>之中，此时彼此之间具有互相依赖的关联关系。</li>
</ul>
<p>此外， IntelliJ IDEA 的<code>Project</code>是一个不具备任何编码设置、构建等开发功能的概念，其主要作用就是起到一个项目定义、范围约束、规范类型的效果，这个目录在命名上应该有其代表性的意义。在缺省情况下，IntelliJ IDEA 是默认单<code>Project</code>单<code>Module</code>的，这时<code>Project</code>和<code>Module</code>合二为一。</p>
<p>要删除Module时，需要进入<code>Project Structure</code>，在左边选择<code>Modules</code>，右边视图中选中要删除的Module，点击上方的<code>-</code>（或右键delete）即可。此时在项目中移除了对应Module，但在磁盘中没有删除Module对应目录，需手动删除。</p>
<p><strong>在一个Module中，可以通过在本Module的imi文件中配置引入其他Module的内容</strong>。可以使用<code>Alt+Enter</code>的提示功能自动配置。</p>
<h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><h3 id="鼠标悬停显示文档"><a href="#鼠标悬停显示文档" class="headerlink" title="鼠标悬停显示文档"></a>鼠标悬停显示文档</h3><p>【Settings】-》【Editor】-》【General】-》【视图右边滑到最下面，勾上<code>show quik documentation on mouse move</code>】</p>
<p>下方的Tooltip delay设置延迟时间。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145751019.png" alt="image-20200815145751019" style="zoom:67%;" />

<h3 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135642.png" style="zoom:67%;" />



<h3 id="显示方法间的分隔符"><a href="#显示方法间的分隔符" class="headerlink" title="显示方法间的分隔符"></a>显示方法间的分隔符</h3><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/20200815135936.png"></p>
<h3 id="忽略大小写提示的差别"><a href="#忽略大小写提示的差别" class="headerlink" title="忽略大小写提示的差别"></a>忽略大小写提示的差别</h3><p>如图取消勾选即可。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815140939775.png" alt="image-20200815140939775"></p>
<p>效果：输入S跟s的提示将变的一样。</p>
<h3 id="多个文件的标签多行显示"><a href="#多个文件的标签多行显示" class="headerlink" title="多个文件的标签多行显示"></a>多个文件的标签多行显示</h3><p>打开多个文件时，让多个文件的标签分成多行显示。如图，取消勾选。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141445072.png" alt="image-20200815141445072" style="zoom:80%;" />





<h3 id="设置代码编辑区各部分样式"><a href="#设置代码编辑区各部分样式" class="headerlink" title="设置代码编辑区各部分样式"></a>设置代码编辑区各部分样式</h3><p>设置如单行注释、多行注释、方法等字体的样式。在框框内点击不同位置可自动跳转到对应的设置。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815141938283.png" alt="image-20200815141938283" style="zoom: 67%;" />



<h3 id="当导入同一个包的类超过多少时使用"><a href="#当导入同一个包的类超过多少时使用" class="headerlink" title="当导入同一个包的类超过多少时使用*"></a>当导入同一个包的类超过多少时使用<code>*</code></h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815142453764.png" alt="image-20200815142453764" style="zoom: 67%;" />



<h3 id="设置类的头部信息"><a href="#设置类的头部信息" class="headerlink" title="设置类的头部信息"></a>设置类的头部信息</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143009247.png" alt="image-20200815143009247" style="zoom:67%;" />



<h3 id="设置编码（全局）"><a href="#设置编码（全局）" class="headerlink" title="设置编码（全局）"></a>设置编码（全局）</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815143239051.png" alt="image-20200815143239051" style="zoom:67%;" />



<h3 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h3><p>也可同时勾上框框第二项，启动多模块并行编译。但会占用更多内存。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815144738928.png" alt="image-20200815144738928" style="zoom:67%;" />



<h3 id="多个代码文件垂直-水平显示"><a href="#多个代码文件垂直-水平显示" class="headerlink" title="多个代码文件垂直/水平显示"></a>多个代码文件垂直/水平显示</h3><p>右键标签页，如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145150886.png" alt="image-20200815145150886" style="zoom: 80%;" />

<p>效果：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815145304470.png" alt="image-20200815145304470" style="zoom: 67%;" />

<h3 id="CTRL-插入注释时带缩进"><a href="#CTRL-插入注释时带缩进" class="headerlink" title="CTRL+/ 插入注释时带缩进"></a><code>CTRL+/</code> 插入注释时带缩进</h3><p>设置Java文件：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135428506.png" alt="image-20200818135428506" style="zoom:67%;" />

<p>XML文件同理：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200818135625076.png" alt="image-20200818135625076" style="zoom:67%;" />



<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/VariatioZbw/article/details/105626147">https://blog.csdn.net/VariatioZbw/article/details/105626147</a></p>
</blockquote>
<h3 id="为main方法传递参数"><a href="#为main方法传递参数" class="headerlink" title="为main方法传递参数"></a>为main方法传递参数</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013713294/article/details/53020293">https://blog.csdn.net/u013713294/article/details/53020293</a></p>
</blockquote>
<p>有时需要使用main方法的args参数，而为args参数赋值一般在命令行中，如下：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java <span class="comment">//编译</span></span><br><span class="line">java Test para<span class="name">m1</span> para<span class="name">m2</span> para<span class="name">m3</span> ... <span class="comment">//运行Test类，param是传递给main方法的参数</span></span><br></pre></td></tr></table></figure>



<p>在idea中可以设置参数，在main方法运行时把这些参数传递给它，步骤如下：</p>
<ol>
<li><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213818332.png" style="zoom:80%;" />

<p>或</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924213902857.png" style="zoom:80%;" />
</li>
<li><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924214508649.png" alt="image-20200924214508649"></p>
<p>点击OK，运行main方法时即会传入设置的参数。</p>
</li>
</ol>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815152625644.png" alt="image-20200815152625644" style="zoom: 80%;" />

<p>查看/修改快捷键：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200815233545855.png" alt="image-20200815233545855" style="zoom: 67%;" />



<p><strong>快捷键大全</strong>：</p>
<blockquote>
<p>以下大部分来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38963960/article/details/89552704">https://blog.csdn.net/qq_38963960/article/details/89552704</a></p>
</blockquote>
<h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + F</td>
<td align="left">在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + R</td>
<td align="left">在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Z</td>
<td align="left">撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Y</td>
<td align="left">删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + X</td>
<td align="left">剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + C</td>
<td align="left">复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td align="left">Ctrl + D</td>
<td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + W</td>
<td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + E</td>
<td align="left">显示最近打开的文件记录列表</td>
</tr>
<tr>
<td align="left">Ctrl + N</td>
<td align="left">根据输入的 <strong>类名</strong> 查找类文件</td>
</tr>
<tr>
<td align="left">Ctrl + G</td>
<td align="left">在当前文件跳转到指定行处</td>
</tr>
<tr>
<td align="left">Ctrl + J</td>
<td align="left">插入自定义动态代码模板</td>
</tr>
<tr>
<td align="left">Ctrl + P</td>
<td align="left">方法参数提示显示</td>
</tr>
<tr>
<td align="left">Ctrl + Q</td>
<td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td align="left">Ctrl + U</td>
<td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td align="left">Ctrl + B</td>
<td align="left">进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td>
</tr>
<tr>
<td align="left">Ctrl + K</td>
<td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + T</td>
<td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td align="left">Ctrl + H</td>
<td align="left">显示当前类的层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + O</td>
<td align="left">选择可重写的方法</td>
</tr>
<tr>
<td align="left">Ctrl + I</td>
<td align="left">选择可继承的方法</td>
</tr>
<tr>
<td align="left">Ctrl + +</td>
<td align="left">展开代码</td>
</tr>
<tr>
<td align="left">Ctrl + -</td>
<td align="left">折叠代码</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + [</td>
<td align="left">移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td align="left">Ctrl + ]</td>
<td align="left">移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td align="left">Ctrl + F1</td>
<td align="left">在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td align="left">Ctrl + F3</td>
<td align="left">调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td align="left">Ctrl + F4</td>
<td align="left">关闭当前编辑文件</td>
</tr>
<tr>
<td align="left">Ctrl + F8</td>
<td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td align="left">Ctrl + F9</td>
<td align="left">执行 Make Project 操作</td>
</tr>
<tr>
<td align="left">Ctrl + F11</td>
<td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td align="left">Ctrl + F12</td>
<td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td align="left">Ctrl + Tab</td>
<td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td align="left">Ctrl + Enter</td>
<td align="left">智能分隔行</td>
</tr>
<tr>
<td align="left">Ctrl + End</td>
<td align="left">跳到文件尾</td>
</tr>
<tr>
<td align="left">Ctrl + Home</td>
<td align="left">跳到文件头</td>
</tr>
<tr>
<td align="left">Ctrl + Space</td>
<td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Delete</td>
<td align="left">删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + BackSpace</td>
<td align="left">删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td align="left">Ctrl + 1,2,3…9</td>
<td align="left">定位到对应数值的书签位置</td>
</tr>
<tr>
<td align="left">Ctrl + 左键单击</td>
<td align="left">在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td align="left">Ctrl + 光标定位</td>
<td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td align="left">Ctrl + 左方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 右方向键</td>
<td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td align="left">Ctrl + 前方向键</td>
<td align="left">等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td align="left">Ctrl + 后方向键</td>
<td align="left">等效于鼠标滚轮向后效果</td>
</tr>
</tbody></table>
<h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + `</td>
<td align="left">显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td align="left">Alt + Q</td>
<td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td align="left">Alt + F1</td>
<td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td align="left">Alt + F2</td>
<td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td align="left">Alt + F3</td>
<td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td align="left">Alt + F7</td>
<td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td align="left">Alt + F8</td>
<td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td align="left">Alt + Home</td>
<td align="left">定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td align="left">Alt + Enter</td>
<td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Alt + Insert</td>
<td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td align="left">Alt + 左方向键</td>
<td align="left">按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 右方向键</td>
<td align="left">按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td align="left">Alt + 前方向键</td>
<td align="left">当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 后方向键</td>
<td align="left">当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td align="left">Alt + 1,2,3…9</td>
<td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
<tr>
<td align="left">Alt + 7</td>
<td align="left">显示当前类的所有方法、成员变量等</td>
</tr>
</tbody></table>
<h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Shift + F1</td>
<td align="left">如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td align="left">Shift + F2</td>
<td align="left">跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td align="left">Shift + F3</td>
<td align="left">在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td align="left">Shift + F4</td>
<td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td align="left">Shift + F6</td>
<td align="left">对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td align="left">Shift + F7</td>
<td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td align="left">Shift + F8</td>
<td align="left">在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td align="left">Shift + F9</td>
<td align="left">等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F10</td>
<td align="left">等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td align="left">Shift + F11</td>
<td align="left">弹出书签显示层</td>
</tr>
<tr>
<td align="left">Shift + Tab</td>
<td align="left">取消缩进</td>
</tr>
<tr>
<td align="left">Shift + ESC</td>
<td align="left">隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td align="left">Shift + End</td>
<td align="left">选中光标到当前行尾位置</td>
</tr>
<tr>
<td align="left">Shift + Home</td>
<td align="left">选中光标到当前行头位置</td>
</tr>
<tr>
<td align="left">Shift + Enter</td>
<td align="left">在当前行的下一行另起新行</td>
</tr>
<tr>
<td align="left">Shift+Alt+Enter</td>
<td align="left">在当前行的上一行另起新行</td>
</tr>
<tr>
<td align="left">Shift + 左键单击</td>
<td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
<tr>
<td align="left">Shift + 滚轮前后滚动</td>
<td align="left">当前文件的横向滚动轴滚动</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Alt + L</td>
<td align="left">格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + O</td>
<td align="left">优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + I</td>
<td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + T</td>
<td align="left">对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + J</td>
<td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + H</td>
<td align="left">调用层次</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + B</td>
<td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + V</td>
<td align="left">快速引进变量</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Y</td>
<td align="left">同步、刷新</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + S</td>
<td align="left">打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F7</td>
<td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + F11</td>
<td align="left">切换全屏模式</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Enter</td>
<td align="left">光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Home</td>
<td align="left">弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Space</td>
<td align="left">类名自动完成</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 左方向键</td>
<td align="left">退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 右方向键</td>
<td align="left">前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 前方向键</td>
<td align="left">在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + 后方向键</td>
<td align="left">在查找模式下，跳到下个查找的文件</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + F</td>
<td align="left">根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + R</td>
<td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + J</td>
<td align="left">自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Z</td>
<td align="left">取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + W</td>
<td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + N</td>
<td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + U</td>
<td align="left">对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + T</td>
<td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + C</td>
<td align="left">复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + E</td>
<td align="left">显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + H</td>
<td align="left">显示方法层次结构</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + B</td>
<td align="left">跳转到类型声明处</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + I</td>
<td align="left">快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + A</td>
<td align="left">查找动作 / 设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + /</td>
<td align="left">代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + [</td>
<td align="left">选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + ]</td>
<td align="left">选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + +</td>
<td align="left">展开所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + -</td>
<td align="left">折叠所有代码</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F7</td>
<td align="left">高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F8</td>
<td align="left">在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F9</td>
<td align="left">编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + F12</td>
<td align="left">编辑器最大化</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Space</td>
<td align="left">智能代码提示</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Enter</td>
<td align="left">自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">退回到上次修改的地方</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 1,2,3…9</td>
<td align="left">快速添加指定数值的书签</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 左方向键</td>
<td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 右方向键</td>
<td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 前方向键</td>
<td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + 后方向键</td>
<td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt + Shift + N</td>
<td align="left">选择 / 添加 task</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td align="left">Alt + Shift + C</td>
<td align="left">查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td align="left">Alt + Shift + F</td>
<td align="left">添加到收藏夹</td>
</tr>
<tr>
<td align="left">Alt + Shift + I</td>
<td align="left">查看项目当前文件</td>
</tr>
<tr>
<td align="left">Alt + Shift + F7</td>
<td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td align="left">Alt + Shift + F9</td>
<td align="left">弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + F10</td>
<td align="left">弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td align="left">Alt + Shift + 左键双击</td>
<td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td align="left">Alt + Shift + 前方向键</td>
<td align="left">移动光标所在行向上移动</td>
</tr>
<tr>
<td align="left">Alt + Shift + 后方向键</td>
<td align="left">移动光标所在行向下移动</td>
</tr>
</tbody></table>
<h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + Shift + Alt + V</td>
<td align="left">无格式黏贴</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + N</td>
<td align="left">前往指定的变量 / 方法</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + S</td>
<td align="left">打开当前项目设置</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Alt + C</td>
<td align="left">复制参考信息</td>
</tr>
</tbody></table>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">F2</td>
<td align="left">跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td align="left">F3</td>
<td align="left">在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td align="left">F4</td>
<td align="left">编辑源</td>
</tr>
<tr>
<td align="left">F7</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td align="left">F8</td>
<td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td align="left">F9</td>
<td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td align="left">F11</td>
<td align="left">添加书签</td>
</tr>
<tr>
<td align="left">F12</td>
<td align="left">回到前一个工具窗口</td>
</tr>
<tr>
<td align="left">Tab</td>
<td align="left">缩进</td>
</tr>
<tr>
<td align="left">ESC</td>
<td align="left">从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td align="left">连按两次Shift</td>
<td align="left">弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody></table>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>查看/设置模板：</p>
<p>Live Templates中可以查看、<strong>编辑、添加以及删除</strong>模板：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142838850.png" alt="image-20200816142838850" style="zoom:80%;" />



<p>Postfix Completion中只能查看、禁用。下图的Before框表示模板的预定义形式，After表示输出效果。比如下图的例子，输入<code>foo.forr</code>，摁下enter。将输出after框的模板。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816142928743.png" alt="image-20200816142928743" style="zoom:67%;" />



<h3 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816153643738.png" alt="image-20200816153643738" style="zoom: 80%;" />

<p>如上图操作，输入模板组名，确定。选中创建的模板组，点击<code>+</code>，点击<code>Live Template</code>在组中添加新模板。</p>
<p>设置新模板：</p>
<ul>
<li>1处填写模板缩写</li>
<li>2处填写模板的描述</li>
<li>3处定义模板内容。<strong>例子中模板的意义：</strong>输入test按下enter出现模板后，光标会跳至<code>$var1$</code>位置，输入完成后按enter，光标跳至<code>$var2$</code>处。</li>
</ul>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154245765.png" alt="image-20200816154245765"></p>
<p>下一步，点击define，选择java：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200816154543995.png" alt="image-20200816154543995" style="zoom:67%;" />



<p>点击OK即可。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200821195633214.png" alt="image-20200821195633214" style="zoom:67%;" />



<h3 id="idea自带模板"><a href="#idea自带模板" class="headerlink" title="idea自带模板"></a>idea自带模板</h3><table>
<thead>
<tr>
<th>Before</th>
<th align="left">After</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>psvm</code></td>
<td align="left"><code>public static void main(String[] args) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>sout</code></td>
<td align="left"><code>System.out.println();</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>soutm</code></td>
<td align="left"><code>System.out.println(&quot;当前方法的全限定名&quot;);</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>soutp</code></td>
<td align="left"><code>System.out.println(&quot;c = &quot; + c);</code></td>
<td align="left">以<code>valueName=value</code><br>的形式输出</td>
</tr>
<tr>
<td><code>soutv</code></td>
<td align="left">与上同</td>
<td align="left">输出某一变量</td>
</tr>
<tr>
<td><code>variable.sout</code></td>
<td align="left"><code>System.out.println(variable);</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>fori</code> （<strong>递增</strong>）</td>
<td align="left"><code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></td>
<td align="left">输入完成后光标跳至第一个i后<br>可改变变量名；按enter光标跳至&lt;后<br>再按enter跳至<code>&#123;&#125;</code>中</td>
</tr>
<tr>
<td><code>arrs/List/Set.fori</code></td>
<td align="left"><code>for (int i = 0; i &lt; xxx.size(); i++) &#123;&#125;</code></td>
<td align="left">可对数组、集合使用。</td>
</tr>
<tr>
<td><code>forr</code>（递减）</td>
<td align="left">与上同理</td>
<td align="left"></td>
</tr>
<tr>
<td><code>arrs/List/Set.forr</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td><code>iter</code></td>
<td align="left"><code>for (T t : arrs) &#123;&#125;</code></td>
<td align="left">对某一数组使用forEach循环</td>
</tr>
<tr>
<td><code>arrs.iter</code></td>
<td align="left">同上</td>
<td align="left">对指定数组使用forEach循环</td>
</tr>
<tr>
<td><code>itar</code></td>
<td align="left"><code>for (int i = 0; i &lt; arr.length; i++) &#123;int i1 =arr[i];&#125;</code></td>
<td align="left">对代码中上一个数组使用普通for循环</td>
</tr>
<tr>
<td><code>ifn</code></td>
<td align="left"><code>if (xxx == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>value.null</code></td>
<td align="left"><code>if (value == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>inn</code> （if not null）</td>
<td align="left"><code>if (st != null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>value.nn</code></td>
<td align="left"><code>if (value == null) &#123;&#125;</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>prsf</code></td>
<td align="left"><code>private static final</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psfi</code></td>
<td align="left"><code>public static final int</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psfs</code></td>
<td align="left"><code>public static final String</code></td>
<td align="left"></td>
</tr>
<tr>
<td><code>psf</code></td>
<td align="left"><code>public static final</code></td>
<td align="left"></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="快捷创建Mybatis主配置文件"><a href="#快捷创建Mybatis主配置文件" class="headerlink" title="快捷创建Mybatis主配置文件"></a>快捷创建Mybatis主配置文件</h3><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130058653.png" alt="image-20200914130058653" style="zoom: 80%;" />



<p>填写Name以及文件类型（Extension），并在方框内写入初始代码：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130320437.png" alt="image-20200914130320437"></p>
<p>Apply，即完成模板设置。</p>
<p>右键New创建文件时，即可看到创建的模板：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200914130454583.png" alt="image-20200914130454583" style="zoom:80%;" />





<h2 id="版本控制（git）"><a href="#版本控制（git）" class="headerlink" title="版本控制（git）"></a>版本控制（git）</h2><h3 id="克隆GitHub的项目到idea中"><a href="#克隆GitHub的项目到idea中" class="headerlink" title="克隆GitHub的项目到idea中"></a>克隆GitHub的项目到idea中</h3><p>1.先在idea中配置好git安装目录：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817131825434.png" style="zoom: 67%;" />



<p>2.添加GitHub账户</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817132350071.png" alt="image-20200817132350071" style="zoom: 67%;" />



<p>3.从GitHub上clone仓库：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134058705.png" alt="image-20200817134058705" style="zoom:80%;" />

<p>或者：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134723950.png" alt="image-20200817134723950" style="zoom:80%;" />

<p>4.填写仓库信息</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134256096.png" alt="image-20200817134256096" style="zoom:80%;" />



<p>5.是否为clone的仓库创建新项目，选择yes：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817134413600.png" alt="image-20200817134413600" style="zoom:67%;" />

<p>后面是创建项目的一些选项，此处省略。</p>
<p>完成。</p>
<p>6.clone后，在idea中左侧的项目框右键：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135922566.png" alt="image-20200817135922566" style="zoom:67%;" />

<p>即可看到git的各种操作。</p>
<p>没有add的文件在idea中会显示为红色。</p>
<h3 id="将本地项目Share到GitHub"><a href="#将本地项目Share到GitHub" class="headerlink" title="将本地项目Share到GitHub"></a>将本地项目Share到GitHub</h3><p>这种方式将会在GitHub创建一个仓库，并将项目push到该仓库。</p>
<p>步骤：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817135325861.png" alt="image-20200817135325861" style="zoom:80%;" />



<p>后续步骤简单，省略。</p>
<h2 id="Idea自带的文件修改历史功能"><a href="#Idea自带的文件修改历史功能" class="headerlink" title="Idea自带的文件修改历史功能"></a>Idea自带的文件修改历史功能</h2><p>右键一个文件-》【Local History】=》【show History】，即可看到文件的修改历史。</p>
<p>本地历史的相关信息保存在<code>C:\User\.IntelliJIdea2019.3\system\LocalHistory</code>下。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>调试的界面和各种按钮，<strong>鼠标悬停在按钮上可查看快捷键信息</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141152314.png" alt="image-20200817141152314" style="zoom:80%;" />

<p><strong>各种操作的含义</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817140516654.png" alt="image-20200817140516654" style="zoom: 67%;" />



<h3 id="为断点添加条件"><a href="#为断点添加条件" class="headerlink" title="为断点添加条件"></a>为断点添加条件</h3><p>即在该断点停止的条件是满足设置的条件。</p>
<p>例子：</p>
<p>创建一个for循环，并在输出语句添加断点：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141741524.png" alt="image-20200817141741524" style="zoom:80%;" />

<p>右键断点，在condition中设置条件：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817141829128.png" alt="image-20200817141829128" style="zoom:80%;" />

<p>启动Debug，停止时i的值是60：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817142010635.png" alt="image-20200817142010635" style="zoom:67%;" />



<h3 id="调试过程中查看变量的值"><a href="#调试过程中查看变量的值" class="headerlink" title="调试过程中查看变量的值"></a>调试过程中查看变量的值</h3><p>基本数据类型的值可直接在界面上查看，如上述例子。对于引用类型变量，若要查看具体的属性信息，可将鼠标悬停在变量上，点击<code>+</code>即可查看。</p>
<h2 id="创建Javadoc文档"><a href="#创建Javadoc文档" class="headerlink" title="创建Javadoc文档"></a>创建Javadoc文档</h2><p>步骤：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817150847896.png" alt="image-20200817150847896" style="zoom:80%;" />



<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200817151557958.png" alt="image-20200817151557958" style="zoom:67%;" />



<p><strong>PS</strong>：命令行参数中，指定的字符集要和项目的字符集一致。</p>
<h2 id="清除缓存和索引"><a href="#清除缓存和索引" class="headerlink" title="清除缓存和索引"></a>清除缓存和索引</h2><p>IDEA首次加载项目时会创建索引。</p>
<p>IntelliJ IDEA的缓存和索引<strong>主要是用来加快文件查询， 从而加快各种查找、代码提示等操作的速度</strong>。但是， IntelliJ IDEA的索引和缓存并不是一直会良好地支持IntelliJ IDEA的，某些特殊条件下， IntelliJ IDEA的缓存和索引文件也是会损坏的， 比如：断电、蓝屏引起的强制关机， 当你重新打开IntelliJ IDEA， 很可能Intell IDEA会报各种莫名其妙错误。这种情况可以清理下缓存和索引。如下：</p>
<p>【File】-》【Invalidate cache/Restart】，选择invalidate and restart。</p>
<p>或者将<code>C:\User\.IntelliJIdea2019.3\system</code>文件删除（需要idea先关闭），并再次启动idea，等待其重新创建索引即可。</p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="下载maven导入jar包的源码和依赖"><a href="#下载maven导入jar包的源码和依赖" class="headerlink" title="下载maven导入jar包的源码和依赖"></a>下载maven导入jar包的源码和依赖</h3><p>点击右侧边栏的maven，如图：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215147737.png" alt="image-20200820215147737" style="zoom:80%;" />

<p>选择<code>Download Sources</code>下载源码的jar包；选择<code>Download Documentation</code>下载说明文档（javadoc文件）；或者两者都下载。</p>
<p>打开maven的仓库目录，按下图找到对应目录：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215358815.png" alt="image-20200820215358815" style="zoom: 80%;" />



<p>如该图中到仓库下的<code>com\google\protobuf\protobuf-java\3.11.4</code>目录下，可看见下载的javadoc和sources的jar包。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200820215629801.png" alt="image-20200820215629801" style="zoom: 80%;" />



<h3 id="maven项目构建可执行jar包（包含导入的依赖）"><a href="#maven项目构建可执行jar包（包含导入的依赖）" class="headerlink" title="maven项目构建可执行jar包（包含导入的依赖）"></a>maven项目构建可执行jar包（包含导入的依赖）</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dzblog/p/6913809.html">https://www.cnblogs.com/dzblog/p/6913809.html</a></p>
</blockquote>
<ol>
<li><p>pom.xml文件中配置插件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此处指定main方法入口的class --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>包含main方法的入口类全限定名<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行package命令：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20200924215425450.png" alt="image-20200924215425450"></p>
</li>
<li><p>在target目录下即可看见项目的包含依赖的可执行jar包。</p>
</li>
</ol>
<blockquote>
<p>不包含依赖、包含部分依赖的打包方式见参考链接。</p>
</blockquote>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">多线程笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 00:21:20" itemprop="dateCreated datePublished" datetime="2021-02-25T00:21:20+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:06:42" itemprop="dateModified" datetime="2021-03-20T20:06:42+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>一个程序进入内存运行时，即变成一个进程。进程是代码在数据集合上的一次运行活动；<strong>进程是系统进行资源分配和调度的一个独立单位</strong>。 </p>
<p>进程的三个特征：</p>
<ul>
<li><strong>独立性</strong>：拥有独立的资源、私有的地址空间。未经允许的情况下，一个进程不能直接访问其他的进程。</li>
<li><strong>动态性</strong>：程序是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程具有自己的生命周期和各种不同状态。</li>
<li><strong>并发性</strong>：多个进程可以在单个处理器上并发执行，进程之间不会互相影响。</li>
</ul>
<p>并发和并行：</p>
<ul>
<li>并发：指同一时刻，只有一条指令执行，但多个进程指令快速轮换执行。<strong>CPU执行指令即为并发执行</strong>。“<strong>微观串行，宏观并行</strong>”。（单核CPU）</li>
<li>并行：同一时刻多个指令同时执行（多核CPU）。</li>
<li>对于多核OS，既有并行又有并发。</li>
</ul>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2) 线程"></a>2) 线程</h4><p><strong>线程是进程中的一个实体，线程本身是不会独立存在的</strong>。线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p>
<p>操作系统在分配资源时是把资源分配给进程的的， 但是<strong>CPU资源是被分配到线程的， 因为真正要占用CPU运行的是线</strong>程，所以也说<strong>线程是CPU分配的基本单位</strong>。在Java中，<strong>当启动main函数时其实就启动了一个JVM的进程， 而main函数所在的线程就是这个进程中的一个线程，也称主线程</strong>。</p>
<p>&emsp;&emsp;</p>
<p>一个进程可以同时并发处理多个任务（即执行多个线程）。线程也被称作轻量级进程。线程是进程的执行单元。<strong>线程是一个指令流</strong>。</p>
<p><strong>于绝大多数的应用程序来说，通常仅要求有一个主线程，但也可以在该进程内创建多条顺序执行流，这些顺序执行流就是线程，每个线程也是互相独立的。</strong>   </p>
<ul>
<li><strong>线程拥有自己的堆栈、自己的程序计数器和自己的局部变量</strong>，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。多个线程共享父进程里的全部资源，需要确保线程不会妨碍同一进程里的其他线程。</li>
<li>线程是独立运行的，它并不知道进程中是否还有其他线程存在。<strong>线程的执行是抢占式</strong>(当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。)</li>
<li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li>
<li>多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行.</li>
<li>线程的调度和管理由进程本身负责完成。</li>
<li>一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程.</li>
</ul>
<p><strong><em>归纳</em></strong>：<br><strong>操作系统可以同时执行多个任务，每个任务即为一个进程；进程可同时执行多个任务，每个任务即为一个线程。单线程只有一个顺序执行流，多线程有多个，多个顺序流之间互不干扰。</strong></p>
<h3 id="多线程相比于多进程的优势"><a href="#多线程相比于多进程的优势" class="headerlink" title="多线程相比于多进程的优势"></a>多线程相比于多进程的优势</h3><p>（为什么使用多线程而不是用多进程）</p>
<ul>
<li>进程中线程隔离程度小，使得多线程程序并发性高。</li>
<li>进程之间不能共享内存，而线程可以，运行效率高。</li>
<li>创建进程系统需为该进程分配独立内存空间，并分配大量资源，而创建线程代价小得多。</li>
<li>Java语言内置多线程功能支持。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>从方法调用的角度来讲，</p>
<ul>
<li>如果需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p>同步在多线程中还有另外一层意思，是让多个线程步调一致</p>
<p>&emsp;&emsp;</p>
<h3 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h3><ul>
<li>windows<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程 </li>
<li>tasklist 查看进程 </li>
<li>taskkill 杀死进程</li>
</ul>
</li>
<li>linux<ul>
<li><code>ps -fe</code> 查看所有进程 </li>
<li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程 </li>
<li><code>kill</code> 杀死进程 </li>
<li><code>top</code> 按大写 H 切换是否显示线程 </li>
<li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li>
</ul>
</li>
<li>Java<ul>
<li>jps 命令查看所有 Java 进程 </li>
<li>jstack &lt;PID&gt; 查看某个 Java 进程（PID）的所有线程状态 </li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<hr>
<h2 id="线程的3种创建方式"><a href="#线程的3种创建方式" class="headerlink" title="线程的3种创建方式"></a>线程的3种创建方式</h2><p>Java使用<strong>Thread类</strong>代表线程，每个线程对象都是Thread类实例或Thread类的子类实例。<br>每个线程的作用是完成一定的任务，即执行一段程序流。Java使用线程执行体来代表这段程序流。</p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>定义Thread类子类，重写run()方法。<strong>run()<em>方法的方法体代表线程要完成的任务</em></strong>。  </p>
<p>Thread类常用方法：</p>
<ul>
<li>run()</li>
<li>start()</li>
<li>getName()<br>获取调用该方法的线程的名字</li>
<li>Thread.currentThread()<br>Thread类的静态方法，返回<strong>当前正在执行</strong>的线程对象（返回值为Thread）。</li>
</ul>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">				<span class="keyword">new</span> FirstTread().start();</span><br><span class="line">				<span class="keyword">new</span> FirstTread().start();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或使用匿名内部类方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;thread is running...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><strong>使用继承Thread类的方法创建线程时，多个线程之间无法共享线程类的实例变量（每个线程都是独立的）</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Runnable接口是一个函数式接口，包含一个<code>run()</code>方法。<strong>通过实现该接口来创建线程任务</strong>。</p>
<p>eg:</p>
<p>1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByRunnable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Runnable runnable = () -&gt; log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(; i &lt; <span class="number">100</span> ;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> +i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">		    <span class="comment">//通过该方法创建线程，要获取线程名称只能通过currentThread()调用getName()</span></span><br><span class="line">		    <span class="comment">//无法通过this引用直接调用getName()</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">				SecondThread st = <span class="keyword">new</span> SecondThread();</span><br><span class="line">				<span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line">				<span class="keyword">new</span> Thread(st，<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>该例子的两个子线程共享i变量（两个子线程输出的i变量是连续的）。</strong><br><strong>即采用同一个Runnable变量创建的线程可共享线程类的实例变量。</strong></p>
<p>&emsp;&emsp;</p>
<p>使用该方法将线程和任务分开，更加灵活。</p>
<p>&emsp;&emsp;</p>
<h3 id="使用FutureTask"><a href="#使用FutureTask" class="headerlink" title="使用FutureTask"></a>使用FutureTask</h3><p>FutureTask的继承关系：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210115247727.png" alt="image-20210210115247727"></p>
<p>FutureTask中封装了一个Callable接口。</p>
<p>Callable接口<strong>提供一个call()方法作为线程执行体</strong>，与run()方法相比：</p>
<ul>
<li>call()方法有返回值。</li>
<li>call()方法可以抛出异常。</li>
</ul>
<p>Callable接口的call()方法并不是直接调用，而是作为线程执行体被调用。</p>
<p>Future的几个控制与他关联的Callable任务公共方法：</p>
<ol>
<li><code>boolean cancel( boolean maylnterruptlfrunnin)</code>：试图取消该Future里关联的 Callable任务。</li>
<li><code>V get()</code>:返回 Callable任务里call()方法的返回值。<strong>调用该方法将导致程序阻塞，必须等到子线程结束后才会得到返回值（其他线程将被阻塞，直到该子线程执行完毕并返回对应值）</strong>。</li>
<li><code>V get(long timeout， Timeunit unit)</code>:返回 Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出Timeoutexception异常。</li>
<li><code>boolean isCancelled()</code>:如果在Callable任务正常完成前被取消，则返回true。</li>
<li><code>boolean isDone()</code>:如果 Callable任务已完成，则返回true。  </li>
</ol>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createByFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread&#x27;s running...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;the return value of the task: &quot;</span> + task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程的返回值通过FutureTask对象的get()方法获取，<strong>且当调用该方法时当前线程会阻塞，直到FutureTask执行完毕才返回，若是在调用线程的<code>start()</code>方法之前调用get方法，会陷入死锁</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="三种方式优缺点"><a href="#三种方式优缺点" class="headerlink" title="三种方式优缺点"></a>三种方式优缺点</h3><p>通过实现Runnable、Callable接口创建多线程的优缺点：  </p>
<ul>
<li>线程类只是实现了对应接口，可继承其他的类。</li>
<li>多个线程可以共享一个target对象。适合多个相同线程处理同一份资源的情况。<strong>可以将CPU、代码和数据分开，形成清晰的模型，体现面向对象的思想</strong>。</li>
<li>劣势：编程稍稍复杂，访问当前线程只能用<code>Thread.currentThread()</code>方法。  </li>
</ul>
<p>继承Thread方法的优缺点：</p>
<ul>
<li>劣势：<strong>不可继承其他父类</strong>。</li>
<li>优势：编写简单。<strong>使用当前线程可直接使用this</strong>。</li>
</ul>
<p>Runnable、继承Thread都不能获取线程返回值，使用FutrueTask可以获取返回值，且<code>call()</code>方法可以抛出异常。</p>
<p><strong>推荐方法为实现Runnable接口、Callable接口</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="线程中的常用方法"><a href="#线程中的常用方法" class="headerlink" title="线程中的常用方法"></a>线程中的常用方法</h2><h3 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h3><p>wait、notify、notifyAll是<strong>Object类中的实例方法</strong>。</p>
<p>3个api：</p>
<ul>
<li><code>wait()</code> 让进入 object 监视器的线程到 waitSet <strong>一直</strong>等待 </li>
<li><code>wait(long n)</code> 等待直到时间超时后进入EntryList</li>
<li><code>notify()</code> 在 object 上正在 waitSet 等待的线程中随机唤醒一个。<strong>interrupt()可以叫醒wait中的线程</strong>。</li>
<li><code>notifyAll()</code> 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210216174346353.png" alt="image-20210216174346353"></p>
<ul>
<li><p>Owner 线程发现条件不满足时，<strong>调用 wait 方法，进入 WaitSet 变为 WAITING 状态，等待被唤醒</strong> 。</p>
</li>
<li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </p>
</li>
<li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </p>
</li>
<li><p>而WAITING 线程只能<strong>在 Owner 线程中调用 notify 或 notifyAll 唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</strong>。</p>
</li>
<li><p><strong><font color="red">当前线程必须拥有对象的monitor才能调用这些api，否则抛出IllegalMonitorStateException异常</font></strong>。<code>wait()</code>的JavaDoc：</p>
<p><code>The current thread must own this object&#39;s monitor  </code> </p>
<blockquote>
<p>注意是1个对象对应1个monitor</p>
</blockquote>
</li>
<li><p><strong>当前线程调用<code>wait()</code>只会释放当前该共享变量的锁，而该线程的其他锁是不会释放的</strong>。</p>
</li>
<li><p>被唤醒的线程不能马上从wait方法返回并继续执行， 它<strong>必须在获取了共享对象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行</strong>。</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h4 id="使用的正确姿势"><a href="#使用的正确姿势" class="headerlink" title="使用的正确姿势"></a>使用的正确姿势</h4><p><strong>sleep和 wait的异同</strong>：</p>
<ol>
<li><p>sleep 是 Thread 方法，而 wait 是 Object 的方法 </p>
</li>
<li><p>sleep 不需要强制和 synchronized 配合使用，<strong>但 wait 需要 和 synchronized 一起用</strong> </p>
</li>
<li><p><strong><font color="red">sleep在睡眠的同时不会释放对象锁，但 wait 在等待的时候会释放对象锁 </font></strong>。</p>
</li>
<li><p>它们状态都是TIMED_WAITING。</p>
</li>
</ol>
<p>&emsp;&emsp;</p>
<p>以下姿势对应的demo在<code>practice/useWaitNotifyOBBK</code>包下。</p>
<p><strong>姿势1</strong>：某些条件不满足时调用sleep会占用锁，使用wait更合理。</p>
<p><strong>姿势2</strong>：若是有多个线程在WaitSet，则不宜使用<code>notify()</code>，它只能随机唤醒一个，不能唤醒满足条件的线程。应使用<code>notifyAll()</code>（显然会唤醒部分不满足条件的线程）。</p>
<p><strong>姿势3</strong>：使用循环进行<code>wait()</code>，不满足条件则一直等。<strong>一个线程即使没有被其他线程调用<code>notify()</code>、<code>notifyAll()</code>方法进行通知、或者被中断、或者等待超时，也可以被唤醒，这就是所谓的虚假唤醒</strong>。虽然虚假唤醒很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	<span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">		lock.wait();</span><br><span class="line">	&#125; <span class="comment">// 干活 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程 </span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	lock.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="park、unpark"><a href="#park、unpark" class="headerlink" title="park、unpark"></a>park、unpark</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>它们是 LockSupport 类中的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程 </span></span><br><span class="line">LockSupport.park();</span><br><span class="line"><span class="comment">// 恢复某个线程的运行 </span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>

<p>与 Object 的 wait &amp; notify 相比 </p>
<ul>
<li><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p>
</li>
<li><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 </p>
</li>
<li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><strong>每个线程都关联一个 Parker 对象</strong>，由三部分组成 _counter ， _cond 和 _mutex</p>
<ul>
<li>_counter ：值为0或1，调用park时若<code>_count</code>为0则当前线程阻塞，为1则将其减1并继续运行，无需阻塞。</li>
<li>_cond：相当于阻塞队列。</li>
<li>_mutex：互斥锁，操作<code>_count</code>时需要获取该锁？。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>先调用<code>park()</code>，再调用<code>unpark()</code>过程解析：</p>
<ul>
<li>调用<code>park()</code>：</li>
</ul>
<ol>
<li><p>当前线程调用 Unsafe.park() 方法 </p>
</li>
<li><p>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁 </p>
</li>
<li><p>线程<strong>进入 _cond 条件变量阻塞</strong> </p>
</li>
<li><p><strong>设置 _counter = 0</strong> </p>
</li>
</ol>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217142957852.png" alt="image-20210217142957852" style="zoom: 67%;" />

<ul>
<li>调用<code>unpark()</code>：</li>
</ul>
<ol>
<li><p>设置 _counter 为 1 </p>
</li>
<li><p>唤醒 _cond 条件变量中的 Thread_0 </p>
</li>
<li><p>Thread_0 恢复运行 </p>
</li>
<li><p>设置 _counter 为 0</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143224158.png" alt="image-20210217143224158" style="zoom:67%;" />

</li>
</ol>
<p>&emsp;&emsp;</p>
<p>先调用<code>unpark()</code>，再调用<code>park()</code>过程解析：</p>
<ol>
<li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 </p>
</li>
<li><p>当前线程调用 Unsafe.park() 方法 </p>
</li>
<li><p><strong>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</strong>  </p>
</li>
<li><p>设置 _counter 为 0</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217143503716.png" alt="image-20210217143503716" style="zoom:67%;" />

</li>
</ol>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>以下api都是Thread类的方法。</p>
<ul>
<li><p><code>interrupt()</code>：中断线程，<strong style="color:red">但其实只是将线程的中断标志置为true，线程还是会继续运行</strong>。</p>
<ul>
<li><strong>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记</strong> ；</li>
<li>否则，<strong>仅仅设置打断标记 ，但并不会使线程停止（即调用interrupt只是让线程知道有人要终止它，它可以先进行某些处理后再自行终止线程）</strong>。</li>
<li>被<code>LockSurpport.park()</code><strong>暂停</strong>的线程被打断则会继续运行，<strong>且会设置打断标记为true</strong>。</li>
</ul>
<p>**demo见<code>JavaConcurrentDemo/trhead_basic/TestInterrupt</code>**。</p>
</li>
<li><p><code>isInterrupted()</code>：返回中断标志，<strong>不清除中断标志</strong>。</p>
</li>
<li><p><code>static interrupted()</code>：判断当前线程是否被打断。<strong>清除中断标记（即将中断标志置false）</strong>。<strong>注意是静态方法</strong>。</p>
<ul>
<li><p>该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要注意返回的是<font color="red">“当前线程”</font>的中断标志</strong>。</p>
</li>
</ul>
</li>
<li><p><code>private native boolean isInterrupted(boolean ClearInterrupted)</code>：私有方法，返回中断标志，并根据ClearInterrupted参数决定是否清除中断标志，上面2个方法都是调用了该方法。</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="Thread类方法"><a href="#Thread类方法" class="headerlink" title="Thread类方法"></a>Thread类方法</h3><ul>
<li><p><code>start()</code>：启动一个新线程，在新的线程运行run方法中的代码。<strong>start方法只是让线程进入就绪，里面代码不一定立刻运行</strong>（CPU的时间片还没分给它）。<strong>每个线程对象的 start方法只能调用一次</strong>，如果调用了多次会出IllegalThreadStateException</p>
</li>
<li><p><code>run()</code>：如果在构造Thread对象时传递了 Runnable 参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为。</p>
</li>
<li><p><code>join()</code> ：<strong>在当前线程中阻塞，直到指定线程运行结束，<font color="red">注意此时当前线程是在指定线程对象上的monitor等待（即在该monitor的WaitSet上）</font></strong>。其他线程调用因<code>join()</code>阻塞线程的<code>interrupt()</code>方法时，被打断程序会抛出InterruptedException 并返回。</p>
</li>
<li><p><code>join(long n) </code>：等待线程运行结束,最多等待 n 毫秒</p>
</li>
<li><p><code>setPriority(int)</code> ：线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用。</p>
</li>
<li><p><code>isAlive()</code>：线程是否存活 （还没有运行完毕）</p>
</li>
<li><p><code>sleep()</code>：</p>
</li>
<li><p>在一些<code>while(true)</code>中可以使用sleep来避免占用过多的cpu用于空转。</p>
<ul>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） </li>
<li><strong>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时线程会抛出 InterruptedException并返回</strong> 。</li>
<li>睡眠结束后的线程未必会立刻得到执行 </li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。如<code>TimeUnit.SECONDS.sleep(2);</code>表示睡眠2s。</li>
</ul>
</li>
<li><p><code>static currentThread()</code>：获取当前正在执 行的线程</p>
</li>
<li><p><code>static yield()</code>：提示线程调度器让出当前线程对 CPU的使用，<strong>线程调度器可以无视这个提示</strong>。<strong>调用该方法时，当前线程会进入就绪状态，线程调度器会重新执行调度，当然有可能重新调度到执行yeild的线程</strong>。</p>
<ul>
<li>示例：若没有<code>Thread.yield();</code>，则两个线程打印的count数相差不大；加上<code>Thread.yield();</code>，可以看到线程1明显打印的更快。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----&gt;1 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) &#123;</span><br><span class="line">               Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;              ----&gt;2 &quot;</span> + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp; </p>
<p>其他方法：</p>
<ul>
<li><p><code>getState()</code></p>
</li>
<li><p><code>getId()</code> </p>
</li>
<li><p><code>getName()</code> </p>
</li>
<li><p><code>setName(String)</code> </p>
</li>
<li><p><code>getPriority() </code></p>
</li>
</ul>
<p>停止线程使用“两阶段停止模式”（demo TestTwoPhaseTermination），而不要使用以下过时方法：</p>
<ul>
<li>stop() </li>
<li>suspend() </li>
<li>resume() static </li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="理解线程上下文切换"><a href="#理解线程上下文切换" class="headerlink" title="理解线程上下文切换"></a>理解线程上下文切换</h2><p>在多线程编程中线程个数一般都大于CPU个数， 而每个CPU同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行的， CPU资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片， 线程在时间片内占用CPU执行任务。<strong>当前线程使用完时间片后就会处于就绪状态并让出CPU让其他线程占用， 这就是上下文切换</strong>。</p>
<p>在切换线程上下文时需要保存当前线程的执行现场，当再次执行时根据保存的执行现场信息恢复执行现场。</p>
<p>&emsp;&emsp;</p>
<p>概括来说就是：<strong>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>线程上下文切换的时机有：</p>
<ul>
<li>当前线程的CPU时间片使用完处于就绪状态时。</li>
<li>当前线程被其他线程中断时。</li>
</ul>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>&emsp;&emsp;</p>
<h2 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h2><p><strong>Java中的线程分为两类， 分别为daemon线程(守护线程) 和user线程(用户线程)</strong> 。在JVM启动时会调用main函数， main函数所在的线程就是一个用户线程， 其实在JVM内部同时还启动了好多守护线程，比如垃圾回收线程。</p>
<p><strong>当最后一个非守护线程结束时， JVM会正常退出， 而不管当前是否有守护线程， 也就是说， 只要有一个用户线程还没结束，正常情况下JVM就不会退出</strong>。</p>
<p>创建的线程默认是用户线程，可以通过Thread的<code>setDeamon(true)</code>可将线程设置为守护线程。</p>
<p>示例demo：TestDeamon。</p>
<p>&emsp;&emsp;</p>
<h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><h3 id="从OS层面"><a href="#从OS层面" class="headerlink" title="从OS层面"></a>从OS层面</h3><p>从操作系统层面，线程的生命周期包括<strong>新建（New），就绪（Ready），运行（Running），阻塞（Blocked），死亡（Dead）</strong>。CPU在多个线程之间切换时，线程状态也在Ready、Running之间切换。</p>
<h4 id="新建与就绪状态"><a href="#新建与就绪状态" class="headerlink" title="新建与就绪状态"></a>新建与就绪状态</h4><p><strong>使用new关键字创建一个线程时，该线程即处于新建状态</strong>，此时JVM仅为它分配内存，初始化成员变量的值（与new普通对象一样）。<br><strong>调用start()方法后，线程处于就绪状态</strong>，<strong>JVM为其创建方法调用栈和程序计数器</strong>，<strong>此时线程并没有运行，只是表示其可以运行</strong>，何时运行取决于JVM里线程调度器的调度。 </p>
<p>&emsp;&emsp;</p>
<h4 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h4><p>处于就绪状态的线程获得CPU，开始执行run()方法，则<strong>处于运行状态</strong>。如果只有一个CPU，则每个时刻只有一个线程在运行状态。<br>线程调度策略：</p>
<ul>
<li><strong>抢占式策略</strong>：系统给每个线程一小段时间处理任务，时间用完后，系统剥夺该线程所占用的资源，让给其他线程。选择下一个线程时，系统会考虑线程优先级。</li>
<li><strong>协作式调度策略</strong>：只有一个线程调用它的sleep()或yield()方法后才会放弃所占用的资源——即必须由线程主动放弃资源。  </li>
</ul>
<p>发生以下情况时，<strong>线程进入阻塞状态</strong>：</p>
<ul>
<li>线程调用sleep()。</li>
<li>线程调用一个阻塞式IO方法，在该方法返回之前。</li>
<li>线程试图获取一个同步监视器，但该监视器被其他线程所持有。</li>
<li>线程在等待某个通知（notify）。</li>
<li>线程调用suspend()方法将该线程挂起。（该方法<strong>容易导致死锁</strong>）  </li>
</ul>
<p>当线程被阻塞，其他线程即可获得CPU。被阻塞的线程在合适的时候进入就绪状态（而不是运行状态，解除阻塞后，必须重新等待线程调度器调用它）。<br>发生以下情况时，阻塞的线程进入就绪状态（对应上面的情况）：</p>
<ul>
<li>sleep()方法超过指定时间。</li>
<li>IO方法已返回。</li>
<li>获得同步监视器。</li>
<li>线程正在等待通知时，其他线程发出了一个通知。</li>
<li>被挂起的线程调用resume()恢复方法。</li>
</ul>
<h4 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h4><p>线程以如下三种方式结束时死亡：</p>
<ul>
<li>run()或call()方法执行完毕。</li>
<li>抛出Exception或Error。</li>
<li>调用线程的stop()方法。（<strong>容易导致死锁</strong>）  </li>
</ul>
<p>判断某个线程是否已死亡可调用线程的isAlive()方法（<strong>处于新建、死亡状态返回false</strong>，处于就绪、运行、阻塞返回true）。</p>
<blockquote>
<ul>
<li><strong>主线程结束时，其他线程不受影响。一旦子线程启动，就拥有与主线程相同地位</strong>。</li>
<li>不要对一个已死亡的线程调用start()。  </li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<h3 id="从Java-API方面"><a href="#从Java-API方面" class="headerlink" title="从Java API方面"></a>从Java API方面</h3><p>（以下图片来自JavaGuide）</p>
<p>在<strong>Thread中的State枚举类里定义了线程的6种状态</strong>：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215044761.png" alt="image-20210210215044761"></p>
<p>其中，将OS层面的就绪（Ready）和运行（Running）状态统称为 <strong>RUNNABLE（可运行）</strong> 状态 。</p>
<blockquote>
<p>在idea中debug时，BLOCKED状态显示为MONITOR</p>
</blockquote>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>Java 线程状态变迁如下图（<strong>大概情况</strong>）：（这里join方法应是来自Thread类）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210210215151522.png" alt="image-20210210215151522" style="zoom: 80%;" />

<p>其中的一些情况补充：</p>
<ul>
<li><p>WAITING &lt;–&gt; RUNNABLE：调用 <code>obj.notify()  obj.notifyAll()  t.interrupt()</code> 时线程不是直接进入RUNNABLE状态，而是进入EntryList后再竞争锁（<i>对于join、park等应该也是</i>）：</p>
<ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE </li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
<li><p>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING。<strong><font color="red">注意是当前线程在t 线程对象的监视器上（具体是在WaitSet上）等待</font></strong>。<br>t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
<li><p>RUNNABLE &lt;–&gt; BLOCKED：</p>
<ul>
<li>t 线程用 <code>synchronized(obj)</code> <strong>获取对象锁时如果竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED </li>
<li><strong>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争</strong>，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="变量的线程安全"><a href="#变量的线程安全" class="headerlink" title="变量的线程安全"></a>变量的线程安全</h2><h3 id="成员变量和静态变量"><a href="#成员变量和静态变量" class="headerlink" title="成员变量和静态变量"></a>成员变量和静态变量</h3><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 <ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li>局部变量是线程安全的 </li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的 </li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p>对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul>
<li>String、Integer：String、Integer 等都是不可变类，因为<strong>其内部的状态不可以改变</strong>，因此它们的方法都是线程安全的。对于String的replace，substring 等方法，其实质是返回一个新的字符串。</li>
<li>StringBuffer</li>
<li>Random </li>
<li>Vector</li>
<li>Hashtable </li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong>。它们的每个方法是原子的，<strong>但注意它们多个方法的组合不是原子的</strong>。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable(); </span><br><span class="line"><span class="comment">// 线程1，线程2 </span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="keyword">null</span>) &#123; </span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种线程不安全的执行示例：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210213172057961.png" alt="image-20210213172057961"></p>
<p>&emsp;&emsp;</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>死锁是指<strong>两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。发生死锁时，整个程序不会发生任何异常，也不会给出任何提示，如果没有外力作用，这些线程会一直等待，无法继续运行</strong>。</p>
<p><strong style="color:red">发生死锁的4个条件</strong>：</p>
<ul>
<li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li>
<li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程一资源的环形链，即线程集合{T0，T1，T2，…，Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>避免死锁可以通过破坏4个条件的至少一个实现，<strong>而目前只有请求并持有和环路等待条件是可破坏的</strong>。造成死锁的原因和资源申请顺序关系很大，可以使用资源的有序性申请来避免死锁（<strong>破坏环路等待条件</strong>）。有序性即：<strong>假如线程A和线程B都需要资源1，2，3，…，n时，对资源进行排序，<font color="red">线程A和线程B只有在获取了资源n-1时才能去获取资源n</font></strong>。</p>
<p>&emsp;&emsp;</p>
<p>一种死锁示例：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">* t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁</span></span><br><span class="line"><span class="comment">* t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;lock obj B&quot;</span>);</span><br><span class="line">                sleep(<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;lock obj A&quot;</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;do something...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="检测死锁的工具"><a href="#检测死锁的工具" class="headerlink" title="检测死锁的工具"></a>检测死锁的工具</h3><h4 id="jstack命令"><a href="#jstack命令" class="headerlink" title="jstack命令"></a>jstack命令</h4><p>运行上述示例代码，在cmd输入<code>jps</code>，查看线程id，再执行<code>jstack thread_id</code>输出检测结果。</p>
<p>输出结果的部分：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">  waiting to <span class="keyword">lock</span> monitor <span class="number">0x000000000297c178</span> (<span class="keyword">object</span> <span class="number">0x00000000d6b65178</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held <span class="keyword">by</span> <span class="string">&quot;t1&quot;</span></span><br><span class="line"><span class="string">&quot;t1&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">to</span> <span class="keyword">lock</span> monitor <span class="number">0x000000000297e488</span> (<span class="keyword">object</span> <span class="number">0x00000000d6b65188</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held <span class="keyword">by</span> <span class="string">&quot;t2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Java</span> stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;t2&quot;</span>:</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock.lambda$<span class="keyword">main</span>$<span class="number">1</span>(TestDeadLock.java:<span class="number">34</span>)</span><br><span class="line">        - waiting <span class="keyword">to</span> <span class="keyword">lock</span> &lt;<span class="number">0x00000000d6b65178</span>&gt; (a java.lang.Object)</span><br><span class="line">        - <span class="keyword">locked</span> &lt;<span class="number">0x00000000d6b65188</span>&gt; (a java.lang.Object)</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock$$Lambda$<span class="number">2</span>/<span class="number">1879034789.</span>run(<span class="literal">Unknown</span> <span class="keyword">Source</span>)</span><br><span class="line">        <span class="keyword">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">&quot;t1&quot;</span>:</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock.lambda$<span class="keyword">main</span>$<span class="number">0</span>(TestDeadLock.java:<span class="number">23</span>)</span><br><span class="line">        - waiting <span class="keyword">to</span> <span class="keyword">lock</span> &lt;<span class="number">0x00000000d6b65188</span>&gt; (a java.lang.Object)</span><br><span class="line">        - <span class="keyword">locked</span> &lt;<span class="number">0x00000000d6b65178</span>&gt; (a java.lang.Object)</span><br><span class="line">        <span class="keyword">at</span> lock.TestDeadLock$$Lambda$<span class="number">1</span>/<span class="number">942986815.</span>run(<span class="literal">Unknown</span> <span class="keyword">Source</span>)</span><br><span class="line">        <span class="keyword">at</span> java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Found</span> <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p>进入cmd，输入<code>jconsole</code>，连接线程。</p>
<p>在线程窗口点击检测死锁，可看到相关信息：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217170359984.png" alt="image-20210217170359984"></p>
<p>&emsp;&emsp;</p>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>5个哲学家围在圆桌上用餐，有5根筷子，只有拥有两根筷子才能吃饭，吃完饭会放下筷子思考，如此反复。</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210217171857739.png" alt="image-20210217171857739" style="zoom:67%;" />

<p>代码：demo位于<code>lock/deadlock/v1/TestPhilosopher.java</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//　尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p>
<p>示例：（demo：<code>lock/TestLiveLock.java</code>）</p>
<p>t1要将count减到0，t2要加到20，由于它们的运算速度相近，导致一直执行不结束。</p>
<p><strong>可以使用随机sleep时间避免等</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个线程由于优先级太低（或者说长时间运行不了），始终得不到 CPU 调度执行，也不能够结束。</p>
<p>&emsp;&emsp;</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量，JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 **<code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，</strong>即创建一个变量，每一个线程访问该变量获取的都是该变量在该线程的副本**。</p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><blockquote>
<p><code>sleep(int i)</code>表示睡眠i s</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String str = <span class="string">&quot;str from t1&quot;</span>;</span><br><span class="line">            threadLocal.set(str);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 获取的是自己放置的str，获取不到t2放置的</span></span><br><span class="line">            String str1 = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str after 2s: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获取的str为null，不能获取到t1放置的str</span></span><br><span class="line">            String str = threadLocal.get();</span><br><span class="line">            log.debug(<span class="string">&quot;get str: &#123;&#125;&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            String str1 = <span class="string">&quot;str from t2&quot;</span>;</span><br><span class="line">            threadLocal.set(str1);</span><br><span class="line">            log.debug(<span class="string">&quot;set str: &#123;&#125;&quot;</span>, str1);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Thread类包含一个ThreadLocal.ThreadLocalMap成员变量，其实质是一个Map，映射类型是 ThreadLocal-Object，存放多个ThreadLocal的本地副本，</p>
<p>从Thread类源码开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>即<strong>Thread类中有一个threadLocals和一个inheritableThreadLocals， 它们都是ThreadLocalMap类型（<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类）的变量</strong>， 而<strong>ThreadLocalMap是一个定制化的map，存放多个ThreadLocal变量在当前线程的副本，<code>ThreadLocalMap</code>存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</strong>。</p>
<p>在默认情况下， 每个线程中的这两个变量都为nll， <strong>只有当前线程第一次调用Thread Local的<code>set()</code>或者<code>get()</code>方法时才会创建它们</strong>。</p>
<p>从上面可以看出，<strong style="color:red">每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</strong>。<strong>Thread Local就是一个工具壳， 通过它来从当前线程的threadLocals中获取值或放入值</strong>。</p>
<p>如果调用线程一直不终止， 那么这个本地变量会一直存放在调用线程的thread Locals变量里面， 所以当不需要使用本地变量时可以通过调用Thread Local变量的<code>remove()</code>方法， 从当前线程的thread Locas里面删除该本地变量，避免内存泄漏。</p>
<p>&emsp;&emsp;</p>
<p><code>set()</code>、<code>get()</code>的源码简单分析：</p>
<p><code>set()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// threadLocalMap不为null，修改值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 第一次调用则创建当前线程对应的threadLocalMap，并将value放进去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><code>get()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的threadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 不为null则从中尝试获取值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前ThreadLocal对象为key，从线程的threadLocalMap中尝试获取值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map为null或其中没有当前ThreadLocal对应的值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong style="color:red">可以看到<code>set()</code>、<code>get()</code>方法都是先从当前线程中获取ThreadLocalMap对象</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p><code>setInitialValue()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();<span class="comment">//该方法只是返回一个null</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="comment">// map不为null（表示其中没有当前ThreadLocal对应的值）</span></span><br><span class="line">    <span class="comment">// 放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 否则创建一个ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 并同样放置一个 当前ThreadLocal对象-null 的键值对</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><code>createMap()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>Thread、ThreadLoacal、ThreadLoacalMap的关系图解：（图片来自JavaGuide）</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210218180050123.png" alt="image-20210218180050123" style="zoom:80%;" />



<h3 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h3><p><strong><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry</strong>。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。<strong>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</strong>。</p>
<blockquote>
<p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放但又无法使用，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
</blockquote>
<p>ThreadLocalMap的静态内部类Entry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="InheritableThreadLocal-to-be-…"><a href="#InheritableThreadLocal-to-be-…" class="headerlink" title="InheritableThreadLocal(to be …)"></a>InheritableThreadLocal(to be …)</h3><p>&emsp;&emsp;</p>
<h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h2><p>CPU与主内存之间会添加一级或多级高速缓冲存储器，即Cache。</p>
<p><strong>在Cache内部是按行存储的， 其中每一行称为一个Cache行</strong>。Cache行是<strong>Cache与主内存进行数据交换的单位</strong>，Cache行的大小一般为2的幂次数字节。当CPU访问某个变量时， 首先会去看CPU Cache内是否有该变量， 如果有则直接从中获取，否则就去主内存里面获取该变量， <strong style="color:red">然后把该变量所在内存区域的一个Cache行大小的内存块（局部性原理）复制到Cache中</strong>。</p>
<p><strong>由于存放到Cache行的是内存块而不是单个变量， 所以可能会把多个变量存放到一个Cache行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享</strong>。</p>
<p>比如CPU1、CPU2读取了同一个缓存行，若CPU1对其中的一个变量修改，在缓存一致性协议下，CPU2中对应的缓存行就会失效，即破坏了CPU2的一级缓存，CPU2需要到二级缓存查找（甚至到主存），造成性能下降。</p>
<p>&emsp;&emsp;</p>
<p>比如有4个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure>

<p>假设缓存行大小32字节，一个long类型8个字节，当CPU访问a时，会把a及附近的b、c、d一起放入缓存行。</p>
<p><strong style="color:red">也就是地址连续的多个变量才有可能会被放到一个缓存行中</strong>。比如创建数组时，数组里面的多个元素就会被放入同一个缓存行。</p>
<p>在正常情况下单线程访问时将数组元素放入一个或者多个缓存行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p>
<p>测试缓存行demo见<code>test/TestCacheLine</code>。</p>
<p>&emsp;&emsp;</p>
<p>JDK8之前使用声明多个填充变量的方法来避免伪共享问题，让一个缓存行只有一个有用变量：</p>
<p>该例中，若缓存行大小是64B，则value+p1-6是56B，对象头是8B，所以共64B。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>JDK8提供了一个注解<code>@sun.misc.Contended</code>解决伪共享问题，它可以自行执行填充。上面代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<blockquote>
<p>需要注意的是， 在默认情况下， @Contended注解只用于Java核心类， 比如rt包下的类。如果用户类路径下的类需要使用这个注解， 则需要添加JVM参数：<code>-XX:-RestrictContended</code>。填充的宽度默认为128，要自定义宽度则可以设置</p>
<p><code>-XX:ContendedPaddingWidth</code>参数。</p>
</blockquote>
<h2 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。</p>
<p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以<strong>在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态</strong>。</p>
<blockquote>
<p>悲观锁的<strong>实现往往依靠数据库提供的锁机制</strong>，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以<strong>在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测</strong>。比如根据update返回的行数让用户决定如何去做。</p>
<p>乐观锁并不会使用数据库提供的锁机制， 一般在表中添加version字段（<strong>每次根据id和version修改记录，若修改成功，将version+1</strong>）或者使用业务状态来实现。乐观锁直到提交时才锁定，所以不会产生任何死锁。</p>
<p>&emsp;&emsp;</p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，</p>
<ul>
<li>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的。</li>
<li>非公平锁则是先来不一定先得。</li>
</ul>
<p>Reentrant Lock提供了公平和非公平锁的实现。</p>
<ul>
<li>公平锁：<code>Reentrant Lock pair Lock=nhew Reentrant Lock(true)</code> 。</li>
<li>非公平锁：<code>Reentrant Lock pair Lock=new Reentrant Lock(false) </code>。如果构造函数不传递参数，则默认是非公平锁。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p><strong>独占锁表示一个锁只能被一个线程获取，共享锁则可以被多个线程获取</strong>。</p>
<p><strong>独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性</strong>，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<p>&emsp;&emsp;</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>当一个线程可以再次获取它已经获取了的锁，则该锁是可重入的。synchronized内部锁和ReentrantLock都是可重入锁。</p>
<p>&emsp;&emsp;</p>
<p>可重入锁的原理是<strong>在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器</strong>。一开始计数器值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁时，计数器的值会变成1，这时其他线程再来获取该锁时<strong>会发现锁的所有者不是自己而被阻塞挂起</strong>。但是当<strong>获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+1</strong>，当释放锁后计数器值-1。当计数器值为0时， 锁里面的线程标示被重置为null， 这时候被阻塞的线程会被唤醒来竞争获取该锁。</p>
<p>&emsp;&emsp;</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>由于Java中的线程是与操作系统中的线程一一对应的，<strong>所以当一个线程在获取锁(比如独占锁)失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。<font color="red">而从用户状态切换到内核状态的开销是比较大的</font>，在一定程度上会影响并发性能</strong>。</p>
<p>自旋锁是<strong>当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取</strong>（默认次数是10，可以使用<code>-XX：PreBlockSpinsh</code>参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。</p>
<p>由此看来自旋锁是使用CPU时间换取线程阳塞与调度的开销， <strong>但是很有可能这些CPU时间白白浪费了</strong>。</p>
<p>&emsp;&emsp;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="do nothing, nothing there">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">JVM垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 13:20:53" itemprop="dateCreated datePublished" datetime="2021-02-18T13:20:53+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-20 20:51:21" itemprop="dateModified" datetime="2021-03-20T20:51:21+08:00">2021-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<p>对于程序计数器、虚拟机栈、本地方法栈，这几个区域的内存分配和回收都具有确定性，它们随着线程结束或方法结束时回收内存。<strong>而堆和方法区则有很大的不确定性：只有到运行期才能知道程序要创建哪些对象，创建多少对象，它们的内存分配和回收是动态的</strong>。</p>
<p>&emsp;&emsp;</p>
<p>Java 的自动内存管理<strong>主要是针对对象内存的回收和对象内存的分配</strong>。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong> </p>
<p><strong>堆空间的基本结构</strong>（图片来自javaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129095613698.png" alt="image-20210129095613698"></p>
<p>&emsp;&emsp;</p>
<h2 id="判断对象已死"><a href="#判断对象已死" class="headerlink" title="判断对象已死"></a>判断对象已死</h2><p>垃圾收集器对堆回收之前需要判断哪些对象存活，哪些死亡（<strong>即不能再被任何途径使用的对象</strong>）。有<strong>引用计数算法和可达性分析算法</strong>两种判断方式。</p>
<p>&emsp;&emsp;</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；<strong>任何时候计数器为 0 的对象就是不可能再被使用的</strong>。</p>
<p>这个方法实现简单，效率高，但是目前<strong>主流的虚拟机中并没有选择这个算法</strong>来管理内存，其最主要的原因是它<strong>很难解决对象之间相互循环引用的问题</strong>。</p>
<p>循环依赖示例：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，<strong>于是引用计数算法无法通知 GC 回收器回收他们</strong>。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是<strong>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的</strong>。</p>
<p><strong>可作为 GC Roots 的对象</strong>包括下面几种:</p>
<ul>
<li><strong>虚拟机栈</strong>(栈帧中的本地变量表)中引用的对象</li>
<li><strong>本地方法栈</strong>(Native 方法)中引用的对象</li>
<li><strong>方法区</strong>中<strong>类静态属性引用</strong>的对象</li>
<li><strong>方法区</strong>中<strong>常量引用的对象</strong> </li>
<li>Java虚拟机内部引用，如基本类型对应的Class对象，系统类加载器、常驻异常对象等。</li>
<li>被同步锁（synchronized关键字）持有的对象。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p><strong>JDK1.2 之前</strong>，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p><strong>JDK1.2 以后</strong>，Java 对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种（<strong>引用强度逐渐减弱</strong>）。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。<strong>在任何情况下，只要这个强引用存在，垃圾回收器绝不会回收它</strong>。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>&emsp;&emsp;</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述一些<strong><font color="red">还有用，但非必须的对象</font></strong>。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存</strong>。</p>
<p>软引用<strong>可以和一个引用队列（ReferenceQueue）联合使用</strong>，如果<strong>软引用所引用的对象被垃圾回收</strong>，JAVA 虚拟机就会<strong>把这个软引用</strong>加入到与之关联的引用队列中。后续可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。</p>
<p>&emsp;&emsp;</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，<strong style="color:red">它只能生存到下一次垃圾收集发生</strong>。</p>
<p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>&emsp;&emsp;</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<font color="red">虚引用主要用来跟踪对象被垃圾回收的活动</font></strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用<strong>必须和引用队列</strong>（ReferenceQueue）<strong>联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<strong>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收</strong>。程序如果发现某个虚引用已经被加入到引用队列，那么就<strong>可以在所引用的对象的内存被回收之前采取必要的行动</strong>。</p>
<p>&emsp;&emsp;</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="“非死不可”？"><a href="#“非死不可”？" class="headerlink" title="“非死不可”？"></a>“非死不可”？</h3><p><strong>即使在可达性分析法中不可达的对象，也并非是“非死不可”的</strong>，这时候它们暂时处于“缓刑阶段”，要<strong>真正宣告一个对象死亡，至少要经历两次标记过程</strong>：可达性分析法中不可达的对象被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p><strong>被判定为需要执行的对象将会被放在一个队列中，并由一个低优先级线程去执行它们的<code>finalize()</code>方法</strong>，除非这个对象在<code>finalize()</code>方法中与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<p><strong style="color:red">这种“自救”不推荐被使用</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p><strong>方法区也是垃圾回收的对象区域</strong>，这里的垃圾收集主要包含两部分内容：<strong>废弃的常量和不再使用的类型</strong>。方法区的垃圾收集通常“性价比”比较低。</p>
<h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><p>运行时常量池主要回收的是废弃的常量。判断一个常量是否废弃：</p>
<p><strong>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了</strong>。</p>
<p>&emsp;&emsp;</p>
<p><strong><font color="red">关于常量池，方法区，元空间</font></strong>：</p>
<ol>
<li>JDK1.7 <strong>之前</strong>运行时常量池逻辑包含字符串常量池存放在方法区， 此时 HotSpot 虚拟机对方法区的实现为永久代</li>
<li><strong>JDK1.7  字符串常量池 被从方法区拿到了堆中</strong>， 这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区， 也就是 HotSpot 中的永久代 。</li>
<li>JDK1.8 HotSpot 移除了永久代用元空间(Metaspace)取而代之，<strong><font color="red"> 这时候字符串常量池还在堆， 运行时常量池还在方法区， 只不过方法区的实现从永久代变成了元空间</font></strong>(Metaspace)。</li>
</ol>
<p>&emsp;&emsp;</p>
<h4 id="回收类"><a href="#回收类" class="headerlink" title="回收类"></a>回收类</h4><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p>
<p>类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<blockquote>
<p>在大量使用反射、动态代理、CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 通常都需要Java虚拟机具备类型卸载的能力， <strong>以保证不会对方法区造成过大的内存压力</strong>。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集理论的3个经验法则：</p>
<ul>
<li><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p>
</li>
<li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
</li>
<li><p>跨代引用假说：跨代引用相对于同代引用来说占极少数。</p>
<blockquote>
<p>假如要进行一次只局限于新生代区域内的收集(Minor GC) ， <strong>但新生代中的对象是完全有可能被老年代所引用的</strong>， 为了找出该区域中的存活对象， 不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。但无疑会为内存回收带来很大的性能负担。为了解决这个问题，于是添加了第3个经验法则。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p>分代收集理论放到具体的JVM中，设计者一般至少把Java堆划分为新生代和老年代。在Java堆划分出不同的区域之后，<strong>垃圾收集器才可以每次只回收其中某一个或者某些部分的区域</strong>——因而有了“Minor GC”、“Major GC”、“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。</p>
<p>&emsp;&emsp;</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</strong>。（或者反过来标记不需要回收的对象）</p>
<p>它是<strong>最基础的收集算法，后续的算法都是对其不足进行改进得到</strong>。这种垃圾收集算法会带来两个明显的问题：</p>
<ul>
<li><p><strong>效率问题</strong>。如果堆中很多对象需要回收，这时必须进行大量清除和标记的动作。</p>
</li>
<li><p><strong>内存碎片问题（标记清除后会产生大量不连续的碎片）</strong> </p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。<strong>它将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收</strong>。</p>
<p>这样实现简单，运行高效，<strong>缺陷也明显，可用内存缩小了一半，且当对象存活率较高时，该算法效率较低</strong>。</p>
<p>&emsp;&emsp;</p>
<p>针对内存浪费太多的改进（Appel式回收）：<strong>把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间</strong>。HotSpot虚拟机<strong>默认Eden和Survivor的大小比例是8：1</strong>， 只有10%的新生代是会被“浪费”的。</p>
<p>但也没有办法保证每次回收都只有不多于10%的对象存活， 因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计， 当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（<strong>实际上大多就是老年代</strong>）进行分配担保(Handle Promotion) </p>
<p>&emsp;&emsp;</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法不适合老年代，因为老年代的回收率低，需要复制的对象太多。<strong style="color:red">标记-整理算法是针对老年代的</strong>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<strong>而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</strong>。</p>
<p>图示（来自JavaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129150506762.png" alt="image-20210129150506762"></p>
<p>&emsp;&emsp;</p>
<p>标记-清除、标记-整理的<strong>本质区别在于是不是移动式的回收算法</strong>。是否移动对象都存在弊端：</p>
<ul>
<li>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，<strong>移动存活对象并更新所有引用这些对象的地方</strong>将会是一种极为负重的操作，<strong>而且这种对象移动操作必须全程暂停用户应用程序才能进行</strong>（“<strong style="color:red">Stop The World</strong>”）。</li>
<li>但如果完全不考虑移动和整理存活对象，<strong>弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配策略来解决</strong>。</li>
</ul>
<p><strong>移动则内存回收时会更复杂，不移动则内存分配时会更复杂</strong>。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是<strong style="color:red">从总的来说，移动对象会更划算</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块</strong>。一般将 java 堆分为新生代和老年代，<strong style="color:red">这样就可以根据各个年代的特点选择合适的垃圾收集算法</strong>。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<blockquote>
<p> <strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？根据上面的对分代收集算法的介绍回答。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器。这个收集器是一个<strong>单线程收集器</strong>。它的 <strong>“单线程” 的意义</strong>不仅仅意味着它<strong>只会使用一条垃圾收集线程去完成垃圾收集工作</strong>，<strong style="color:red">而且它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束</strong>。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。如图（来自《深入理解JVM》</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155016436.png" alt="image-20210129155016436"></p>
<p>Serial不是已无用的”鸡肋“，<strong>它是HotSpot运行在客户端模式下的默认<font color="red">新生代</font>收集器</strong>。它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器<strong>没有线程交互的额外开销</strong>，可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
<p>&emsp;&emsp;</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样</strong>。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。（图片来自JavaGuide)</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155850631.png" alt="image-20210129155850631" style="zoom:80%;" />

<p><strong>它是许多运行在 Server 模式下的虚拟机的首要选择</strong>，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。</p>
<p><strong>在谈论垃圾收集器的上下文语境中，并行和并发概念可理解为：</strong> </p>
<ul>
<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，通常默认<strong>此时用户线程仍然处于等待状态</strong>。</li>
<li><strong>并发（Concurrent）</strong>：指<strong>用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行）</strong>，用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器也是<strong>使用复制算法的新生代多线程收集器，看上去几乎和 ParNew 一样</strong>。</p>
<p>其不同点在于：CMS 等垃圾收集器的关注点更多的是用户线程的<strong>停顿时间</strong>，而<strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）</strong>。停顿时间短，可以让用户有更好的体验；高吞吐量则可以充分利用处理器资源，<strong>适合在后台运算而不需要过多交互的任务</strong>。</p>
<p>所谓<strong>吞吐量</strong>就是 <strong>CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值</strong>。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合<strong>自适应调节策略</strong>，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性</strong>。</p>
<p>  &emsp;&emsp;</p>
<p><strong>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old</strong>，如果指定了<code>-XX:+UseParallelGC</code> 参数，则默认指定了</p>
<p><code>-XX:+UseParallelOldGC</code>，可以使用<code>-XX:-UseParallelOldGC</code> 来禁用该功能。</p>
<p>  &emsp;&emsp;</p>
<p>新生代采用复制算法，老年代采用标记-整理算法。（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130154438990.png" alt="image-20210130154438990"></p>
<p>&emsp;&emsp;</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial收集器的老年代版本，使用标记-整理算法，它同样是一个单线程收集器</strong>。该收集器主要也是供客户端模式下的HotSpot使用。如果在<strong>服务端模式下，主要有两大用途</strong>：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<p>&emsp;&emsp;</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法</strong>。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器组合使用。</p>
<p>&emsp;&emsp;</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep，并发标记清除）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用</strong>。CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它<strong style="color:red">第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。（并发收集、低停顿）</p>
<p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<strong>整个过程分为四个步骤</strong>：</p>
<ul>
<li><strong>初始标记</strong>（<strong style="color:red">STW</strong>）： 暂停所有的其他线程，并记录下<strong>直接与 root 相连的对象</strong>，速度很快 ；</li>
<li><strong><font color="red">并发</font>标记</strong>： <strong>GC 和用户线程一起并发运行，从GC Roots的直接关联对象开始遍历整个对象图</strong>。但在这个阶段结束，并不能保证扫描完当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以<strong>这个算法里会跟踪记录这些发生引用更新的地方</strong>。</li>
<li><strong>重新标记</strong>（<strong style="color:red">STW</strong>）： 重新标记阶段就是为了<strong>修正并发标记期间因为用户程序继续运行而导致标记产生变动</strong>的那一部分对象的<strong>标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</strong>。</li>
<li><strong><font color="red">并发</font>清除</strong>： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130162109512.png" alt="image-20210130162109512"></p>
<p>&emsp;&emsp;</p>
<p><strong>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的</strong>。</p>
<p>&emsp;&emsp;</p>
<p>CMS收集器有下面三个明显的缺点：</p>
<ul>
<li><p><strong>对 CPU 资源敏感；</strong> </p>
</li>
<li><p><strong>无法处理浮动垃圾； 且在垃圾收集阶段还需要预留足够内存空间提供给用户线程使用</strong>， 在JDK 5的默认设置下， CMS收集的阈值是68%。JDK 6时，阈值默认提升至92%。但如果预留的内存无法满足程序分配新对象的需要， 就会出现一次“<strong>并发失败</strong>”(Concurrent Mode Failure) ， <strong>这时虚拟机将启动后备预案：冻结用户线程的执行， 临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了</strong>。</p>
<blockquote>
<p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
</blockquote>
</li>
<li><p><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</strong>。它开创了<strong>收集器面向局部收集</strong>的设计思路和<strong>基于Region的内存布局</strong>形式。</p>
<blockquote>
<p>JDK9发布时，G1取代Parallel Scavenge+Parallel Old组合，是服务端模式下的默认收集器，而CMS被声明为不被推荐。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>基于Region的内存布局</strong>：</p>
<p>在G1收集器出现之前的所有其他收集器， 包括CMS在内， 垃圾收集的目标范围要么是整个新生代(MinorGC) 、整个老年代(Major GC) 、或整个Java堆(Full GC) 。<strong>而G1可以面向堆内存任何部分来组成回收集(Collection Set， 一般简称CSet) 进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大</strong>， 这就是G1收集器的Mixed GC模式。</p>
<p>G1仍是遵循分代收集理论，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分， <strong>而是把连续的Java堆划分为多个大小相等的独立区域(Region) ， 每一个Region都可以根据需要， 扮演新生代的Eden空间、Survivor空间，或者老年代空间</strong>。</p>
<blockquote>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围为1MB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中， </p>
</blockquote>
<p>&emsp;&emsp;</p>
<p>总结G1的一些特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的</strong>。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，停顿时间模型即<strong>支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>G1 收集器的运作大致分为以下几个步骤（具体P101）：</p>
<ul>
<li><strong>初始标记</strong> （<strong style="color:red">短暂STW</strong>）</li>
<li><strong>并发标记</strong> </li>
<li><strong>最终标记</strong> （<strong style="color:red">短暂STW</strong>）</li>
<li><strong>筛选回收</strong> （<strong style="color:red">STW</strong>）</li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（这也就是它的名字 Garbage-First 的由来）</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p>&emsp;&emsp;</p>
<h3 id="Shenandoah收集器-to-be…"><a href="#Shenandoah收集器-to-be…" class="headerlink" title="Shenandoah收集器(to be…)"></a>Shenandoah收集器(to be…)</h3><p>&emsp;&emsp;</p>
<h3 id="ZGC收集器-to-be…"><a href="#ZGC收集器-to-be…" class="headerlink" title="ZGC收集器(to be…)"></a>ZGC收集器(to be…)</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a> </p>
<p>&emsp;&emsp;</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide-Note</a> </p>
<p>《深入理解JVM》第3版</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bxxiao</p>
  <div class="site-description" itemprop="description">do nothing, nothing there</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bxxiao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bxxiao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bxxiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
