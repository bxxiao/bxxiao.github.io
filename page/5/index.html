<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="bxxiao">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="bxxiao">
<meta property="og:description" content="nothing">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bxxiao">
<meta property="article:tag" content="bxxiao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>bxxiao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bxxiao" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bxxiao</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">类加载器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:58:25" itemprop="dateModified" datetime="2021-08-30T12:58:25+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>类的 “加载阶段” 由类加载器完成</strong>。Java 支持以下 4 种类型的类加载器：</p>
<p>前 3 种是 Java 虚拟机内置的类加载器，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ul>
<li><p><strong>启动（根）类加载器</strong>（<strong>BootstrapClassLoader</strong>）：最顶层的加载类，没有继承<code>java.ang.ClassLoader</code>类。<strong>由C++实现</strong>，主要负责加载Java核心类库，加载<code>%JAVA_HOME%/lib</code>目录下的**<code>rt.jar</code>**、<code>resources.jar、charsets.jar和class</code>等（是按文件名识别的）。或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类（系统属性<code>sun.boot.class.path</code>）。</p>
</li>
<li><p><strong>扩展类加载器</strong>（<strong>ExtensionClassLoader</strong>）：它的<strong>父加载器为根类加载器</strong>。它从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或者从JDK的安装目录的 <code>jre\lib\ext</code>子目录下加载jar和class文件。<strong>这个文件夹可以用于放置具有通用性的类库</strong>，以扩展JavaE功能。</p>
</li>
<li><p><strong>应用（系统）类加载器</strong>（<strong>System/AppClassLoader</strong>）：它的<strong>父加载器为扩展类加载器</strong>。它<strong>从环境变量classpath或者系统属性<code>java.class.path</code>所指定的目录中加载类</strong>（jdk默认的<code>java.class.path</code>是<code>.</code>，即当前目录，在idea中运行时会为该属性添加其他路径）。AppClassLoader是<strong>用户自定义的类加载器的默认父加载器</strong>。</p>
</li>
<li><p>用户自定义类加载器。通过创建<code>java.lang.ClassLoader</code>的子类实现，用户可定制类的加载方式。</p>
</li>
</ul>
<p>4种类加载器的<strong>层次关系</strong>：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210121142323383.png" alt="image-20210121142323383" style="zoom:80%;" />

<p>&emsp;&emsp;</p>
<p>一般认为上一层加载器是下一层加载器的父加载器，除了BootstrapClassLoader之外，所有的加载器都是有父加载器的。</p>
<p><strong>双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的</strong>。源码体现：在ClassLoader中关于父加载器的定义：<code>private final ClassLoader parent;</code> </p>
<p>&emsp;&emsp;</p>
<p><strong>Ext loader、App loader以及<code>java.lang.ClassLoader</code>是由启动类加载器加载的</strong>。</p>
<p>类加载器并<strong>不需要等到某个类被“首次主动使用”时再加载它</strong>，JVM规范允许类加载器<strong>在预料某个类将要被使用时就预先加载它</strong>，如果在预先加载的过程中遇到了. class文件缺失或存在错误，类加载器<strong>必须在程序首次主动使用该类时才报告错误</strong>（Linkage Error错误）<strong>如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</strong>。</p>
<p>&emsp;&emsp;</p>
<blockquote>
<p>查看3个JVM类加载器中3个属性包含的路径：执行，可以看到java.class.path的输出中包含当前项目的classes路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span></span><br><span class="line"></span><br><span class="line">    String property = System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line">    String property1 = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">    String property2 = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">    print(property);</span><br><span class="line">    print(property1);</span><br><span class="line">    print(property2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String property)</span></span>&#123;</span><br><span class="line">    String[] properties = property.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : properties) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>可通过修改系统属性java.system.class.loader来将自定义类加载器作为app loader。</p>
</blockquote>
<p>相关demo：（JVMDemo/classloader/MyTest16   JVMDemo\classloader\MyTest13）</p>
<p>&emsp;&emsp;</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。当一个类不能通过JVM内置3个类加载器加载时，比如需要通过网络加载，则需要继承ClassLoader创建子类，自定义类加载器。</p>
<p>获取ClassLoader的几种方式：</p>
<ul>
<li>获得当前类的Clas Loader：<code>clazz.getClassloader</code> </li>
<li>获得当前线程上下文ClassLoader：<code>Thread. currentThread().getContextClassLoader()</code> </li>
<li>获得系统ClassLoader：<code>Classloader.getSystemClassLoader()</code>（获取AppClassLoader）</li>
<li><strong>获得调用者的ClassLoader</strong>：<code>DriverManager.getCallerClassLoader()</code> </li>
</ul>
<blockquote>
<p>调用ClassLoader的<code>loadClass()</code>方法时，只会对类进行加载和连接，不会执行初始化操作。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>ClassLoader的部分javadoc及其翻译★</strong>：一些点</p>
<ul>
<li><strong>数组的Class对象不是由类加载器创建，而是在JVM运行时自动创建的</strong>。</li>
<li><strong>调用数组的Class对象的getClassLoader()方法返回的类加载器，与其数组元素返回的一样。而如果其数组元素是原生类型，则该数组没有类加载器</strong>。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">class</span> loader is an <span class="keyword">object</span> that is responsible <span class="keyword">for</span> loading classes. The <span class="keyword">class</span> ClassLoader is an </span><br><span class="line"></span><br><span class="line">abstract <span class="keyword">class</span>. Given the binary name <span class="keyword">of</span> a <span class="keyword">class</span>， a <span class="keyword">class</span> loader should attempt <span class="keyword">to</span> locate <span class="keyword">or</span> generate data that constitutes a definition <span class="keyword">for</span> the <span class="keyword">class</span>. </span><br><span class="line">A typical strategy is <span class="keyword">to</span> transform the name into a file name <span class="keyword">and</span> <span class="keyword">then</span> read a <span class="string">&quot;class file&quot;</span> <span class="keyword">of</span> that name from a file system.</span><br><span class="line">一种典型的策略是，将给定的name转换为文件名，并从文件系统中读取对应的<span class="keyword">class</span>文件。</span><br><span class="line">Every Class <span class="keyword">object</span> contains a reference <span class="keyword">to</span> the ClassLoader that defined it.</span><br><span class="line">每一个Class对象包含一个定义了该Class对象的ClassLoader的引用</span><br><span class="line"></span><br><span class="line">Class objects <span class="keyword">for</span> <span class="built_in">array</span> classes are not created by <span class="keyword">class</span> loaders， but are created automatically <span class="keyword">as</span> required by the Java runtime. </span><br><span class="line">数组的Class对象不是由类加载器创建，而是在JVM运行时自动创建的。</span><br><span class="line">The <span class="keyword">class</span> loader <span class="keyword">for</span> an <span class="built_in">array</span> <span class="keyword">class</span>， <span class="keyword">as</span> returned by <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>get<span class="constructor">ClassLoader()</span> is the same <span class="keyword">as</span> the <span class="keyword">class</span> loader <span class="keyword">for</span> its element <span class="keyword">type</span>; <span class="keyword">if</span> the element <span class="keyword">type</span> is a primitive <span class="keyword">type</span>， <span class="keyword">then</span> the <span class="built_in">array</span> <span class="keyword">class</span> has no <span class="keyword">class</span> loader.</span><br><span class="line">调用数组的Class对象的get<span class="constructor">ClassLoader()</span>方法返回的类加载器，与其数组元素返回的一样。而如果其数组元素是原生类型，则该数组没有类加载器。</span><br><span class="line"></span><br><span class="line">Applications implement subclasses <span class="keyword">of</span> ClassLoader <span class="keyword">in</span> order <span class="keyword">to</span> extend the manner <span class="keyword">in</span> which the Java <span class="keyword">virtual</span> machine dynamically loads classes.</span><br><span class="line">应用程序实现类加载器的子类，来扩展JVM动态加载类的方式。</span><br><span class="line"></span><br><span class="line">Class loaders may typically be used by security managers <span class="keyword">to</span> indicate security domains.</span><br><span class="line"></span><br><span class="line">The ClassLoader <span class="keyword">class</span> uses a delegation model <span class="keyword">to</span> search <span class="keyword">for</span> classes <span class="keyword">and</span> resources. </span><br><span class="line">ClassLoader类使用委托机制来寻找类和资源</span><br><span class="line"></span><br><span class="line">Each instance <span class="keyword">of</span> ClassLoader has an associated parent <span class="keyword">class</span> loader. When requested <span class="keyword">to</span> find a <span class="keyword">class</span> <span class="keyword">or</span> resource， a ClassLoader instance will delegate the search <span class="keyword">for</span> the <span class="keyword">class</span> <span class="keyword">or</span> resource <span class="keyword">to</span> its parent <span class="keyword">class</span> loader before attempting <span class="keyword">to</span> find the <span class="keyword">class</span> <span class="keyword">or</span> resource itself. </span><br><span class="line">每一个ClassLoader的实例都有一个与之关联的父ClassLoader。当被要求寻找一个类或资源时，ClassLoader实例在尝试自己寻找之前，会先委托给父ClassLoader去执行。</span><br><span class="line"></span><br><span class="line">The <span class="keyword">virtual</span> machine&#x27;s built-<span class="keyword">in</span> <span class="keyword">class</span> loader， called the <span class="string">&quot;bootstrap class loader&quot;</span>， does not itself have a parent but may serve <span class="keyword">as</span> the parent <span class="keyword">of</span> a ClassLoader instance.</span><br><span class="line">JVM有一个内建ClassLoader叫做bootstrap <span class="keyword">class</span> loader，它本身没有父类，但可以作为类加载器实例的父类</span><br><span class="line"></span><br><span class="line">Class loaders that support concurrent loading <span class="keyword">of</span> classes are known <span class="keyword">as</span> parallel capable <span class="keyword">class</span> loaders <span class="keyword">and</span> are required <span class="keyword">to</span> register themselves at their <span class="keyword">class</span> initialization time by invoking the <span class="module-access"><span class="module"><span class="identifier">ClassLoader</span>.</span></span>registerAsParallelCapable <span class="keyword">method</span>. </span><br><span class="line">Note that the ClassLoader <span class="keyword">class</span> is registered <span class="keyword">as</span> parallel capable by default.</span><br><span class="line">However， its subclasses still need <span class="keyword">to</span> register themselves <span class="keyword">if</span> they are parallel capable. </span><br><span class="line">支持并发加载的ClassLoader被称为可并行的类加载器，</span><br><span class="line">且它们被要求在初始化时通过调用<span class="module-access"><span class="module"><span class="identifier">ClassLoader</span>.</span></span>registerAsParallelCapable方法进行注册。</span><br><span class="line">注意ClassLoader类默认会被注册。然而它的子类依然需要自行进行注册（如果需要并行能力）</span><br><span class="line"></span><br><span class="line">In environments <span class="keyword">in</span> which the delegation model is not strictly hierarchical， <span class="keyword">class</span> loaders need <span class="keyword">to</span> be parallel capable， otherwise <span class="keyword">class</span> loading can lead <span class="keyword">to</span> deadlocks because the loader lock is held <span class="keyword">for</span> the duration <span class="keyword">of</span> the <span class="keyword">class</span> loading process (see loadClass methods).</span><br><span class="line"></span><br><span class="line">Normally， the Java <span class="keyword">virtual</span> machine loads classes from the local file system <span class="keyword">in</span> a platform-dependent manner. For example， on UNIX systems， the <span class="keyword">virtual</span> machine loads classes from the directory defined by the CLASSPATH environment variable.</span><br><span class="line"></span><br><span class="line">However， some classes may not originate from a file; they may originate from other sources， such <span class="keyword">as</span> the network， <span class="keyword">or</span> they could be constructed by an application.</span><br><span class="line">然而，某些<span class="keyword">class</span>文件不是来源于文件，可能是来自其他来源，如网络、或者被程序创建。</span><br><span class="line">The <span class="keyword">method</span> defineClass converts an <span class="built_in">array</span> <span class="keyword">of</span> <span class="built_in">bytes</span> into an instance <span class="keyword">of</span> <span class="keyword">class</span> Class. Instances <span class="keyword">of</span> this newly defined <span class="keyword">class</span> can be created using <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>newInstance.</span><br><span class="line">defineClass方法可以将一个字节数组转换为一个Class对象，且可以通过<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance()</span>方法来创建这个Class对应的类实例。</span><br><span class="line"></span><br><span class="line">The methods <span class="keyword">and</span> constructors <span class="keyword">of</span> objects created by a <span class="keyword">class</span> loader may reference other classes. To determine the <span class="keyword">class</span>(es) referred <span class="keyword">to</span>， the Java <span class="keyword">virtual</span> machine invokes the loadClass <span class="keyword">method</span> <span class="keyword">of</span> the <span class="keyword">class</span> loader that originally created the <span class="keyword">class</span>.</span><br><span class="line">类加载器创建的对象的方法和构造函数可以引用其他类。要确定引用的类，Java虚拟机调用最初创建类的类装入器的loadClass方法</span><br><span class="line">For example， an application could create a network <span class="keyword">class</span> loader <span class="keyword">to</span> download <span class="keyword">class</span> files from a server. Sample code might look like:</span><br><span class="line">     ClassLoader loader = <span class="keyword">new</span> <span class="constructor">NetworkClassLoader(<span class="params">host</span>， <span class="params">port</span>)</span>;</span><br><span class="line">     Object main = loader.load<span class="constructor">Class(<span class="string">&quot;Main&quot;</span>， <span class="params">true</span>)</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line">          . . .</span><br><span class="line">   </span><br><span class="line">The network <span class="keyword">class</span> loader subclass must define the methods findClass <span class="keyword">and</span> loadClassData <span class="keyword">to</span> load a <span class="keyword">class</span> from the network. Once it has downloaded the <span class="built_in">bytes</span> that make up the <span class="keyword">class</span>， it should use the <span class="keyword">method</span> defineClass <span class="keyword">to</span> create a <span class="keyword">class</span> instance. </span><br><span class="line">网络类加载器的子类必须定义find<span class="constructor">Class()</span>和load<span class="constructor">ClassData()</span>方法（也可其他命名）用于加载来源于网络的类，用于从网络中加载类。一旦它下载了组成类的字节，它就应该使用defineClass方法来创建对应的Class对象。</span><br><span class="line">A sample implementation is:（示例）</span><br><span class="line">       <span class="keyword">class</span> NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">           String host;</span><br><span class="line">           <span class="built_in">int</span> port;</span><br><span class="line">  </span><br><span class="line">           public Class find<span class="constructor">Class(String <span class="params">name</span>)</span> &#123;</span><br><span class="line">               byte<span class="literal">[]</span> b = load<span class="constructor">ClassData(<span class="params">name</span>)</span>;</span><br><span class="line">               return define<span class="constructor">Class(<span class="params">name</span>， <span class="params">b</span>， 0， <span class="params">b</span>.<span class="params">length</span>)</span>;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="keyword">private</span> byte<span class="literal">[]</span> load<span class="constructor">ClassData(String <span class="params">name</span>)</span> &#123;</span><br><span class="line">               <span class="comment">// load the class data from the connection</span></span><br><span class="line">                . . .</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="2-双亲委托机制"><a href="#2-双亲委托机制" class="headerlink" title="2. 双亲委托机制"></a>2. 双亲委托机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每一个类都有一个对应它的类加载器。系统中的ClassLoder在工作时<strong>默认</strong>使用 <strong>双亲委派机制</strong> ：</p>
<ul>
<li>当一个类加载器收到加载类的请求时，<strong>它不会直接去加载指定的类，而是首先判断当前类是否被加载过</strong>。已经被加载的类会直接返回，<strong>否则才会尝试加载</strong>。</li>
<li><strong><font color="red">加载时，类加载器首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理</font>（若检查到父类加载器为null，则使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器，并让其尝试加载指定类）</strong>。所有的请求最终都传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li><strong>如果父类加载器无法处理，才由自己调用<code>findClass()</code>方法尝试加载类</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p><strong>即自底向上检查是否被加载过，再自顶向下尝试加载</strong>。</p>
<p>（<strong>当ClassLoder的parent为null时，表示其parent为BootstrapClassLoader</strong>）</p>
<p>图片来自Guide哥文档（<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?id=%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e6%80%bb%e7%bb%93">链接</a>）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="classloader_WPS图片"></p>
<blockquote>
<p>加载类的类加载器称为定义类加载器，返回已经被加载的类的类加载器称为初始化类加载器。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong><font color="red">双亲委派机制在ClassLoader的<code>loadClass()</code>方法中体现</font></strong>：（来自Guide哥文档<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?id=%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e6%80%bb%e7%bb%93">链接</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name， <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name， <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><strong>每个Class对象都对应一个加载它的类加载器，每个类加载器都有一个父类加载器（若为null表示父类加载器为BootstrapClassLoader）</strong>。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = MyTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>b6d3586</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>自定义的类由AppClassLoader加载，AppClassLoader的父类加载器是ExtClassLoader，ExtClassLoader的父类加载器是BootstrapClassLoader（表示为null）</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="双亲委托机制的优点"><a href="#双亲委托机制的优点" class="headerlink" title="双亲委托机制的优点"></a>双亲委托机制的优点</h3><ul>
<li><strong>双亲委派机制保证了Java程序的稳定运行，可以避免类的重复加载</strong>（JVM 区分不同类的方式是根据类的全限定名（binary name）和用于加载该类的定义类加载器）。当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。</li>
<li><strong>保证了安全性，使 Java 的核心 API 不被篡改</strong>。因为在该机制下，用户自定义类加载器不能加载应由根类加载器加载的核心类库，防止不可靠或恶意代码代替Java核心类库。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="打破双亲委托机制"><a href="#打破双亲委托机制" class="headerlink" title="打破双亲委托机制"></a>打破双亲委托机制</h3><p>自定义加载器需要继承 <code>ClassLoader</code> 。如果不想打破双亲委派机制，重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，因为默认的loadClass()实现会调用该方法（当父加载器无法加载指定类时）。无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p><strong>如果想打破双亲委派机制则需要重写 <code>loadClass()</code> 方法</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="loadClass-、findClass-、definclass-区别"><a href="#loadClass-、findClass-、definclass-区别" class="headerlink" title="loadClass()、findClass()、definclass()区别"></a>loadClass()、findClass()、definclass()区别</h3><ul>
<li>loadClass() 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。</li>
<li>findClass() 根据名称或位置加载.class字节码文件</li>
<li>definclass() 把字节码转化为Class对象</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="3-类加载器命名空间"><a href="#3-类加载器命名空间" class="headerlink" title="3. 类加载器命名空间"></a>3. 类加载器命名空间</h2><ul>
<li><strong>每个类加载器都有自己的命名空间，命名空间由<font color="red">该加载器及所有父加载器所加载的类</font>组成</strong>。</li>
<li><strong>一个类在JVM中的唯一性由这个类本身和它的类加载器决定</strong>。</li>
<li>在同一个命名空间中，不会出现类的全限定名相同的两个类。</li>
<li>在不同的命名空间中，有可能会出现全限定名相同的两个类。</li>
<li><strong>子加载器所加载的类能够访问父加载器所加载的类</strong>。</li>
<li><strong>父加载器所加载的类无法访问到子加载器所加载的类</strong>。</li>
<li>如果两个类加载器之间没有间接或直接的父子关系，则被这两个类加载器所加载的类互不可见。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>若是自定义了多个类加载器，则可能会出现同一个类加载多次的情况，<strong>JVM 是根据类的全限定名（binary name）和用于加载该类的定义类加载器区分不同类的，如果相同全限定名的类是由两个不同的加载器所加载，那么这些类就是不同的，即使class文件的字节码完全一样，并且从相同的位置加载</strong>。（验证示例见JVMDemo/test14）</p>
<p>&emsp;&emsp;</p>
<p><strong>默认情况下，<font color="red">如果一个类由A类加载器加载，则该类的依赖类也由A加载（若被依赖类未被加载）</font></strong>。这时可能会出现以下异常情况：（见<code>JVMDemo\classloader\test12</code>）</p>
<ul>
<li>内外两个类位于不同命名空间的情况，<strong>即被不同的类加载器加载</strong>。</li>
<li><strong>被包含类不能被加载成功的情况</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="4-自定义类加载器示例"><a href="#4-自定义类加载器示例" class="headerlink" title="4. 自定义类加载器示例"></a>4. 自定义类加载器示例</h2><p>示例（使用双亲委派机制）：</p>
<p>自定义类加载器：</p>
<ul>
<li>重写ClassLoader的<code>findClass(String name)</code>方法，<strong>在使用该类加载器加载类时，该方法会被<code>loadClass()</code>方法调用</strong>。</li>
<li>当父类加载器无法加载指定类时，会由该类加载器进行加载，此时<code>loadClass()</code>方法会调用<code>findClass(String name)</code>方法，在该方法中又调用<code>loadClassData()</code>方法来从指定路径读取 .class文件，返回对应的字节数组。</li>
<li>再通过<code>defineClass()</code>（<strong>继承自ClassLoader的方法，底层由C++实现</strong>）方法加载类，返回对应的Class对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//默认使用系统类加载器作为双亲委托</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent， String classLoaderName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);<span class="comment">//自行指定双亲委托</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.classLoaderName + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//★★</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClassLoader.findClass&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name， data， <span class="number">0</span>， data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//★★</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] loadClassData(String name)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;self define loadCLassData&quot;</span>);</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        name = name.replace(<span class="string">&quot;.&quot;</span>， <span class="string">&quot;\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.path + name + <span class="keyword">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span> != (ch=is.read()))&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>测试：（若父类加载器无法加载MyTest1类，则在E:\AAAFrequently-used\temp\路径下读取MyTest1类的 .class 文件并创建Class对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;E:\\AAAFrequently-used\\temp\\&quot;</span>;</span><br><span class="line">    MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">    loader.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;classloader.MyTest1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    System.out.println(<span class="string">&quot;class: &quot;</span> + clazz.hashCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;class loader: &quot;</span> + obj.getClass().getClassLoader());</span><br><span class="line">    System.out.println(<span class="string">&quot;class&#x27; instance: &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;loader2&quot;</span>);<span class="comment">//---1----</span></span><br><span class="line">    loader2.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">&quot;classloader.MyTest1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object obj2 = clazz2.newInstance();</span><br><span class="line">    System.out.println(<span class="string">&quot;class: &quot;</span> + clazz2.hashCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;class loader: &quot;</span> + obj2.getClass().getClassLoader());</span><br><span class="line">    System.out.println(<span class="string">&quot;class&#x27; instance: &quot;</span> + obj2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时loader1、loader2的父类加载器都是系统类加载器，运行结果：</p>
<ul>
<li><p>若是当前项目的classpath路径下有MyTest1的 .class 文件时，<strong>根据双亲委派机制</strong>，MyTest1将由系统类加载器进行加载，因此创建的两个Class实例相同：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">460141958</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@4554617c</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">460141958</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@74a14482</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把classpath下的MyTest1.class移除，放到<code>E:\AAAFrequently-used\temp\classloader</code>路径下，重新运行程序。<strong>因为loader1、loader2的父类加载器都无法加载MyTest1，所以最后会由它们进行加载，此时会加载出两个MyTest1的Class对象</strong>：</p>
<p><strong><font color="red">这两个Class位于不同的命名空间</font></strong>。</p>
<p>输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self define loadCLassData</span><br><span class="line">MyClassLoader.findClass</span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">1956725890</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader1]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@1540e19d</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self define loadCLassData</span><br><span class="line">MyClassLoader.findClass</span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">2133927002</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader2]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@6d6f6e28</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把–1–处代码改为<code>MyClassLoader loader2 = new MyClassLoader(loader， &quot;loader2&quot;);</code>，即loader2的父类加载器是loader1。重新运行程序。<strong>根据双亲委派机制，因为其父类加载器loader1已完成MyTest1的加载，所以loader2不会重新加载类，返回loader1创建的Class对象</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self define loadCLassData</span><br><span class="line">MyClassLoader.findClass</span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">1956725890</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader1]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@1540e19d</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>: <span class="type">1956725890</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loader</span>: <span class="type">[loader1]</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&#x27; <span class="title">instance</span>: <span class="type">classloader.MyTest1@677327b6</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
</li>
</ul>
<h2 id="5-线程上下文类加载器"><a href="#5-线程上下文类加载器" class="headerlink" title="5. 线程上下文类加载器"></a>5. 线程上下文类加载器</h2><p>线程上下文类加载器（Thread Context ClassLoader，<strong>since jdk1.2</strong>）可用于解决某些双亲委托机制无法适应的情况，主要为了解决SPI（Service Provider Interface，服务提供接口）的问题。</p>
<p>SPI即一组接口或抽象类，没有具体实现。jdk中的一些SPI的具体实现由Java核心类库提供，这些SPI和具体实现都可以被启动类加载器所加载。而对于某些SPI，如jdbc的SPI，其具体实现由第三方提供，<strong>若是遵循双亲委托机制，则它们无法通过启动类加载器来加载，这时可以就可以使用线程上下文类加载器来加载这些具体实现</strong>。Context ClassLoade破坏了双亲委托机制。</p>
<p>即<strong><font color="red">当高层提供了统一的接口让低层实现，同时又需要在高层加载这些具体实现，则需要使用Context ClassLoader来寻找并加载这些类</font></strong>。</p>
<p>Context ClassLoader通过<code>Thread.currentThread().getContextClassLoader()</code>获取，<strong>若无显式指定，则默认为系统类加载器</strong>。</p>
<p>Context ClassLoade的一般使用模式是：获取-》使用-》还原：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	Thread.currentThread().setContextClassLoader(targetTccl);</span><br><span class="line">	myMethod();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//还原</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，在<code>myMethod();</code>中通过<code>Thread.currentThread().getContextClassLoader();</code>获取线程上下文类加载器来加载某些类（服务提供者）。</p>
<p>ServiceLoader类是jdk提供的一个用于加载服务具体实现的类，具体见源码分析笔记。</p>
<hr>
<p>参考：</p>
<ul>
<li><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">Guide-类的加载过程</a> </p>
</li>
<li><p><a href="https://gu_chun_bo.gitee.io/java-construct/#/jvm%E5%AD%A6%E4%B9%A0/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">jvm-类加载过程</a> </p>
</li>
<li><p>《疯狂Java讲义》</p>
</li>
<li><p>《深入理解JVM》</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6kedGPZP4iTDuK-Wuzym4Q">十个双亲委派问题</a> </p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:58:17" itemprop="dateModified" datetime="2021-08-30T12:58:17+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<p>对于程序计数器、虚拟机栈、本地方法栈，这几个区域的内存分配和回收都具有确定性，它们随着线程结束或方法结束时回收内存。<strong>而堆和方法区则有很大的不确定性：只有到运行期才能知道程序要创建哪些对象，创建多少对象，它们的内存分配和回收是动态的</strong>。</p>
<p>&emsp;&emsp;</p>
<p>Java 的自动内存管理<strong>主要是针对对象内存的回收和对象内存的分配</strong>。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong> </p>
<p><strong>堆空间的基本结构</strong>（图片来自javaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129095613698.png" alt="image-20210129095613698"></p>
<p>&emsp;&emsp;</p>
<h2 id="判断对象已死"><a href="#判断对象已死" class="headerlink" title="判断对象已死"></a>判断对象已死</h2><p>垃圾收集器对堆回收之前需要判断哪些对象存活，哪些死亡（<strong>即不能再被任何途径使用的对象</strong>）。有<strong>引用计数算法和可达性分析算法</strong>两种判断方式。</p>
<p>&emsp;&emsp;</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；<strong>任何时候计数器为 0 的对象就是不可能再被使用的</strong>。</p>
<p>这个方法实现简单，效率高，但是目前<strong>主流的虚拟机中并没有选择这个算法</strong>来管理内存，其最主要的原因是它<strong>很难解决对象之间相互循环引用的问题</strong>。</p>
<p>循环依赖示例：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，<strong>于是引用计数算法无法通知 GC 回收器回收他们</strong>。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是<strong>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的</strong>。</p>
<p><strong>可作为 GC Roots 的对象</strong>包括下面几种:</p>
<ul>
<li><strong>虚拟机栈</strong>(栈帧中的本地变量表)中引用的对象</li>
<li><strong>本地方法栈</strong>(Native 方法)中引用的对象</li>
<li><strong>方法区</strong>中<strong>类静态属性引用</strong>的对象</li>
<li><strong>方法区</strong>中<strong>常量引用的对象</strong> </li>
<li>Java虚拟机内部引用，如基本类型对应的Class对象，系统类加载器、常驻异常对象等。</li>
<li>被同步锁（synchronized关键字）持有的对象。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p><strong>JDK1.2 之前</strong>，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p><strong>JDK1.2 以后</strong>，Java 对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种（<strong>引用强度逐渐减弱</strong>）。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。<strong>在任何情况下，只要这个强引用存在，垃圾回收器绝不会回收它</strong>。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>&emsp;&emsp;</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述一些<strong><font color="red">还有用，但非必须的对象</font></strong>。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存</strong>。</p>
<p>软引用<strong>可以和一个引用队列（ReferenceQueue）联合使用</strong>，如果<strong>软引用所引用的对象被垃圾回收</strong>，JAVA 虚拟机就会<strong>把这个软引用</strong>加入到与之关联的引用队列中。后续可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。</p>
<p>&emsp;&emsp;</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，<strong style="color:red">它只能生存到下一次垃圾收集发生</strong>。</p>
<p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>&emsp;&emsp;</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<font color="red">虚引用主要用来跟踪对象被垃圾回收的活动</font></strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用<strong>必须和引用队列</strong>（ReferenceQueue）<strong>联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<strong>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收</strong>。程序如果发现某个虚引用已经被加入到引用队列，那么就<strong>可以在所引用的对象的内存被回收之前采取必要的行动</strong>。</p>
<p>&emsp;&emsp;</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="“非死不可”？"><a href="#“非死不可”？" class="headerlink" title="“非死不可”？"></a>“非死不可”？</h3><p><strong>即使在可达性分析法中不可达的对象，也并非是“非死不可”的</strong>，这时候它们暂时处于“缓刑阶段”，要<strong>真正宣告一个对象死亡，至少要经历两次标记过程</strong>：可达性分析法中不可达的对象被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p><strong>被判定为需要执行的对象将会被放在一个队列中，并由一个低优先级线程去执行它们的<code>finalize()</code>方法</strong>，除非这个对象在<code>finalize()</code>方法中与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<p><strong style="color:red">这种“自救”不推荐被使用</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p><strong>方法区也是垃圾回收的对象区域</strong>，这里的垃圾收集主要包含两部分内容：<strong>废弃的常量和不再使用的类型</strong>。方法区的垃圾收集通常“性价比”比较低。</p>
<h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><p>运行时常量池主要回收的是废弃的常量。判断一个常量是否废弃：</p>
<p><strong>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了</strong>。</p>
<p>&emsp;&emsp;</p>
<p><strong><font color="red">关于常量池，方法区，元空间</font></strong>：</p>
<ol>
<li>JDK1.7 <strong>之前</strong>运行时常量池逻辑包含字符串常量池存放在方法区， 此时 HotSpot 虚拟机对方法区的实现为永久代</li>
<li><strong>JDK1.7  字符串常量池 被从方法区拿到了堆中</strong>， 这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区， 也就是 HotSpot 中的永久代 。</li>
<li>JDK1.8 HotSpot 移除了永久代用元空间(Metaspace)取而代之，<strong><font color="red"> 这时候字符串常量池还在堆， 运行时常量池还在方法区， 只不过方法区的实现从永久代变成了元空间</font></strong>(Metaspace)。</li>
</ol>
<p>&emsp;&emsp;</p>
<h4 id="回收类"><a href="#回收类" class="headerlink" title="回收类"></a>回收类</h4><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p>
<p>类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<blockquote>
<p>在大量使用反射、动态代理、CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 通常都需要Java虚拟机具备类型卸载的能力， <strong>以保证不会对方法区造成过大的内存压力</strong>。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集理论的3个经验法则：</p>
<ul>
<li><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p>
</li>
<li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
</li>
<li><p>跨代引用假说：跨代引用相对于同代引用来说占极少数。</p>
<blockquote>
<p>假如要进行一次只局限于新生代区域内的收集(Minor GC) ， <strong>但新生代中的对象是完全有可能被老年代所引用的</strong>， 为了找出该区域中的存活对象， 不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。但无疑会为内存回收带来很大的性能负担。为了解决这个问题，于是添加了第3个经验法则。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p>分代收集理论放到具体的JVM中，设计者一般至少把Java堆划分为新生代和老年代。在Java堆划分出不同的区域之后，<strong>垃圾收集器才可以每次只回收其中某一个或者某些部分的区域</strong>——因而有了“Minor GC”、“Major GC”、“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。</p>
<p>&emsp;&emsp;</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</strong>。（或者反过来标记不需要回收的对象）</p>
<p>它是<strong>最基础的收集算法，后续的算法都是对其不足进行改进得到</strong>。这种垃圾收集算法会带来两个明显的问题：</p>
<ul>
<li><p><strong>效率问题</strong>。如果堆中很多对象需要回收，这时必须进行大量清除和标记的动作。</p>
</li>
<li><p><strong>内存碎片问题（标记清除后会产生大量不连续的碎片）</strong> </p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。<strong>它将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收</strong>。</p>
<p>这样实现简单，运行高效，<strong>缺陷也明显，可用内存缩小了一半，且当对象存活率较高时，该算法效率较低</strong>。</p>
<p>&emsp;&emsp;</p>
<p>针对内存浪费太多的改进（Appel式回收）：<strong>把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间</strong>。HotSpot虚拟机<strong>默认Eden和Survivor的大小比例是8：1</strong>， 只有10%的新生代是会被“浪费”的。</p>
<p>但也没有办法保证每次回收都只有不多于10%的对象存活， 因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计， 当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（<strong>实际上大多就是老年代</strong>）进行分配担保(Handle Promotion) </p>
<p>&emsp;&emsp;</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法不适合老年代，因为老年代的回收率低，需要复制的对象太多。<strong style="color:red">标记-整理算法是针对老年代的</strong>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<strong>而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</strong>。</p>
<p>图示（来自JavaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129150506762.png" alt="image-20210129150506762"></p>
<p>&emsp;&emsp;</p>
<p>标记-清除、标记-整理的<strong>本质区别在于是不是移动式的回收算法</strong>。是否移动对象都存在弊端：</p>
<ul>
<li>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，<strong>移动存活对象并更新所有引用这些对象的地方</strong>将会是一种极为负重的操作，<strong>而且这种对象移动操作必须全程暂停用户应用程序才能进行</strong>（“<strong style="color:red">Stop The World</strong>”）。</li>
<li>但如果完全不考虑移动和整理存活对象，<strong>弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配策略来解决</strong>。</li>
</ul>
<p><strong>移动则内存回收时会更复杂，不移动则内存分配时会更复杂</strong>。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是<strong style="color:red">从总的来说，移动对象会更划算</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块</strong>。一般将 java 堆分为新生代和老年代，<strong style="color:red">这样就可以根据各个年代的特点选择合适的垃圾收集算法</strong>。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<blockquote>
<p> <strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？根据上面的对分代收集算法的介绍回答。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器。这个收集器是一个<strong>单线程收集器</strong>。它的 <strong>“单线程” 的意义</strong>不仅仅意味着它<strong>只会使用一条垃圾收集线程去完成垃圾收集工作</strong>，<strong style="color:red">而且它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束</strong>。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。如图（来自《深入理解JVM》</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155016436.png" alt="image-20210129155016436"></p>
<p>Serial不是已无用的”鸡肋“，<strong>它是HotSpot运行在客户端模式下的默认<font color="red">新生代</font>收集器</strong>。它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器<strong>没有线程交互的额外开销</strong>，可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
<p>&emsp;&emsp;</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样</strong>。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。（图片来自JavaGuide)</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210129155850631.png" alt="image-20210129155850631" style="zoom:80%;" />

<p><strong>它是许多运行在 Server 模式下的虚拟机的首要选择</strong>，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。</p>
<p><strong>在谈论垃圾收集器的上下文语境中，并行和并发概念可理解为：</strong> </p>
<ul>
<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，通常默认<strong>此时用户线程仍然处于等待状态</strong>。</li>
<li><strong>并发（Concurrent）</strong>：指<strong>用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行）</strong>，用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器也是<strong>使用复制算法的新生代多线程收集器，看上去几乎和 ParNew 一样</strong>。</p>
<p>其不同点在于：CMS 等垃圾收集器的关注点更多的是用户线程的<strong>停顿时间</strong>，而<strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）</strong>。停顿时间短，可以让用户有更好的体验；高吞吐量则可以充分利用处理器资源，<strong>适合在后台运算而不需要过多交互的任务</strong>。</p>
<p>所谓<strong>吞吐量</strong>就是 <strong>CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值</strong>。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合<strong>自适应调节策略</strong>，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性</strong>。</p>
<p>  &emsp;&emsp;</p>
<p><strong>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old</strong>，如果指定了<code>-XX:+UseParallelGC</code> 参数，则默认指定了</p>
<p><code>-XX:+UseParallelOldGC</code>，可以使用<code>-XX:-UseParallelOldGC</code> 来禁用该功能。</p>
<p>  &emsp;&emsp;</p>
<p>新生代采用复制算法，老年代采用标记-整理算法。（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130154438990.png" alt="image-20210130154438990"></p>
<p>&emsp;&emsp;</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial收集器的老年代版本，使用标记-整理算法，它同样是一个单线程收集器</strong>。该收集器主要也是供客户端模式下的HotSpot使用。如果在<strong>服务端模式下，主要有两大用途</strong>：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<p>&emsp;&emsp;</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法</strong>。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器组合使用。</p>
<p>&emsp;&emsp;</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep，并发标记清除）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用</strong>。CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它<strong style="color:red">第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。（并发收集、低停顿）</p>
<p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<strong>整个过程分为四个步骤</strong>：</p>
<ul>
<li><strong>初始标记</strong>（<strong style="color:red">STW</strong>）： 暂停所有的其他线程，并记录下<strong>直接与 root 相连的对象</strong>，速度很快 ；</li>
<li><strong><font color="red">并发</font>标记</strong>： <strong>GC 和用户线程一起并发运行，从GC Roots的直接关联对象开始遍历整个对象图</strong>。但在这个阶段结束，并不能保证扫描完当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以<strong>这个算法里会跟踪记录这些发生引用更新的地方</strong>。</li>
<li><strong>重新标记</strong>（<strong style="color:red">STW</strong>）： 重新标记阶段就是为了<strong>修正并发标记期间因为用户程序继续运行而导致标记产生变动</strong>的那一部分对象的<strong>标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</strong>。</li>
<li><strong><font color="red">并发</font>清除</strong>： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210130162109512.png" alt="image-20210130162109512"></p>
<p>&emsp;&emsp;</p>
<p><strong>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作， 所以从总体上来说， CMS收集器的内存回收过程是与用户线程一起并发执行的</strong>。</p>
<p>&emsp;&emsp;</p>
<p>CMS收集器有下面三个明显的缺点：</p>
<ul>
<li><p><strong>对 CPU 资源敏感；</strong> </p>
</li>
<li><p><strong>无法处理浮动垃圾； 且在垃圾收集阶段还需要预留足够内存空间提供给用户线程使用</strong>， 在JDK 5的默认设置下， CMS收集的阈值是68%。JDK 6时，阈值默认提升至92%。但如果预留的内存无法满足程序分配新对象的需要， 就会出现一次“<strong>并发失败</strong>”(Concurrent Mode Failure) ， <strong>这时虚拟机将启动后备预案：冻结用户线程的执行， 临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了</strong>。</p>
<blockquote>
<p>在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
</blockquote>
</li>
<li><p><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</strong>。它开创了<strong>收集器面向局部收集</strong>的设计思路和<strong>基于Region的内存布局</strong>形式。</p>
<blockquote>
<p>JDK9发布时，G1取代Parallel Scavenge+Parallel Old组合，是服务端模式下的默认收集器，而CMS被声明为不被推荐。</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>基于Region的内存布局</strong>：</p>
<p>在G1收集器出现之前的所有其他收集器， 包括CMS在内， 垃圾收集的目标范围要么是整个新生代(MinorGC) 、整个老年代(Major GC) 、或整个Java堆(Full GC) 。<strong>而G1可以面向堆内存任何部分来组成回收集(Collection Set， 一般简称CSet) 进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大</strong>， 这就是G1收集器的Mixed GC模式。</p>
<p>G1仍是遵循分代收集理论，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分， <strong>而是把连续的Java堆划分为多个大小相等的独立区域(Region) ， 每一个Region都可以根据需要， 扮演新生代的Eden空间、Survivor空间，或者老年代空间</strong>。</p>
<blockquote>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围为1MB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中， </p>
</blockquote>
<p>&emsp;&emsp;</p>
<p>总结G1的一些特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的</strong>。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，停顿时间模型即<strong>支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标</strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<p>G1 收集器的运作大致分为以下几个步骤（具体P101）：</p>
<ul>
<li><strong>初始标记</strong> （<strong style="color:red">短暂STW</strong>）</li>
<li><strong>并发标记</strong> </li>
<li><strong>最终标记</strong> （<strong style="color:red">短暂STW</strong>）</li>
<li><strong>筛选回收</strong> （<strong style="color:red">STW</strong>）</li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（这也就是它的名字 Garbage-First 的由来）</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p>&emsp;&emsp;</p>
<h3 id="Shenandoah收集器-to-be…"><a href="#Shenandoah收集器-to-be…" class="headerlink" title="Shenandoah收集器(to be…)"></a>Shenandoah收集器(to be…)</h3><p>&emsp;&emsp;</p>
<h3 id="ZGC收集器-to-be…"><a href="#ZGC收集器-to-be…" class="headerlink" title="ZGC收集器(to be…)"></a>ZGC收集器(to be…)</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a> </p>
<p>&emsp;&emsp;</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide-Note</a> </p>
<p>《深入理解JVM》第3版</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/JVM/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/JVM/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" class="post-title-link" itemprop="url">Java内存区域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:58:36" itemprop="dateModified" datetime="2021-08-30T12:58:36+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>相比于 C/C++，Java 虚拟机拥有自动内存管理机制，不需要为每一个 new 操作配对对应的 delete/free 代码，不容易出现内存泄漏和内存溢出问题。而正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，<strong>一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务</strong>。</p>
<h2 id="2-运行时数据区域划分"><a href="#2-运行时数据区域划分" class="headerlink" title="2. 运行时数据区域划分"></a>2. 运行时数据区域划分</h2><p>Java 虚拟机<strong>在执行 Java 程序的过程中</strong>会把它<strong>管理的内存划分成若干个不同的数据区域</strong>。<strong>对于 jdk1.8 和之前的版本，内存的划分有一些不同</strong>，如下（图片来自JavaGuide）：</p>
<p>jdk1.8之前：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="JVM运行时数据区域"></p>
<p>jdk1.8：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/jdkJava%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" alt="jdkJava运行时数据区域JDK1.8"></p>
<h2 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h2><p>程序计数器是一块较小的内存空间，可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。其作用是：</p>
<ul>
<li><strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>。<strong>分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</strong>。</li>
<li><strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了（<strong>上下文切换</strong>）。</li>
</ul>
<p>程序计数器是一块“<strong>线程私有</strong>”的内存区域：</p>
<p><strong>为什么程序计数器是线程私有</strong>：</p>
<p>由于 Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p>
<p><strong>若线程正在执行一个Java方法，则计数器记录的是正在执行的方法对应字节码指令的地址</strong>。而若是在<strong>执行native方法，则计数器为空</strong>（Undefined）。**程序计数器不会抛出<code>OutOfMemoryError错误</code>**（《JVM规范》没有规定这种情况）</p>
<h2 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4. 虚拟机栈"></a>4. 虚拟机栈</h2><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型：<font color="red">每个Java方法被执行的时候， Java虚拟机都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态连接、方法出口等信息</font>。每一个方法被调用直至执行完毕的过程，就<font color="red">对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</font></strong>。</p>
<p>递归调用时，每一次递归都在栈顶创建一个栈帧。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p><strong>不管哪种返回方式都会导致栈帧被弹出</strong>。</p>
<p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈通常指这里的虚拟机栈，或者<strong>更多情况下只是指虚拟机栈中局部变量表部分</strong>。 </p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li>
</ul>
<h2 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h2><p>和虚拟机栈所发挥的作用相似，区别是： <strong><font color="red">虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中本地方法栈和 Java 虚拟机栈合二为一</font></strong>。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，<strong>也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误</strong>。</p>
<h2 id="6-Java堆"><a href="#6-Java堆" class="headerlink" title="6. Java堆"></a>6. Java堆</h2><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong><font color="red">此内存区域的唯一目的就是存放对象实例</font><strong>，</strong>几乎所有的对象实例以及数组都在这里分配内存</strong>。</p>
<blockquote>
<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
</blockquote>
<p><strong>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆</strong>（Garbage Collected Heap）</p>
<p>在垃圾回收机制中，有时会对堆进行划分，如“新生代”，“老年代”等，<strong>但这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已， 而非某个 Java 虚拟机具体实现的固有内存布局， 更不是《Java虚拟机规范》里对 Java 堆的进一步细致划分</strong>。</p>
<p>根据 JVM 规范，<strong>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的</strong>。Java 堆<strong>可以被实现为固定大小，也可实现为可扩展</strong>，当前主流 JVM 都是可扩展的（参数<code>-Xmx、-Xms</code>），<strong>若堆内存中没有空间可分配且不可扩展，则抛出OOM异常</strong>。</p>
<p>（来自JavaGuide）</p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>
<ol>
<li>新生代(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" alt="JVM堆内存结构-JDK7"></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" alt="JVM堆内存结构-JDK8"></p>
<p>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</p>
<blockquote>
<p>to be continue….   <a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_24-%e5%a0%86">https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_24-%e5%a0%86</a></p>
</blockquote>
<h2 id="7-方法区"><a href="#7-方法区" class="headerlink" title="7. 方法区"></a>7. 方法区</h2><p>方法区与 Java 堆一样，是<strong>各个线程共享的内存区域、可以不连续的内存和大小可扩展</strong>，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<h3 id="方法区与永久代的关系"><a href="#方法区与永久代的关系" class="headerlink" title="方法区与永久代的关系"></a>方法区与永久代的关系</h3><p>JDK1.8 以前，方法区经常被称为永久代，JVM 规范只是定义了方法区这个概念和它的作用，<strong>并没有定义永久代，永久代是 Hotsp对方法区的一个具体实现</strong>，但这种实现方式使 Java 应用更容易遇到内存溢出问题。从 JDK1.6 开始 HotSpot 逐渐放弃永久代，<strong><font color="red">到JDK1.8已完全放弃永久代的概念，改用在本地内存中实现元空间（Meta-space）（<span style="font-size:25px">元空间也是方法区的一种实现</span>）</font></strong>。</p>
<p>永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而<strong>元空间使用的是直接内存，默认情况下其上限是系统的物理内存大小（unlimited），内存溢出几率很小</strong>。可以通过 <code>MaxMetaspaceSize</code> 参数指定元空间大小。</p>
<blockquote>
<p>元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code> </p>
</blockquote>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>JDK1.8 之前通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>

<p>JDK 1.8 之后</p>
<p>下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<p><code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<h2 id="8-运行时常量池"><a href="#8-运行时常量池" class="headerlink" title="8. 运行时常量池"></a>8. 运行时常量池</h2><p><strong>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量和符号引用</strong>。运行时常量池是方法区的一部分，受到方法区内存的限制，<strong>当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误</strong>。</p>
<p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备<strong>动态性</strong>， Java 语言并不要求常量一定只有编译期才能产生，也就是说，并非只有 Class 文件中常量池的内容才能进入方法区运行时常量池，<strong>运行期间也可以将新的常量放入池中</strong>。</p>
<h2 id="9-直接内存"><a href="#9-直接内存" class="headerlink" title="9. 直接内存"></a>9. 直接内存</h2><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是会受到本机总内存大小以及处理器寻址空间的限制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/JVM/Hotspot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/JVM/Hotspot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Hotspot中的对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:58:33" itemprop="dateModified" datetime="2021-08-30T12:58:33+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p>创建对象在 Java 代码中通常只是一个 new 关键字，而在 JVM 中的具体过程如下：</p>
<h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<strong>对象所需的内存大小在类加载完成后便可确定</strong>，为对象分配空间的任务等同于<strong>把一块确定大小的内存从 Java 堆中划分出来</strong>。</p>
<p><strong>划分堆内存</strong>的两种方式：</p>
<ul>
<li><strong>指针碰撞（Bump The Pointer）</strong>。假设 Java 堆中内存是绝对规整的，所有<strong>被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离， 这种分配方式即为“指针碰撞”。（GC收集器：Serial、ParNew）</li>
<li><strong>空闲列表（Free List）</strong>。如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，虚拟机就必须<strong>维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</strong>，这种分配方式称为“空闲列表” 。（GC收集器：CMS）</li>
</ul>
<p><strong>选择哪种分配方式由 Java 堆是否规整决定，<font color="red">而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</font>（或者说，Java 堆是否规整取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”））</strong>。</p>
<p><strong><font color="red">线程安全问题</font></strong>：</p>
<p><strong>分配内存的操作在并发环境下并不是线程安全的</strong>，在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的。通常虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> <strong>为每一个线程预先在 Java 堆中分配一小块内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB）</strong>。哪个线程要分配内存，就在其对应 TLAB 中分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li>
</ul>
<blockquote>
<p>虚拟机是否采用TLAB，可通过参数<code>-XX:+/-UseTLAB</code>设定。</p>
</blockquote>
<h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p><strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值</strong>（不包括对象头），这一步操作保证了对象的<strong>实例字段</strong>在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<blockquote>
<p>若使用了 TLAB，则可以提前至 TLAB 分配时顺便进行。</p>
</blockquote>
<h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上哈希码会延迟到调用<code>Object.hashCode()</code>方法时才调用）、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="执行-init-方法（构造函数）"><a href="#执行-init-方法（构造函数）" class="headerlink" title="执行 init 方法（构造函数）"></a>执行 init 方法（构造函数）</h3><p>在上面工作都完成之后，<strong>从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零</strong>。一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<blockquote>
<p><strong>是否接着执行 init 方法，由字节码流中 new 指令后面是否跟随 invokespecial 指令所决定</strong>， Java 编译器会在遇到 new 关键字的地方同时生成这两条字节码指令， 但如果直接通过其他方式产生的则不一定如此。</p>
</blockquote>
<h2 id="对象在堆中的内存布局"><a href="#对象在堆中的内存布局" class="headerlink" title="对象在堆中的内存布局"></a>对象在堆中的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<ul>
<li><p><strong>HotSpot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
</li>
<li><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。<strong>无论是从父类继承的还是在子类中定义的字段都必须记录在这部分</strong>。</p>
</li>
<li><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位符作用。</strong> HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 <strong>8 字节的整数倍</strong>，换句话说就是对<strong>象的大小必须是 8 字节的整数倍</strong>。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对象，<strong>Java 程序通过栈上的 reference 数据来操作堆上的具体对象</strong>。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ul>
<li><p><strong>句柄：</strong> 如果使用句柄的话， Java 堆中将会<strong>划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>。如图：（图片来自JavaGuide）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210128110202532.png" alt="image-20210128110202532"></p>
</li>
<li><p><strong>直接指针</strong>（HotSpot主要使用这种方式，也有例外情况）： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。<strong>即 reference 直接指向堆中对象所在内存</strong>。如图：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210128110402759.png" alt="image-20210128110402759"></p>
</li>
</ul>
<p>这两种方式的优势：</p>
<ul>
<li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，<strong>在对象被移动时（如垃圾收集时对象经常移动）只会改变句柄中的实例数据指针，而 reference 本身不需要修改</strong>。</li>
<li>使用直接指针访问方式最大的好处就是速度快，它<strong>节省了一次指针定位的时间开销</strong>。</li>
</ul>
<p>String相关：<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%e5%9b%9b-%e9%87%8d%e7%82%b9%e8%a1%a5%e5%85%85%e5%86%85%e5%ae%b9">补充内容</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bxxiao</p>
  <div class="site-description" itemprop="description">nothing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bxxiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
