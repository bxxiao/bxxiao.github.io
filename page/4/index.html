<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="bxxiao">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="bxxiao">
<meta property="og:description" content="nothing">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bxxiao">
<meta property="article:tag" content="bxxiao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>bxxiao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bxxiao" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bxxiao</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%9F%BA%E7%A1%80/IO%E6%80%BB%E7%BB%93/Java-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%9F%BA%E7%A1%80/IO%E6%80%BB%E7%BB%93/Java-IO/" class="post-title-link" itemprop="url">Java-IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:56:56" itemprop="dateModified" datetime="2021-08-30T12:56:56+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用Java io流经常会用到File类，这里先对File类做个总结。</p>
<p>File类是Java.io包下<strong>代表与平台无关的文件和目录</strong>。可通过File对象新建、重命名、文件和目录，但<strong>不能通过File类访问文件内容本身，此操作需通过Java输入/输出流</strong>。</p>
<p><strong>File 类是对文件系统的映射，并不是硬盘上真实的文件， new File(“filePath”) 只是创建一个与硬盘中filePath指定的文件或目录（不管存不存在）对应的File对象</strong>，并不会在硬盘中创建文件，<strong>即一个File对象只是和硬盘里面的一个文件/目录相关联</strong>。如果所指向的文件不存在，调用<code>exist()</code>将返回false，可以通过<code>createNewFile()</code>方法在硬盘中创建对应文件或目录。</p>
<h2 id="创建File对象"><a href="#创建File对象" class="headerlink" title="创建File对象"></a>创建File对象</h2><p>创建File对象最常用的方法是使用构造器<code>new File(String pathName)</code>。pathName可以是绝对路径和相对路径。<strong>可以通过传入空字符串来创建一个当前路径对应的File对象：<code>File file = new File(&quot;&quot;);</code>，可以通过该方法来获取当前路径</strong>。</p>
<p>File类还包含其他构造器，具体查看官方文档或者File类源码。</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul>
<li><p>File类的一些静态变量：</p>
<ul>
<li><p><strong><code>separator</code>（String）：代表当前系统对应的文件路径分隔符</strong> </p>
</li>
<li><p><strong><code>separatorChar</code>（char）</strong>：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。此字符串只包含一个字符</p>
</li>
<li><p><strong>pathSeparatorChar（char）</strong>：与系统有关的路径分隔符，为了方便，它被表示为一个字符串</p>
</li>
<li><p><strong>pathSeparator（String）</strong>：此字符<strong>用于分隔以路径列表形式给定的文件序列中的文件名</strong>。在UNIX 系统上此字段为<code>:</code>；在 Windows系统上，它为 <code>;</code> </p>
</li>
</ul>
</li>
<li><p><strong>获取文件名</strong> </p>
<ul>
<li><code>String getName()</code>：返回<strong>文件</strong>名（最后一级子路径名）</li>
<li><code>String getPath()</code>：返回<strong>文件</strong>（若是目录则返回空字符串）对应的路径名</li>
<li><strong><code>String getAbsolutePath()</code>：返回绝对路径名</strong></li>
<li><code>String getParent()</code>：返回父目录名</li>
<li><code>boolean renameTo(File newName)</code>：修改文件名，成功返回true，否则false（文件不存在时返回false）</li>
</ul>
</li>
<li><p><strong>检测文件</strong> </p>
<ul>
<li>**<code>boolean exist()</code>**：是否存在</li>
<li><code>boolean canWrite()</code>：是否可写</li>
<li><code>boolean canRead()</code>：是否可读</li>
<li>**<code>boolean isFile()</code>**：是否是文件而不是目录</li>
<li>**<code>boolean isDirectory()</code>**：是否是目录而不是文件</li>
</ul>
</li>
<li><p><strong>获取文件信息</strong> </p>
<ul>
<li><code>long lastModified()</code>：返回最后修改的时间</li>
<li><strong><code>long length()</code>：返回文件长度</strong> </li>
</ul>
</li>
<li><p>文件操作：</p>
<ul>
<li><strong><code>boolean createNewFile()</code>：若对应文件不存在，创建对应的新文件。创建成功返回true，否则false</strong> </li>
<li><strong><code>boolean delete()</code>：删除对应文件</strong> </li>
<li><code>static File createTempFile(String prefix, String suffix)</code>：静态方法。根据前缀，后缀以及系统生成的随机数在默认的临时文件目录中创建一个空文件。prefix至少3字节，suffix可为null</li>
<li><code>static File createTempFile(String prefix, String suffix, File directory)</code>：在指定目录创建对应文件</li>
<li><code>void deleteOnExit()</code>：注册删除钩子。当虚拟机退出时，删除该文件</li>
</ul>
</li>
<li><p>目录操作：</p>
<ul>
<li><strong><code>boolean mkdir()</code>：创建File对象对应的目录</strong></li>
<li><strong><code>String[] list()</code>：返回File的所有子文件名和路径名的String数组</strong></li>
<li><code>File[] listFiles()</code>：返回File的所有子文件名和路径名的File数组</li>
<li><code>static File[] listRoots()</code>：返回系统所有的根路径的File数组</li>
</ul>
</li>
</ul>
<h2 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h2><p>在使用<code>list()</code>方法所有子文件名和路径名时，可以传入一个FilenameFilter（接口）参数，代表文件过滤器。该接口包含一个<code>boolean accept(File dir, String name)</code>方法，该方法将依次对指定File对象的子文件名和路径名进行迭代筛选，返回true表示符合要求。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String[] list1 = f1.list();</span><br><span class="line">    System.out.println(<span class="string">&quot;该目录下的所有文件：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;过滤掉不以.txt结尾的子文件：&quot;</span>);</span><br><span class="line">    String[] list2 = f1.list(((dir, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>)));</span><br><span class="line">    <span class="keyword">for</span> (String s : list2) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">该目录下的所有文件：</span><br><span class="line">a.txt</span><br><span class="line">a.txt.bak</span><br><span class="line">answers.txt</span><br><span class="line">b.txt</span><br><span class="line">b.txt.bak</span><br><span class="line">c.txt</span><br><span class="line">c.txt.bak</span><br><span class="line">expFile.txt</span><br><span class="line">过滤掉不以.txt结尾的子文件：</span><br><span class="line">a.txt</span><br><span class="line">answers.txt</span><br><span class="line">b.txt</span><br><span class="line">c.txt</span><br><span class="line">expFile.txt</span><br></pre></td></tr></table></figure>



<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Java的IO流是实现输入/输出的基础， 它可以方便地实现数据的输入/输出操作， <strong>在Java中把不同的输入/输出源(键盘、文件、网络连接等) 抽象表述为“流”(stram) ， 通过流的方式允许Java程序使用相同的方式来访问不同的输入/输出源。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象</strong>。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<p><strong>Java io流的类层次图</strong>，其中的类皆来自java.io包（图片来自菜鸟教程）：</p>
<img src="https://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png"  />



<h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><h3 id="输入流与输出流"><a href="#输入流与输出流" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h3><p>根据数据流向不同可分为输入流和输出流。</p>
<p>输入流：只能从中读取数据。<strong>输入流主要以InputStream、Reader抽象类作为基类</strong>。</p>
<p>输出流：只能向其中输入数据。<strong>输出流主要以OutputStream、Writer抽象类作为基类。</strong> </p>
<p><strong>这里的输入输出是从程序运行所在角度来划分的</strong>。</p>
<h3 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h3><p>根据处理数据类型的不同可分为字节流和字符流。</p>
<p>两者的区别：</p>
<ul>
<li><p><strong>传输数据的单位不同，字节流为8位的字节，字符流为16位的字符</strong>。</p>
</li>
<li><p>处理对象不同，<strong>字节流能处理所有类型的数据，而字符流只能处理字符类型的数据</strong>。</p>
</li>
<li><p>字节流在操作的时候本身是不会用到缓冲区的，是在文件本身直接操作；而<strong>字符流是通过缓冲区来操作文件的</strong>。</p>
</li>
<li><p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p>
</li>
</ul>
<p><strong>字节流以InputStream、OutputStream为基类。字符流以Reader、Writer为基类</strong>。</p>
<h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ul>
<li><p>节点流：可以从/向一个特定的IO设备（磁盘，网络等）读/写数据的流。<strong>即程序直接连接到数据源</strong>。</p>
</li>
<li><p>处理流：<strong>对一个已存在的节点流进行连接和封装</strong>，封装后的流提供了更简便强大的数据读写功能。<strong>关闭流时，只关闭处理流即可，外层的流将会关闭内层的节点流</strong>。</p>
</li>
</ul>
<p>以下分为字节流和字符流对一些较常用的流进行总结。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流基类是InputStream和OutputStream。<strong>InputStream类是所有字节输入流类的抽象父类。OutputStream类是所有字节输出流的抽象父类</strong>。InputStream和OutputStream基类提供了<code>read()</code>和<code>write()</code>系列方法进行读写，可以一次读/写一个字节，也可多个字节。在处理图片、音乐等非文本文件时，使用的是字节流。</p>
<p>InputStream的常见子类有：</p>
<ul>
<li><strong>FileInputStream</strong>：从文件中读取信息。</li>
<li><strong>ByteArrayInputStream</strong>： 字节数组输入流,</li>
<li><strong>ObjectInputStream</strong>：<strong>序列化时</strong>使用。一般和ObjectOutputStream一起使用</li>
<li><strong>FilterInputStream</strong>：过滤输入流，为基础的输入流提供一些额外的操作。</li>
</ul>
<p>OutputStream的常见子类有：</p>
<ul>
<li><strong>FileOutPutStream</strong>: 文件输出流对文件进行操作</li>
<li><strong>ByteArrayOutputStream</strong>: 字节数组输出流</li>
<li><strong>ObjectOutputStream</strong>: 序列化时使用。一般和OjbectInputStream一起使用</li>
<li><strong>FilterOutputStream</strong>:过滤输出流,为基础的输出流提供一些额外的操作。</li>
</ul>
<p>其中，<strong>创建OutputStream的子类时，若指定的文件在磁盘中不存在，则会创建对应的文件</strong>；对于InputStream，若文件不存在则抛出异常。</p>
<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>FileInputStream、FileOutPutStream是针对文件的字节输入、输出流，可以<strong>通过指定文件的路径（String）或指定一个File对象来创建</strong>。</p>
<p>一个复制文件的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//创建输入流，输出流，实现文件的复制</span></span><br><span class="line">      FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\source.java&quot;</span>);</span><br><span class="line">      FileOutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\copy.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">      <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//将读取的输入流数据写入输出流</span></span><br><span class="line">      <span class="keyword">while</span>((hasRead = input.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          output.write(buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//输出复制后的文件</span></span><br><span class="line">      FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\copy.txt&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span>((hasRead = file.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span> ,hasRead));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭资源</span></span><br><span class="line">      input.close();</span><br><span class="line">      output.close();</span><br><span class="line">      file.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h3><p><strong><font color="red">流的来源或目的地并不一定是文件，也可以是内存中的一块空间</font></strong>，例如一个字节数组。<strong>ByteArrayInputStream、ByteArrayOutputStream就是将字节数组当作流的输入来源、输出目的地的类</strong>。</p>
<p>创建ByteArrayInputStream需要传入一个<code>byte[]</code>；创建ByteArrayOutputStream不是传入一个byte数组（<strong>ByteArrayOutputStream中封装了一个byte数组作为输出目的地，通过<code>toByteArray()</code>方法可以获取到该数组</strong>），而是指定ByteArrayOutputStream中byte数组的长度，也可以不指定，默认为32。</p>
<p>关于这两个流的应用场景（来自参考链接）：</p>
<p><strong>这两个类对于要创建临时性文件的程序以及网络数据的传输、数据压缩后的传输等可以提高运行的的效率，可以不用访问磁盘</strong>。同样有StringReader与StringWriter类以字符IO流的方式处理字符串。</p>
<p>两个流的用法比较简单，直接看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayOutputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        demo1();</span><br><span class="line">        demo2();</span><br><span class="line">        <span class="comment">//输出：</span></span><br><span class="line">        <span class="comment">//hello</span></span><br><span class="line">		<span class="comment">//hello, world!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ByteArrayInputStream inputStream;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[bytes.length];</span><br><span class="line"></span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        inputStream = <span class="keyword">new</span> ByteArrayInputStream(outputStream.toByteArray());</span><br><span class="line">        inputStream.read(bytes1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((hasRead = inputStream.read())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)hasRead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>ObjectInputStream和ObjectOutpuStream一般<strong>用于反序列化/序列化Java对象。被操作的对象对应的类必须实现Serializable接口</strong>。</p>
<ul>
<li>ObjectInputStream能够从输入流中读取Java对象，而不需要每次读取一个字节（反序列化）</li>
<li>ObjectOutputStream能够把对象写入到输出流中，而不需要每次写入一个字节（序列化）</li>
</ul>
<p><strong>创建ObjectInputStream和ObjectOutpuStream流需要传入一个节点流</strong>。</p>
<p>示例：</p>
<p><strong>一个要注意的点是：若是要从流中读取多个对象，则读取顺序要与写入的顺序一致</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Data w=<span class="keyword">new</span> Data(<span class="number">2</span>);</span><br><span class="line">    ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\worm.out&quot;</span>));</span><br><span class="line">    <span class="comment">//序列化对象，把对象写到worm.out里面</span></span><br><span class="line">    out.writeObject(<span class="string">&quot;Worm storage\n&quot;</span>);</span><br><span class="line">    <span class="comment">//序列化对象，把对象写到worm.out里面</span></span><br><span class="line">    out.writeObject(w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从worm.out里面读取对象</span></span><br><span class="line">    ObjectInputStream in=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\worm.out&quot;</span>));</span><br><span class="line">    <span class="comment">//读取String对象</span></span><br><span class="line">    String s=(String)in.readObject();</span><br><span class="line">    <span class="comment">//读取Data对象</span></span><br><span class="line">    Data d=(Data)in.readObject();</span><br><span class="line">    System.out.println(s+<span class="string">&quot;Data = &quot;</span>+d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ObjectInputStream和ObjectOutpuStream也提供了系列<code>readXxx()</code>和<code>writeXxx()</code>方法，用于写入/读取int、char或者字符串等类型的值。<strong>与读写对象一样，使用<code>readXxx()</code>读取数据时，要与写入时的顺序一致</strong>。如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ObjectOutputStream out=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\test.out&quot;</span>));</span><br><span class="line">    ObjectInputStream in;</span><br><span class="line"></span><br><span class="line">    out.writeInt(<span class="number">2</span>);</span><br><span class="line">    out.writeChar(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    out.writeDouble(<span class="number">3.14</span>);</span><br><span class="line">    out.writeUTF(<span class="string">&quot;hello, world!&quot;</span>);<span class="comment">//写入字符串</span></span><br><span class="line">    out.writeObject(<span class="string">&quot;I am a String Object&quot;</span>);</span><br><span class="line"></span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    in =<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\test.out&quot;</span>));</span><br><span class="line">    <span class="comment">//从输入流中读取数据的顺序要与写入时的顺序一致，否则抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> val = in.readInt();</span><br><span class="line">    <span class="keyword">char</span> c = in.readChar();</span><br><span class="line">    <span class="keyword">double</span> val1 = in.readDouble();</span><br><span class="line">    String str = in.readUTF();</span><br><span class="line">    String strObj = (String) in.readObject();</span><br><span class="line"></span><br><span class="line">    System.out.println(val);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    System.out.println(val1);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    System.out.println(strObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="过滤io流"><a href="#过滤io流" class="headerlink" title="过滤io流"></a>过滤io流</h3><p>这里的过滤输入/输出流是指<strong>FilterInputStream和FilteOutputStream</strong>，他们的作用是<strong>为基础流提供一些额外的功能</strong>。</p>
<p><strong>常用子类</strong>：</p>
<ul>
<li><p>FilterInputStream常用子类</p>
<ul>
<li><strong>DataInputStream</strong></li>
<li><strong>BufferedInputStream</strong>：可以从缓冲区中读取数据，不用每次和文件的操作都进行实际操作了。</li>
</ul>
</li>
<li><p>FilterOutputStream常用子类</p>
<ul>
<li><strong>DataOutputStream</strong></li>
<li><strong>PrintStream</strong>:用于产生格式化的输出</li>
<li><strong>BufferedOutputStream</strong>:通过缓冲区像文件中写入数据。</li>
</ul>
</li>
</ul>
<h4 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h4><p>DataInputStream是数据字节输入流，用来装饰其他的输入流，<strong>允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型</strong>；DataOutputStream可以向文件中写入基本类型的数据，与DataInputStream配合使用。</p>
<p>创建DataInputStream和DataOutputStream都要基于一个输入/输出节点流。</p>
<p>示例：</p>
<p><strong>其中的<code>writeUTF()</code>方法，是以UTF-8编码写入指定字符串；相应的，<code>readUTF()</code>是以UTF-8编码读取字符串</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInOutStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\data.txt&quot;</span>);</span><br><span class="line">        FileInputStream in;</span><br><span class="line">        FileOutputStream out;</span><br><span class="line">        DataInputStream dataIn;</span><br><span class="line">        DataOutputStream dataOut;</span><br><span class="line"></span><br><span class="line">        out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        dataOut = <span class="keyword">new</span> DataOutputStream(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        dataOut.writeInt(<span class="number">2020</span>);</span><br><span class="line">        dataOut.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">        dataOut.writeChar(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        dataOut.writeUTF(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        dataIn = <span class="keyword">new</span> DataInputStream(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读出数据（注意顺序）</span></span><br><span class="line">        <span class="keyword">int</span> readInt = dataIn.readInt();</span><br><span class="line">        <span class="keyword">boolean</span> readBoolean = dataIn.readBoolean();</span><br><span class="line">        <span class="keyword">char</span> readChar = dataIn.readChar();</span><br><span class="line">        String readStr = dataIn.readUTF();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;readInt = &quot;</span> + readInt);</span><br><span class="line">        System.out.println(<span class="string">&quot;readBoolean = &quot;</span> + readBoolean);</span><br><span class="line">        System.out.println(<span class="string">&quot;readChar = &quot;</span> + readChar);</span><br><span class="line">        System.out.println(<span class="string">&quot;readStr = &quot;</span> + readStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h4><p>BufferedInputStream和BufferedOutputStream是两个缓冲流。对于没有缓冲的节点流，如FileInputStream，<strong>读取一个字节就要与磁盘交互一次，与磁盘的交互过于频繁，读取速度较低</strong>。</p>
<p>缓冲流中内置了一个缓冲区，</p>
<ul>
<li>对于BufferedOutputStream，<strong>使用<code>write()</code>方法写入数据时，写入的数据暂时被放在缓冲区，当调用<code>flush()</code>方法或者缓冲区满时才把数据写入输出流</strong>，从而减少了与磁盘的交互，提高效率。</li>
<li><strong>对于BufferedInputStream</strong>，在新建某输入流对应的BufferedInputStream后，<strong>当通过<code>read()</code>读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区</strong>；如此反复，直到读完输入流数据位置。<strong><font color="red">从内存中读取数据的速度比从硬盘读取数据的速度快得多</font></strong>，且分批读取数据减少了与磁盘的交互，所以BufferedInputStream的效率比普通的输入节点流要高很多。</li>
</ul>
<p>一个复制图片的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInOutStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        copyDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File srcImg = <span class="keyword">new</span> File(<span class="string">&quot;E:\\xiaogailun.jpg&quot;</span>);</span><br><span class="line">        File copyImg = <span class="keyword">new</span> File(<span class="string">&quot;E:\\copy.jpg&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(srcImg);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(copyImg);</span><br><span class="line">        BufferedInputStream bufIn = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">        BufferedOutputStream bufOut = <span class="keyword">new</span> BufferedOutputStream(out);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>];</span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((hasRead = bufIn.read(buf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            bufOut.write(buf, <span class="number">0</span>, hasRead);</span><br><span class="line">        &#125;</span><br><span class="line">        bufOut.flush();</span><br><span class="line"></span><br><span class="line">        bufIn.close();</span><br><span class="line">        bufOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后关闭流时，只需关闭外层流（处理流）即可，在外层流中会把包装的内层流（节点流）关闭</strong>。</p>
<h4 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h4><p>PrintStream 是用来装饰其它输出流，<strong>其中提供了系列<code>print()</code>方法，让其他输出流能够方便地输出各种形式的数据</strong>。另外，PrintStream提供了<strong>自动flush（写入数据时自动调用<code>flush()</code>）和字符集设置</strong>功能。</p>
<p>PrintStream的构造器：（<strong>其中的boolean值是指定是否自动flush；String是指定文件名或字符集名</strong>）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201028233241230.png" alt="image-20201028233241230"></p>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\print.txt&quot;</span>);</span><br><span class="line">        PrintStream printStream = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line"></span><br><span class="line">        printStream.println(<span class="string">&quot;hello,world!啊哈哈哈&quot;</span>);<span class="comment">//结尾加回车符</span></span><br><span class="line">        printStream.print(<span class="number">12138</span>);<span class="comment">//结尾无回车符</span></span><br><span class="line">        printStream.println();</span><br><span class="line">        printStream.print(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        printStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后的print.txt文件内容：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello,world!啊哈哈哈</span><br><span class="line"><span class="number">12138</span></span><br><span class="line">H</span><br></pre></td></tr></table></figure>



<blockquote>
<p>更多关于PrintStream的内容推荐看（贼详细）：<a href="https://www.cnblogs.com/skywang12345/p/io_16.html" target="_blank">java io系列16之 PrintStream(打印输出流)详解</a> </p>
</blockquote>
<h2 id="2-4-字符流"><a href="#2-4-字符流" class="headerlink" title="2.4 字符流"></a>2.4 字符流</h2><p>字符流操作的数据单位是字符，在处理文本文件的时候更多使用的是字符流。</p>
<p>字符流的两个抽象基类是<code>Reader</code>和 <code>Writer</code>。其常见子类如下：</p>
<p>Reader类常见子类有：</p>
<ul>
<li><p><strong>InputStreamReader</strong>：字节流到字符流的桥接器。</p>
</li>
<li><p><strong>FileReader</strong>：文件字符输入流</p>
</li>
<li><p><strong>BufferedReader</strong>： 带缓冲区的字符输入流</p>
</li>
<li><p>StringReader：以字符串为源的字符输入流。（StringReader和StringWriter的使用较简单，不作总结）</p>
</li>
</ul>
<p>Writer类常见子类有：</p>
<ul>
<li><p><strong>OutputStreamWriter</strong>：字节流到字符流的桥接器。</p>
</li>
<li><p><strong>FileWriter</strong>:文件字符输出流</p>
</li>
<li><p><strong>BufferedWriter</strong>:带缓冲区的字符输出流</p>
</li>
<li><p>StringWriter：内部封装了一个StringBuffer，作为该输出流的源。提供了一个<code>getBuffer()</code>方法获取其中的StringBuffer。</p>
</li>
</ul>
<p><strong>要注意的点</strong>：</p>
<ul>
<li><strong>Writer抽象类中定义了一个<code>char[]</code>缓冲区</strong>（即Writer的系列子类都有一个缓冲区），该缓冲区的默认大小是1024，<strong>且不可自行指定大小</strong>。在执行写操作时，<strong>只有缓冲区满或调用<code>flush()</code>或调用<code>close()</code>方法时才会将内容写入磁盘中的文件</strong>。</li>
<li>创建Writer子类时，与OutputStream一样，<strong>若指定的文件在磁盘中不存在，则会创建对应的文件</strong>；对于Reader，若文件不存在则同样抛出异常。</li>
</ul>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>InputStreamReader和OutputStreamWriter<strong>是字节流到字符流的桥接器，它们可以根据指定的字符集来进行读写内容，没有指定字符集时使用的是java虚拟机的字符集</strong>。</p>
<p>每次调用InputStreamReader的<code>read()</code>都将从底层读取一个或多个字节；每次调用OutputStreamWriter的<code>write()</code>方法都会将指定内容写入底层文件。为了提高效率，一般用BufferedReader和BufferedWriter来包装它们。</p>
<p><strong>创建InputStreamReader和OutputStreamWriter时传入的是字节流，它们会根据指定的字符集进行字节和字符间的转换</strong>。</p>
<p>InputStreamReader的构造器：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201031105204555.png" alt="image-20201031105204555"></p>
<p>OutputStreamWriter的构造器：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201031105018986.png" alt="image-20201031105018986"></p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>FileWriter和FileReader是InputStreamWriter和OutputStreamReader的子类，在FileWriter和FileReader中，字符集使用的是Java虚拟机的字符集。</p>
<p>FileWriter和FileReader的使用比较简单。它们都是节点流，可以直接传入一个FIle或文件路径来创建流。</p>
<p><strong>其中，创建FileWriter时可以传入一个boolean值，若为true，表示写入的内容是追加在原文件结尾之后，该值默认为false</strong>。对应的两个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(File file, <span class="keyword">boolean</span> append)</span><br><span class="line">FileWriter(String fileName, <span class="keyword">boolean</span> append)</span><br></pre></td></tr></table></figure>

<p>源码中关于append参数的解释：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> <span class="keyword">if</span> <span class="literal">true</span>, <span class="keyword">then</span> data will be written <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="built_in">file</span> rather than <span class="keyword">the</span> <span class="keyword">beginning</span>.</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderAndWriterDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n\n---------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">        appendWrite();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\file.txt&quot;</span>);</span><br><span class="line">        FileWriter writer = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">        writer.write(<span class="string">&quot;hello,world!你好，世界！\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;12345678999+*-\n&quot;</span>);</span><br><span class="line">        <span class="comment">//写入时会把int数值转换为对应的char</span></span><br><span class="line">        writer.write(<span class="number">67</span>);</span><br><span class="line">        writer.flush();<span class="comment">//可以省略，因为调用close时会调用flush</span></span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\file.txt&quot;</span>);</span><br><span class="line">        FileReader reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((hasRead=reader.read(cbuf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(cbuf, <span class="number">0</span>, hasRead));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在文件结尾写入内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\file.txt&quot;</span>);</span><br><span class="line">        FileWriter writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\n------以下内容并没有覆盖原文件内容------\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;啊哈哈哈哈哈哈哈\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;弹指间、数据库灰飞烟灭&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">hello,world!你好，世界！</span></span><br><span class="line"><span class="comment">12345678999+*-</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">hello,world!你好，世界！</span></span><br><span class="line"><span class="comment">12345678999+*-</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">------以下内容并没有覆盖原文件内容------</span></span><br><span class="line"><span class="comment">啊哈哈哈哈哈哈哈</span></span><br><span class="line"><span class="comment">弹指间、数据库灰飞烟灭</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader和BufferedWriter的功能是<strong>为其他字符输入/输出流提供缓存的功能</strong>。关于缓存功能的说明在上文的BufferedInputStream和BufferedOutputStream中已有描述，此处不再赘述。</p>
<p>一个问题是，上文中提到Writer抽象基类中已经有了一个缓冲区，为何还要使用BufferedWriter？</p>
<p>原因：<strong>Writer中定义的缓冲区大小是不能自定义的，且大小只有1024；BufferedWriter中的缓冲区默认大小是8192（1024的8倍），且大小可以自定义，可以指定更大的缓冲区，这个差别使得在操作大量数据时，BufferedWriter的效率将会比普通的字符流，如FileWriter要快得多（BufferedWriter与磁盘的交互次数更少）</strong>。</p>
<p>使用BufferedReader和BufferedWriter来处理文本时<strong>为了保证字符集的统一，内层流可以使用InputStreamReader和OutputStreamWriter，它们可以指定字符集</strong>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\file.txt&quot;</span>);</span><br><span class="line">        write(file);</span><br><span class="line">        readLine(file);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------------------------\n&quot;</span>);</span><br><span class="line">        readAll(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(File file)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        FileOutputStream outStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(outStream, 										StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        writer.write(<span class="string">&quot;hello,world!你好，世界！\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;123456789&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);<span class="comment">//写入前5个字符</span></span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用readLine()按行读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readLine</span><span class="params">(File file)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream inStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inStream, StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        String line1 = reader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取文件的第一行：&quot;</span> + line1);</span><br><span class="line">        String line2 = reader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取文件的第二行：&quot;</span> + line2);</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readAll</span><span class="params">(File file)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream inStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inStream, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line"></span><br><span class="line">        reader.read(cbuf);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(cbuf));</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">读取文件的第一行：hello,world!你好，世界！</span></span><br><span class="line"><span class="comment">读取文件的第二行：12345</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">hello,world!你好，世界！</span></span><br><span class="line"><span class="comment">12345    </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="移动输入流中的记录指针"><a href="#移动输入流中的记录指针" class="headerlink" title="移动输入流中的记录指针"></a>移动输入流中的记录指针</h2><p>在对输入流进行读操作（<code>read()</code>）时，流中的记录指针随之向后移动。InputStream和Reader中提高了下列方法来移动输入流中的记录指针，从而可以重复读取内容：</p>
<ul>
<li><code>mark(int readlimit)</code>：在此输入流中的当前位置做一个标记。<code>readlimit</code>参数<strong>告诉输入流允许在标记位置之后读取多个字节（注意是字节，不管是对于InputStream还是Reader）</strong>，若是<code>reset()</code>之后读取的字节数超过该参数，则抛出异常：<code>java.io.IOException: Mark invalid</code>。</li>
<li><code>markSupported()</code>：判断是否支持标记，即是否支持mark方法。</li>
<li><code>reset()</code>：将此流的记录指针重新定位到<strong>上一次</strong>在此输入流上调用 <code>mark()</code>方法时的位置。调用<code>reset()</code>之前必须有进行标记，否则抛出异常：<code>java.io.IOException: Stream not marked</code>。</li>
<li><code>skip(long n)</code>：跳过输入流中的 <strong><code>n</code>个字节或字符</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\file.txt&quot;</span>);</span><br><span class="line">        write(file);</span><br><span class="line">        read(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(File file)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileOutputStream outStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(outStream, StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        writer.write(<span class="string">&quot;hello,world!你好，世界！\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(File file)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream inStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inStream, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在开头进行mark。输出文件全部内容后进行reset</span></span><br><span class="line">        reader.mark(<span class="number">1024</span>);</span><br><span class="line">        reader.read(chars);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件的全部内容是：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(chars) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        reader.reset();</span><br><span class="line"></span><br><span class="line">        reader.read(chars, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;读取前12个字符：&quot;</span> + <span class="keyword">new</span> String(chars, <span class="number">0</span>, <span class="number">12</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;BufferedReader是否支持标记：&quot;</span> + reader.markSupported());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n在当前位置进行mark()&quot;</span>);</span><br><span class="line">        reader.mark(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过7个字符，即跳过了 你好，世界！\n</span></span><br><span class="line">        reader.skip(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n跳过7个字符，并读取整行：&quot;</span>);</span><br><span class="line">        String line = reader.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reset，再读取，读取的开始位置是上一次mark时的位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--调用了reset()--\n&quot;</span>);</span><br><span class="line">        reader.reset();</span><br><span class="line">        String line2 = reader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;reset之后再读取：&quot;</span>);</span><br><span class="line">        System.out.println(line2);</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《疯狂Java讲义 第4版》</p>
<p><a href="https://blog.csdn.net/qq_36537546/article/details/88421680" target="_blank">关于：File.separator （ 详解 ）</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/99609337" target="_blank">一文带你看懂JAVA IO流 - 知乎</a> </p>
<p><a href="https://www.cnblogs.com/yixiu868/p/8144670.html" target="_blank">ByteArrayInputStream的作用，和BufferedOutputStream 的区别</a> </p>
<p><a href="https://blog.csdn.net/zhaoyanjun6/article/details/54894451" target="_blank">Java IO流学习总结三：缓冲流-BufferedInputStream、BufferedOutputStream</a> </p>
<p><a href="https://www.cnblogs.com/skywang12345/p/io_16.html" target="_blank">java io系列16之 PrintStream(打印输出流)详解</a> </p>
<p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/io/OutputStreamWriter.html" target="_blank">OutputStreamWriter</a> <a href="https://www.runoob.com/manual/jdk11api/java.base/java/io/InputStreamReader.html" target="_blank">InputStreamReader</a> </p>
<p>另外推荐一个博主的Java io系列文章：<a href="https://www.cnblogs.com/skywang12345/p/io_01.html" target="_blank">java io系列01之 “目录”</a>  </p>
</blockquote>
<p><code>----------------------------------------------------------------</code> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%9F%BA%E7%A1%80/IO%E6%80%BB%E7%BB%93/File%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%9F%BA%E7%A1%80/IO%E6%80%BB%E7%BB%93/File%E7%B1%BB/" class="post-title-link" itemprop="url">File类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:56:52" itemprop="dateModified" datetime="2021-08-30T12:56:52+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用Java io流经常会用到File类，这里先对File类做个总结。</p>
<p>File类是Java.io包下<strong>代表与平台无关的文件和目录</strong>。可通过File对象新建、重命名、文件和目录，但<strong>不能通过File类访问文件内容本身，此操作需通过Java输入/输出流</strong>。</p>
<p><strong>File 类是对文件系统的映射，并不是硬盘上真实的文件， new File(“filePath”) 只是创建一个与硬盘中filePath指定的文件或目录（不管存不存在）对应的File对象</strong>，并不会在硬盘中创建文件，<strong>即一个File对象只是和硬盘里面的一个文件/目录相关联</strong>。如果所指向的文件不存在，调用<code>exist()</code>将返回false，可以通过<code>createNewFile()</code>方法在硬盘中创建对应文件或目录。</p>
<h2 id="创建File对象"><a href="#创建File对象" class="headerlink" title="创建File对象"></a>创建File对象</h2><p>创建File对象最常用的方法是使用构造器<code>new File(String pathName)</code>。pathName可以是绝对路径和相对路径。<strong>可以通过传入空字符串来创建一个当前路径对应的File对象：<code>File file = new File(&quot;&quot;);</code>，可以通过该方法来获取当前路径</strong>。</p>
<p>File类还包含其他构造器，具体查看官方文档或者File类源码。</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul>
<li><p>File类的一些静态变量：</p>
<ul>
<li><p><strong><code>separator</code>（String）：代表当前系统对应的文件路径分隔符</strong> </p>
</li>
<li><p><strong><code>separatorChar</code>（char）</strong>：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。此字符串只包含一个字符</p>
</li>
<li><p><strong>pathSeparatorChar（char）</strong>：与系统有关的路径分隔符，为了方便，它被表示为一个字符串</p>
</li>
<li><p><strong>pathSeparator（String）</strong>：此字符<strong>用于分隔以路径列表形式给定的文件序列中的文件名</strong>。在UNIX 系统上此字段为<code>:</code>；在 Windows系统上，它为 <code>;</code> </p>
</li>
</ul>
</li>
<li><p><strong>获取文件名</strong> </p>
<ul>
<li><code>String getName()</code>：返回<strong>文件</strong>名（最后一级子路径名）</li>
<li><code>String getPath()</code>：返回<strong>文件</strong>（若是目录则返回空字符串）对应的路径名</li>
<li><strong><code>String getAbsolutePath()</code>：返回绝对路径名</strong></li>
<li><code>String getParent()</code>：返回父目录名</li>
<li><code>boolean renameTo(File newName)</code>：修改文件名，成功返回true，否则false（文件不存在时返回false）</li>
</ul>
</li>
<li><p><strong>检测文件</strong> </p>
<ul>
<li>**<code>boolean exist()</code>**：是否存在</li>
<li><code>boolean canWrite()</code>：是否可写</li>
<li><code>boolean canRead()</code>：是否可读</li>
<li>**<code>boolean isFile()</code>**：是否是文件而不是目录</li>
<li>**<code>boolean isDirectory()</code>**：是否是目录而不是文件</li>
</ul>
</li>
<li><p><strong>获取文件信息</strong> </p>
<ul>
<li><code>long lastModified()</code>：返回最后修改的时间</li>
<li><strong><code>long length()</code>：返回文件长度</strong> </li>
</ul>
</li>
<li><p>文件操作：</p>
<ul>
<li><strong><code>boolean createNewFile()</code>：若对应文件不存在，创建对应的新文件。创建成功返回true，否则false</strong> </li>
<li><strong><code>boolean delete()</code>：删除对应文件</strong> </li>
<li><code>static File createTempFile(String prefix, String suffix)</code>：静态方法。根据前缀，后缀以及系统生成的随机数在默认的临时文件目录中创建一个空文件。prefix至少3字节，suffix可为null</li>
<li><code>static File createTempFile(String prefix, String suffix, File directory)</code>：在指定目录创建对应文件</li>
<li><code>void deleteOnExit()</code>：注册删除钩子。当虚拟机退出时，删除该文件</li>
</ul>
</li>
<li><p>目录操作：</p>
<ul>
<li><strong><code>boolean mkdir()</code>：创建File对象对应的目录</strong></li>
<li><strong><code>String[] list()</code>：返回File的所有子文件名和路径名的String数组</strong></li>
<li><code>File[] listFiles()</code>：返回File的所有子文件名和路径名的File数组</li>
<li><code>static File[] listRoots()</code>：返回系统所有的根路径的File数组</li>
</ul>
</li>
</ul>
<h2 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h2><p>在使用<code>list()</code>方法所有子文件名和路径名时，可以传入一个FilenameFilter（接口）参数，代表文件过滤器。该接口包含一个<code>boolean accept(File dir, String name)</code>方法，该方法将依次对指定File对象的子文件名和路径名进行迭代筛选，返回true表示符合要求。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String[] list1 = f1.list();</span><br><span class="line">    System.out.println(<span class="string">&quot;该目录下的所有文件：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;过滤掉不以.txt结尾的子文件：&quot;</span>);</span><br><span class="line">    String[] list2 = f1.list(((dir, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>)));</span><br><span class="line">    <span class="keyword">for</span> (String s : list2) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">该目录下的所有文件：</span><br><span class="line">a.txt</span><br><span class="line">a.txt.bak</span><br><span class="line">answers.txt</span><br><span class="line">b.txt</span><br><span class="line">b.txt.bak</span><br><span class="line">c.txt</span><br><span class="line">c.txt.bak</span><br><span class="line">expFile.txt</span><br><span class="line">过滤掉不以.txt结尾的子文件：</span><br><span class="line">a.txt</span><br><span class="line">answers.txt</span><br><span class="line">b.txt</span><br><span class="line">c.txt</span><br><span class="line">expFile.txt</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">深拷贝、浅拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:56:36" itemprop="dateModified" datetime="2021-08-30T12:56:36+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>定义两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String majorName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Major major;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p><strong>浅拷贝</strong>即在拷贝对象时，<strong>对于对象中的引用类型成员变量，只复制该成员变量的对象引用</strong>，而<strong>该引用地址指向的实际对象空间其实只有一份</strong>。如图（图片来自参考链接）：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201202195036253.png" alt="image-20201202195036253" style="zoom:67%;" />



<p>深拷贝即对于引用类型字段所指向的对象，也会在内存中也<strong>创建一个副本</strong>。如图（图片来自参考链接）：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20201202195739338.png" alt="image-20201202195739338" style="zoom: 67%;" />

<p>&emsp;  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>要拷贝的类实现<code>Cloneable</code>接口，重写Object的<code>clone()</code>方法，<strong>并使用其默认实现来实现浅拷贝</strong>（<strong>Object类的<code>clone()</code>方法的默认实现就是浅拷贝，且该方法是一个<code>native</code>方法</strong>）。</p>
<blockquote>
<p><code>Cloneable</code>接口是一个空接口，与Serializable接口类似，只是一个标记。通过实现该接口，使实现类支持使用Object类的<code>clone()</code>方法，否则会抛出CloneNotSupportedException异常。</p>
</blockquote>
<p>&emsp;  </p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Major major;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Major major = <span class="keyword">new</span> Major(<span class="string">&quot;软件工程&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, major);</span><br><span class="line"></span><br><span class="line">    Student student2 = (Student) student1.clone();</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">    System.out.println(student2);</span><br><span class="line">    System.out.println(<span class="string">&quot;student1==student2 &quot;</span> + (student1==student2));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;两个student的major是否相同：&quot;</span> + (student1.getMajor()==student2.getMajor()));</span><br><span class="line"></span><br><span class="line">    major.setId(<span class="number">666</span>);</span><br><span class="line">    major.setMajorName(<span class="string">&quot;信息安全&quot;</span>);</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">    System.out.println(student2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line"><span class="attribute">student1</span>==student2 <span class="literal">false</span></span><br><span class="line">两个student的major是否相同：<span class="literal">true</span></span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两个student不相同，说明拷贝了一个新的对象。</li>
<li>修改major对象后，两个student中的major都改变，说明两个major指向同一对象。</li>
</ul>
<p>&emsp;  </p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝可以有两种实现方式：</p>
<ul>
<li>同样使用<code>Cloneable</code>接口，但与浅拷贝不同，需要对引用对象实现进行深度遍历式拷贝。</li>
<li>使用反序列化实现。</li>
</ul>
<p>&emsp;  </p>
<h4 id="使用Cloneable接口"><a href="#使用Cloneable接口" class="headerlink" title="使用Cloneable接口"></a>使用Cloneable接口</h4><p>Major类也需要实现Cloneable接口。<strong>Major中的成员变量都是值类型，所以使用<code>clone()</code>方法默认实现即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>在<strong>顶层的</strong>调用类中（Student）重写<code>clone</code>方法，来调用引用类型字段的<code>clone()</code>方法实现深度拷贝：</p>
<ul>
<li>先通过浅拷贝拷贝出一个student。</li>
<li>再创建一个major的副本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Student cloneStu = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">if</span>(major!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            cloneStu.major = (Major) major.clone();<span class="comment">//!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneStu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用相同的测试代码，输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line"><span class="attribute">student1</span>==student2 <span class="literal">false</span></span><br><span class="line">两个student的major是否相同：<span class="literal">false</span></span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br><span class="line">Student&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h4 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h4><p><strong>Major</strong>、Student都实现Serializable接口，在Student中编写<code>clone()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream objectOutputStream  = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">            objectOutputStream.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            ObjectInputStream objectInputStream = </span><br><span class="line">                <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray()));</span><br><span class="line">            <span class="keyword">return</span> (Student2) objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样使用相同的测试代码，输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br><span class="line"><span class="attribute">student1</span>==student2 <span class="literal">false</span></span><br><span class="line">两个student的major是否相同：<span class="literal">false</span></span><br><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;信息安全&#x27;</span>, <span class="attribute">id</span>=666&#125;&#125;</span><br><span class="line">Student2&#123;<span class="attribute">name</span>=<span class="string">&#x27;小明&#x27;</span>, <span class="attribute">major</span>=Major2&#123;<span class="attribute">majorName</span>=<span class="string">&#x27;软件工程&#x27;</span>, <span class="attribute">id</span>=1&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h3 id="深拷贝List集合"><a href="#深拷贝List集合" class="headerlink" title="深拷贝List集合"></a>深拷贝List集合</h3><blockquote>
<p>来自参考链接</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">deepCopy</span><span class="params">(List&lt;T&gt; src)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">    out.writeObject(src);</span><br><span class="line"></span><br><span class="line">    ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray());</span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">    List&lt;T&gt; dest = (List&lt;T&gt;) in.readObject();</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247489983&idx=1&sn=fc1f623d49f3673e9e36510e769143ea&chksm=fddecf7bcaa9466de6e4de09012da3655f5bcb90bcf3359ca43631d5364b078e430bb8c271e6&mpshare=1&scene=1&srcid=120228fwNNHkIf13gg1jHqiu&sharer_sharetime=1606885191820&sharer_shareid=c7195d3c2809169af1ff4a6ce14ea626&key=cb86f5f7c317358fa51edff104c24ff634b46281c76208d61c0da26500b632ec1bc519f53f13e64e10c4c4dbcb00e1897ce2c3b5ff89ad6c9877da0455264e07dd5819acf815823a979bbd11a89688b7a979c0a4987cf0bd183eaa697ee91a97baa6639fad0a40fdffad5e561f56db83c21730ac04f27485a84fb4c4163b5773&ascene=1&uin=MzQwMjIxNDEyNw%3D%3D&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AUxwIEKoH5HA9BYrhguEofc%3D&pass_ticket=jNiOuUtB%2FWAFhQVzmTR2GW6ojOsx%2FZYdzbTSCYuZFBdnXx1pPMpWSkKvQI0C32rs&wx_header=0" target="_blank">程序羊-深拷贝、浅拷贝</a> </p>
<p><a href="https://blog.csdn.net/demonliuhui/article/details/54572908" target="_blank">java List复制：浅拷贝与深拷贝</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">Java-序列化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:56:39" itemprop="dateModified" datetime="2021-08-30T12:56:39+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序列化的含义和意义"><a href="#序列化的含义和意义" class="headerlink" title="序列化的含义和意义"></a>序列化的含义和意义</h2><p><strong>序列化指将Java对象转换成字节序列</strong>， 这些字节序列可以保存在磁盘上， 或者进行网络传输。反序列化即指<strong>将序列化后的字节序列重新恢复成对象</strong>。序列化机制使得对象可以脱离程序的运行而独立存在。</p>
<p>一个Java对象要能序列化，<strong>必须实现一个特殊的<code>java.io.Serializable</code>接口</strong>，这个接口不包含任何方法或成员变量，只是一个标记。</p>
<p>&emsp;  </p>
<h2 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化/反序列化"></a>序列化/反序列化</h2><p>序列化通过<strong>ObjectOutputStream</strong>来实现，它可以把一个Java对象写入字节流。</p>
<blockquote>
<p> <strong>当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名</strong>.</p>
</blockquote>
<p>反序列化使用<strong>ObjectInputStream</strong>对象，它可以从字节流中读取一个Java对象。若反序列化时要使用<code>readObject()</code>读出多个对象，注意要与写入的顺序一致。</p>
<p>&emsp;  </p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        writeObj();</span><br><span class="line">        readObj();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObj</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\person.ser&quot;</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;王大锤&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        objectOutputStream.writeObject(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;写入的对象：&quot;</span> + person);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObj</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\person.ser&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line"></span><br><span class="line">        Person person = (Person)objectInputStream.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取的对象：&quot;</span> + person);</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&#x27;s constructor&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略getter、setter、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person&#x27;s constructor</span><br><span class="line">写入的对象：Person&#123;<span class="attr">name=&#x27;王大锤&#x27;,</span> <span class="attr">age=25&#125;</span></span><br><span class="line">读取的对象：Person&#123;<span class="attr">name=&#x27;王大锤&#x27;,</span> <span class="attr">age=25&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到反序列化时，Person的构造器并没有执行。<strong>反序列化时，是由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时将不被执行</strong>。</p>
<p>&emsp;  </p>
<p>看另一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        objectOutputStream.writeObject(person);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray()));</span><br><span class="line">        Person readPerson = (Person)objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化得到的Person对象：&quot;</span> + readPerson);</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化得到的对象与原对象是否是同一对象：&quot;</span> + (person==readPerson));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反序列化得到的Person对象：Person&#123;<span class="attribute">name</span>=<span class="string">&#x27;张三&#x27;</span>, <span class="attribute">age</span>=20&#125;</span><br><span class="line">反序列化得到的对象与原对象是否是同一对象：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>可见反序列化得到的对象与原来的person不是同一个对象，即反序列化得到的是一个新的对象</strong>。</p>
<p>&emsp;  </p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>每一个可序列化类都会带有一个<strong>long类型的<code>serialVersionUID</code>静态常量值</strong>，<strong>如果没有人为显式定义过<code>serialVersionUID</code>，那编译器会根据类的各种信息为它自动声明一个</strong>。</p>
<p><strong><font color="red">serialVersionUID是序列化前后类的唯一标识符，在反序列化时，jvm会把字节流中的序列号id和被序列化类的序列号id进行比较，只有两个id相同才能成功反序列化，否则抛出InvalidClassException异常</font></strong>。</p>
<p><strong>若是没有人为指定序列号id，则若是改变类时（如添加新的成员变量），默认的serialVersionUID值将会改变</strong>。</p>
<p>示例：</p>
<p>执行上述例子的<code>writeObj()</code>方法后，在Person类定义中添加一个birth成员变量：<code>private Date birth;</code></p>
<p>再执行<code>readObj()</code>进行反序列化，此时抛出异常：<strong>即字节流中的serialVersionUID与Person类的不同</strong>。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Exception</span> <span class="keyword">in</span> thread &quot;main&quot; java.io.InvalidClassException: io.stream.<span class="keyword">serializable</span>.Person; <span class="keyword">local</span> <span class="keyword">class</span> incompatible: stream classdesc serialVersionUID = <span class="number">5578959987866231607</span>, <span class="keyword">local</span> <span class="keyword">class</span> serialVersionUID = <span class="number">-8466270221378179612</span></span><br></pre></td></tr></table></figure>



<p><strong>一般对于可序列化类，为了<code>serialVersionUID</code>的确定性，都要人为指定一个serialVersionUID值</strong>，可以使用idea的自动生成功能：<a href="https://www.jianshu.com/p/5dfa065b7890" target="_blank">IDEA自动生成serialVersionUID</a> 。</p>
<p>&emsp;  </p>
<h2 id="反序列化时的异常"><a href="#反序列化时的异常" class="headerlink" title="反序列化时的异常"></a>反序列化时的异常</h2><p><strong>在反序列化时<code>readObject()</code>可能抛出的异常有</strong>：</p>
<ul>
<li><code>ClassNotFoundException</code>：没有找到对应的Class；</li>
<li><code>InvalidClassException</code>：Class不匹配。</li>
</ul>
<p>抛出<code>ClassNotFoundException</code>的情况：一台电脑上的Java程序把一个Java对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义该类，所以无法反序列化，抛出该异常。</p>
<p>抛出<code>InvalidClassException</code>的情况：如serialVersionUID中的示例情况。</p>
<p>&emsp;  </p>
<h2 id="序列化的特殊情况"><a href="#序列化的特殊情况" class="headerlink" title="序列化的特殊情况"></a>序列化的特殊情况</h2><ul>
<li><strong>当要序列化的对象中包含其他引用类型变量的引用时，该变量对应的类也要实现Serializable接口</strong>。</li>
<li><strong>对同一个对象多次序列化，只有第一次序列化时JVM才会将对象转换为字节序列</strong>，之后的序列化只是直接输出一个序列化编号。且反序列化时多次使用<code>readObject()</code>读出的是同一个对象。</li>
</ul>
<p>&emsp;  </p>
<p>示例：</p>
<p>示例中的Person类同上。新增了一个ID类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stream.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ID</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5829455553074732547L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略getter、setter、toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>创建一个Person对象person和一个ID对象id，id中的Person指向person。将person和id序列化。再反序列，可看到<code>readId.getPerson()==readPerson</code>返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\id.ser&quot;</span>);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line"></span><br><span class="line">        ID id = <span class="keyword">new</span> ID();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;王大锤&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        id.setNumber(<span class="number">1</span>);</span><br><span class="line">        id.setPerson(person);</span><br><span class="line">        objectOutputStream.writeObject(id);</span><br><span class="line">        objectOutputStream.writeObject(person);</span><br><span class="line"></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">        ID readId = (ID) objectInputStream.readObject();</span><br><span class="line">        Person readPerson = (Person) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(readId);</span><br><span class="line">        System.out.println(readPerson);</span><br><span class="line">        System.out.print(<span class="string">&quot;readId.getPerson()==readPerson:&quot;</span>);</span><br><span class="line">        System.out.print(readId.getPerson()==readPerson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>凡是被<code>static</code>修饰的字段是不会被序列化的</strong>。<ul>
<li>因为序列化保存的是<strong>对象的状态</strong>而非类的状态，所以会忽略<code>static</code>静态域。</li>
</ul>
</li>
<li><strong>凡是被<code>transient</code>修饰符修饰的字段也是不会被序列化的</strong>。<ul>
<li>transient修饰符的作用就是修饰不想被序列号的成员变量，一般是对于一些要保密的字段，如密码。对于被transient修饰的字段，在序列号时以null值填充（<strong>对于值类型，则使用0、false等默认值</strong>）。</li>
</ul>
</li>
</ul>
<p>&emsp;  </p>
<p>还有一个点是<strong>序列化的受控和加强</strong>，具体见第3个参考链接中最后一个小节。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698" target="_blank">廖雪峰Java教程-序列化</a> </p>
<p><a href="https://www.runoob.com/java/java-serialization.html" target="_blank">菜鸟教程</a> </p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247486849&idx=1&sn=c0a2555ba22921187a28547b66877af8&scene=21#wechat_redirect" target="_blank">序列化/反序列化，我忍你很久了，淦！</a> （程序羊）</p>
<p>《疯狂Java讲义 第4版》</p>
</blockquote>
<p>&emsp;  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%9F%BA%E7%A1%80/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%9F%BA%E7%A1%80/%E5%8C%85%E8%A3%85%E7%B1%BB%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">包装类总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:56:31" itemprop="dateModified" datetime="2021-08-30T12:56:31+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java<strong>中</strong>有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型 ：byte、short、int、long、float、double</li>
<li>1 种字符类型：char</li>
<li>1 种布尔型：boolean。</li>
</ul>
<p>它们占的字节大小：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>字节</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>boolean</td>
<td></td>
</tr>
</tbody></table>
<p><strong>对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素</strong>。</p>
<p>&emsp;&emsp;</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>八种基本类型都有对应的包装类分别为：<strong>Byte、Short、Integer、Long、Float、Double、Character、Boolean</strong>。</p>
<h3 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h3><p>Java 是号称面向对象的语言，所有的类型都是引用类型。但是基本类型如 int 等不是引用类型，也不是继承自 Object，<strong>所以 Java 需要一个这样的包装类来使其具有对象的特性： 比如可以赋值为 null；且Java 集合中也只能放入包装类型，而不支持基本类型；可以创建一些特定的方法等</strong>。</p>
<p>&emsp;&emsp;</p>
<h3 id="自动装箱-自动拆箱及其原理"><a href="#自动装箱-自动拆箱及其原理" class="headerlink" title="自动装箱/自动拆箱及其原理"></a>自动装箱/自动拆箱及其原理</h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来（转换为对应的包装类）；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>自动装箱/自动拆箱是如何实现的？</p>
<p>编写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">2</span>;<span class="comment">// 装箱</span></span><br><span class="line">        <span class="keyword">int</span> b = a;<span class="comment">// 拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>javap -verbose</code> 指令，查看 main 方法的反编译字节码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> main(java.lang.String[]);</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_2</span><br><span class="line">        <span class="number">1</span>: invokestatic  #<span class="number">2</span>   <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">4</span>: astore_1</span><br><span class="line">        <span class="number">5</span>: aload_1</span><br><span class="line">        <span class="number">6</span>: invokevirtual #<span class="number">3</span>   <span class="comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">        <span class="number">9</span>: istore_2</span><br><span class="line">       <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong style="color:red">可以看到，自动装箱实际上是调用对应包装类的 <code>static valueOf()</code> 方法；而对于自动拆箱，调用的是包装类对象的 <code>xxxValue()</code> ，其中，xxx代表对应的基本数据类型</strong>。 </p>
<p>&emsp;&emsp;</p>
<p>Integer 中的这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean 中，<font color="red">前面 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True Or False</font>。如果超出对应范围仍然会去创建新的对象</strong>。 </p>
<p><strong style="color:red">对以上包装类调用 <code>valueOf()</code> 方法会首先尝试从 cache 中获取值，若不能命中，则使用 new 创建对象</strong> 。</p>
<p>如上面所示 Integer 的 <code>valueOf()</code> 方法中的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br></pre></td></tr></table></figure>

<p>其中 cache 的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br></pre></td></tr></table></figure>

<p>其在 static 静态块中被初始化（摘取部分代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> j = low;<span class="comment">// low 为 -128</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">    cache[k] = <span class="keyword">new</span> Integer(j++);</span><br></pre></td></tr></table></figure>

<p>对于 Byte,Short,Long,Character 类似。</p>
<p><strong>对于 Double、Float 的 <code>valueOf()</code> 则是直接使用 new 创建对象返回</strong>。</p>
<p>&emsp;&emsp;</p>
<p>一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6)); <span class="comment">//true   </span></span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Double d1 = <span class="number">1.2</span>;</span><br><span class="line">Double d2 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(d1 == d2);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p><strong style="color:red">使用 <code>==</code> 比较时要注意的点</strong>：</p>
<ul>
<li><strong>当 “==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象</strong>；</li>
<li>如果其中有一个操作数是表达式（<strong>即包含算术运算</strong>）或有一边是基本类型，则比较的是数值（<strong>即会触发自动拆箱的过程</strong>）。<strong>例如对于 i4 == i5 + i6，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40，再将 i4 拆箱，即 <code>40==40</code> </strong>。</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h3><p>所有包装类（<strong>注意是所有</strong>）的 <code>equals()</code> 方法在进行比较时，<strong>都是先判断参数值是不是当前包装类类型</strong>，</p>
<ul>
<li><strong>若不是直接返回 false</strong>。</li>
<li><strong>若是，则比较两者中封装的 value 成员变量值是否相等</strong>。</li>
</ul>
<p>例如对于 Integer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Integer i = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(g.equals(i));<span class="comment">// false ，g 和 i 的类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong style="color:red">若是 equlas 传入的参数是基本类型，则会转换为对应的包装类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(g.equals(a+b));<span class="comment">// false</span></span><br><span class="line">    System.out.println(g.equals(<span class="number">3</span>));<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_13-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">javaGuide</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析Java中的装箱和拆箱</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%9F%BA%E7%A1%80/equals%E5%92%8ChashCode%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%9F%BA%E7%A1%80/equals%E5%92%8ChashCode%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">equals和hashCode总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:56:48" itemprop="dateModified" datetime="2021-08-30T12:56:48+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>hashCode()</code> 的作用是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。</p>
<blockquote>
<p><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code> ，则一个 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<p>&emsp;&emsp;</p>
<p><strong>该方法主要是为了支持如 HashSet 、 HashMap 等基于哈希表实现的集合</strong>。</p>
<p> 也就是说：<strong>hashCode() 在散列表中才有用，在其它情况下没用。</strong>在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<p>讨论 equals() 和 hashCode() 的关系应该分两种情况进行：</p>
<h2 id="不会创建“类对应的散列表”"><a href="#不会创建“类对应的散列表”" class="headerlink" title="不会创建“类对应的散列表”"></a>不会创建“类对应的散列表”</h2><p><strong>第一种是不会在 HashSet, Hashtable, HashMap 等基于哈希表实现的数据结构中用到该类</strong>，<strong style="color:red">这种情况下 equals() 和 hashCode() 没有关系，如果要比较对象，只需使用 equals() 来进行比较，而并不需要用到 hashCode() </strong>，**所以重写 equals() 时不需要重写 hashCode()**。</p>
<p>比如只是要比较两个 Person 对象的 name 是否相同，但没有要将其放到 HashSet 等集合，只需重写 equals() 即可，如：</p>
<p>（来自参考链接）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否类型相同  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    Person person = (Person)obj;  </span><br><span class="line">    <span class="keyword">return</span> name.equals(person.name);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="会创建“类对应的散列表”"><a href="#会创建“类对应的散列表”" class="headerlink" title="会创建“类对应的散列表”"></a>会创建“类对应的散列表”</h2><p><strong>第二种情况则是会在 HashSet, Hashtable, HashMap 等基于哈希表实现的数据结构中用到该类</strong>。</p>
<p>这时需要注意两者的关系：</p>
<ul>
<li><p><strong>若是两个对象使用 equals() 比较返回 true，那么使用 hashCode() 应该返回相同的哈希值。否则会出现 “ 两个对象是相同的(equals 返回 true)，但却可以放进同一个哈希表 ”  的情况</strong>。</p>
<blockquote>
<p>hashCode() 的 javaDoc ：If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</p>
</blockquote>
</li>
<li><p><strong style="color:red">但如果使用 equals() 比较返回 false ，并不要求 hashCode() 返回不同的值</strong>。因为在哈希表中，即使两个哈希值相同（两个 key 相同），它们的值不一定相同（value 不一定相同），这种情况即哈希碰撞。</p>
<blockquote>
<p>hashCode() 的 javaDoc ：It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results</p>
</blockquote>
<p>一个要注意的点是：<strong>在 HashSet 、 HashMap 等基于哈希表的集合中，若是两个对象使用 equals() 比较返回 false，但 hashCode() 返回相同的值（即产生哈希碰撞时），还是会将两个对象都放进集合（这时会使用哈希碰撞解决方法，如拉链法，红黑树等）</strong>。</p>
</li>
</ul>
<p>&emsp;&emsp;</p>
<p><strong>所以若是要在哈希表实现的数据结构中使用到某个类，则需要重写这个类的 equals() 和 hashCode() ，并保证它们满足上述关系</strong>。</p>
<p>示例：（来自参考链接）</p>
<p>定义 Person 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; - &quot;</span> +age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个对象的 name 的大写相同且年龄相同时，返回相同的哈希值</span></span><br><span class="line">        <span class="keyword">int</span> nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">        <span class="keyword">return</span> nameHash ^ age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一个对象返回true，反之返回false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否类型相同</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// name 相同（区分大小写）且年龄相同返回 true </span></span><br><span class="line">        Person person = (Person)obj;</span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建Person对象，</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line">    Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;EEE&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建HashSet对象</span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    set.add(p3);</span><br><span class="line">    set.add(p4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, </span><br><span class="line">                      p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">    <span class="comment">// 比较p1 和 p4， 并打印它们的hashCode()</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;</span>, </span><br><span class="line">                      p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">    <span class="comment">// p1.equals(p2) : true; p1(68545) p2(68545)</span></span><br><span class="line">	<span class="comment">// p1.equals(p4) : false; p1(68545) p4(68545)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印set，可以看到 p1 p4 equals返回 false，但 hashcode 相同，所以都被放进集合</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;set:%s\n&quot;</span>, set);</span><br><span class="line">    <span class="comment">// set:[eee - 100, EEE - 100, aaa - 200]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不重写 hashCode() ，那么 p1、p2 都可以被放进 set 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么重写 equals() 时需要重写 hashCode() ：</p>
<ul>
<li><p>如果类的对象不会在哈希表结构中使用，则重写 <code>equals()</code> 方法时无需重写 <code>hashCode()</code> 方法。</p>
</li>
<li><p>如果要在 HashMap、HashSet 等哈希表结构中使用，则重写 <code>equals()</code> 方法时需重写 <code>hashCode()</code> 方法。一般约定 equals  比较返回 true 则 hashCode 应该返回相同的值，<strong>一般 equals 比较相同则认为 2 个对象是【相同的】，而若是 hashCode 返回不同的值，则这 2 个相同的对象是可以都被放入一个 HashMap 或 HashSet 中的</strong>。默认实现的 hashCode 对于 2 个不同的对象无论如何都是返回不同的值的。</p>
<p>另外，若是 hashCode 相同，不要求 equals 比较返回 true ，这种情况即哈希碰撞，在 HashMap 等结构中都有处理方法（链表、红黑树）。</p>
</li>
</ul>
<hr>
<p>参考：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a> </p>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_129-hashcode%e4%b8%8e-equals">hashCode() 与 equals()</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%9F%BA%E7%A1%80/byte%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%9F%BA%E7%A1%80/byte%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">byte类型总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:56:42" itemprop="dateModified" datetime="2021-08-30T12:56:42+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="byte类型数据的范围"><a href="#byte类型数据的范围" class="headerlink" title="byte类型数据的范围"></a>byte类型数据的范围</h2><p>Java中一个byte类型数据的大小是一个字节，即8位，其范围是-128（1000_0000) ~ 127（0111_1111），二进制的最高位是符号位。</p>
<p>&emsp;  </p>
<h2 id="使用二进制形式赋值报错问题"><a href="#使用二进制形式赋值报错问题" class="headerlink" title="使用二进制形式赋值报错问题"></a>使用二进制形式赋值报错问题</h2><p>为byte类型变量赋值只能是-128~127范围内的数。</p>
<p>可以使用二进制形式赋值，如：<code>byte b = 0b10011;</code> （b=19）。<strong>且使用二进制赋值时，系统是以补码形式解析赋值的二进制数（如对于<code>0b10011</code>是19；对于<code>0b1111_1101</code>则是-3）</strong>。</p>
<p>若想使用二进制形式赋值一个负数，如：<code>byte b = 0b1001_0101;</code>，<strong>编译器会报类型不兼容的错误</strong>（int不能赋值给byte）。需要添加类型强制转换：<code>byte b = (byte) 0b1001_0101;</code> </p>
<p><strong>原因</strong>：（参考：<a href="https://www.cnblogs.com/ntyvictory/p/10650834.html" target="_blank">关于JAVA中Byte数据类型二进制赋值运算报错问题</a>）</p>
<p>byte共有8个比特位，其中最高位是符号位，给它赋值<code>0b1001_0101</code>时，<strong>最高位的1系统无法判断是实际数值还是符号位数值</strong>。添加强制类型转换<code>(byte)</code>，则系统可以知道1是符号位，此时可以被赋值；<strong>如果没有加强制类型转换，则系统认为<code>0b1001_0101</code>是一个int类型数据</strong>。int类型值无法赋值给byte变量，所以会报错。</p>
<p>&emsp;  </p>
<h2 id="以二进制形式输出byte"><a href="#以二进制形式输出byte" class="headerlink" title="以二进制形式输出byte"></a>以二进制形式输出byte</h2><p>以二进制形式输出byte可以通过包装类<code>Integer</code>的静态方法<code>toBinaryString(int i)</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">12</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line">System.out.println(Integer.toBinaryString(b));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>但若是通过该方法输出一个负数的byte变量，会看到结果是输出了一个32位的二进制数，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = -<span class="number">2</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">11111111111111111111111111111110</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>这是因为byte值被赋值给<code>toBinaryString()</code>方法时被转换为int类型，即变成32位</strong>。对于上个例子的正数也一样被转换为int，只不过因为是正数，所以高位的0可以被省略，因而看起来是正常显示；<strong>但对于负数，高位的1不可以省略，所以以32位形式显示</strong>。</p>
<p>&emsp;  </p>
<p>针对负数的byte，可以截取结果的后8位，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a = -<span class="number">2</span>;</span><br><span class="line">    String aBinary = Integer.toBinaryString(a);</span><br><span class="line">    aBinary = aBinary.substring(aBinary.length()-<span class="number">8</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;原二进制数：&quot;</span> + Integer.toBinaryString(a));</span><br><span class="line">    System.out.println(<span class="string">&quot;截取后的二进制数：&quot;</span> + aBinary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">原二进制数：11111111111111111111111111111110</span></span><br><span class="line"><span class="comment">截取后的二进制数：11111110</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>&emsp;  </p>
<p>一个<code>Integer.toBinaryString()</code>处理byte值（对于正数，进行左补0；对于负数，截取后8位）的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">byte</span> b = -<span class="number">2</span>;</span><br><span class="line">        String aBinary = getBinaryByteStr(Integer.toBinaryString(a));</span><br><span class="line">        String bBinary = getBinaryByteStr(Integer.toBinaryString(b));</span><br><span class="line">        System.out.println(aBinary);</span><br><span class="line">        System.out.println(bBinary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getBinaryIntWithZero</span><span class="params">(String binary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zeroCount = <span class="number">8</span> - binary.length();</span><br><span class="line">        String zeros = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(zeroCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zeroCount; i++) &#123;</span><br><span class="line">                zeros += <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zeros + binary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取8位二进制形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBinaryByteStr</span><span class="params">(String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b.length()&gt;<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> b.substring(b.length()-<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getBinaryIntWithZero(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/%E5%85%B6%E4%BB%96/Comparable%E5%92%8CComparator%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/%E5%85%B6%E4%BB%96/Comparable%E5%92%8CComparator%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">Comparable和Comparator用法小结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:58:05" itemprop="dateModified" datetime="2021-08-30T12:58:05+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">其它</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Comparable 接口和 Comparator 接口都是用来比较两个对象。一个类实现 Comparable 表示该类的对象之间可以比较；Comparator 则表示一个比较器，传入两个对象，返回比较结果。</p>
<p>它们的代码定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组工具类和集合工具类中提供的 sort 排序方法就要求被排序的类实现 Comparable 接口或需要传入一个 Comparator 对象。</p>
<h2 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h2><p><code>compareTo</code> 或 <code>compare</code> 都是返回一个 int 类型值。</p>
<p>对于 <code>o1.compareTo(o2)</code> 或 <code>compare(o1, o2)</code> ，返回不同 int 值时的意义：</p>
<ul>
<li>返回 0 ，表示两个值相等。</li>
<li><strong style="color:red">返回 负数，表示 o1 会排在 o2 前面。即若是返回负数，o1、o2 位置不变</strong>。</li>
<li><strong style="color:red">返回 正数，表示 o1 会排在 o2 后面。即若是返回正数，o1、o2 位置交换</strong>。</li>
</ul>
<p>根据这 3 个点，在定义比较规则时，从 “<strong>返回负数表示两个值位置不变</strong>” 这个点入手：</p>
<ul>
<li>若是要按某个值升序排序，即返回负数的情况（o1，o2 位置不变）是 o1&lt;o2 ，则应该 <code>return o1-o2</code> 。这样当返回负数时，o1、o2 是升序的，位置不用变；返回正数，表示 o1 大于 o2，此时是降序的，应该交换位置。</li>
<li>而若是降序，返回负数的情况应是 o1&gt;o2 ，则应该 <code>return o2-o1</code> 。同理。</li>
</ul>
<p>示例：</p>
<p>定义类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">A</span>&gt;</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序时按 num 值递增进行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(A o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递增（升序），对应上面所说的 return o1-o2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num - o.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 A 的多个对象加入 List ，用 sort 方法进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="string">&quot;a1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    A a2 = <span class="keyword">new</span> A(<span class="string">&quot;a2&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    A a3 = <span class="keyword">new</span> A(<span class="string">&quot;a3&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;A&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(a1);</span><br><span class="line">    list.add(a2);</span><br><span class="line">    list.add(a3);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="keyword">before</span> sort: [A&#123;<span class="type">name</span>=<span class="string">&#x27;a1&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a2&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a3&#x27;</span>&#125;]</span><br><span class="line"><span class="keyword">after</span> sort: [A&#123;<span class="type">name</span>=<span class="string">&#x27;a1&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a3&#x27;</span>&#125;, A&#123;<span class="type">name</span>=<span class="string">&#x27;a2&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>再看一个复杂一点的例子，对一个 nx2 的数组按<strong>第一个值升序排序，若第一个值相等，第二个值倒序排序</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;before sort: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （这里使用 Lambda 表达式， o1、o2 是一个一维数组）</span></span><br><span class="line">    <span class="comment">// 第一个值相等时，第二个值倒序排序；否则第一个值升序排序</span></span><br><span class="line">    Arrays.sort(array, (o1, o2)-&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o2[<span class="number">1</span>] - o1[<span class="number">1</span>] : o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\nafter sort: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before sort:</span> </span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">after sort:</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>]     </span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">类文件结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:58:28" itemprop="dateModified" datetime="2021-08-30T12:58:28+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="class文件结构概述"><a href="#class文件结构概述" class="headerlink" title="class文件结构概述"></a>class文件结构概述</h2><p><strong>Class文件是一组<font color="red">以字节为基础单位</font>的二进制流， 各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</strong>，当遇到需要占用单个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个字节进行存储。</p>
<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，<strong>这种伪结构中只有两种数据类型</strong>：<strong>“无符号数”和“表”</strong>。</p>
<ul>
<li>无符号数属于基本的数据类型，以<strong><font color="red">ul、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数</font></strong>，无符号数<strong>可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</strong>。</li>
<li><strong>表是由多个无符号数或者其他表作为数据项构成的复合数据类型</strong>，表的命名习惯以“info”结尾。表用于描述有层次关系的复合结构的数据。</li>
</ul>
<p>整个Class文件本质上也可以视作是一张表， 这张表由下图所示的数据项按严格顺序排列构成。<strong>该格式中的数据项，无论是顺序还是数量，都是被严格限定的</strong>。(【】内表示数量，第一列表示数据类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;【<span class="number">1</span>】 <span class="comment">//Class文件的标志（魔数）</span></span><br><span class="line">    u2             minor_version;【<span class="number">1</span>】<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;【<span class="number">1</span>】<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool【constant_pool_count-<span class="number">1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br><span class="line">    u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;【<span class="number">1</span>】<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;【<span class="number">1</span>】<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;【<span class="number">1</span>】<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces;【interfaces_count】<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;【<span class="number">1</span>】<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields;【fields_count】<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;【<span class="number">1</span>】<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods;【methods_count】<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;【<span class="number">1</span>】<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes;【attributes_count】<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class文件中，<strong>当需要描述同一类型但数量不定的多个数据项时，使用一个前置的容量计数器（u2无符号数，即两个字节）加若干个连续的数据项的形式来表示</strong>。</p>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure>

<p>每个Class文件的头4个字节称为魔数，用于<strong>标志这是一个能被JVM接受的class文件</strong>。其值为<code>0xCAFEBABE</code>。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version<span class="comment">;【1】</span></span><br><span class="line">u2             major_version<span class="comment">;【1】</span></span><br></pre></td></tr></table></figure>

<p><strong>紧接的4个字节是class文件的版本号，第5、6为次版本号（Minor Version），第7、8为主版本号（Major Version）</strong>。</p>
<p><strong>高版本的 Java 虚拟机可以向下兼容执行低版本编译器生成的 Class 文件</strong>，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p>
<blockquote>
<p>jdk1.1对应45（十进制），往上依次递增1。如jdk1.8对应52（0x34）</p>
</blockquote>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;【<span class="number">1</span>】<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool【constant_pool_count<span class="number">-1</span>】;<span class="comment">//常量池 数量是constant_pool_count-1，0号</span></span><br></pre></td></tr></table></figure>

<p>紧接着主、次版本号之后的是常量池， <strong>常量池可以比喻为Class文件里的资源仓库， 它是Class文件结构中与其他项目关联最多的数据</strong>。</p>
<p><strong>常量池中常量的数量是不固定的</strong>。constant_pool_count指定常量数量。<strong>这个容量计数是从1而不是0开始的</strong>，例如，若是0x0018（十进制24），即表示有24-1=23个常量。<strong>将第0项常量空出来的目的在于</strong>：<strong><font color="red">如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义， 可以把索引值设置为0来表示</font></strong>。</p>
<p>对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始。</p>
<p>常量池中主要存放两大类常量：<strong>字面量和符号引用</strong>。</p>
<ul>
<li>字面量比较接近于Java语言层面的常量概念， 如文本字符串、被声明为final的常量值等。</li>
<li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul>
<li>被模块导出或者开放的包</li>
<li><strong>类和接口的全限定名</strong> </li>
<li>**字段的名称和描述符 ** </li>
<li><strong>方法的名称和描述符</strong> </li>
<li>方法句柄和方法类型</li>
<li>动态调用点和动态常量</li>
</ul>
</li>
</ul>
<blockquote>
<p>Java代码在进行Javac编译的时候， 并不像C和C++那样有“连接”这一步骤， 而是<strong>在虚拟机加载Class文件的时候进行动态连接</strong>的 。也就是说， <strong>在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存人口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</strong>。</p>
</blockquote>
<p>常量池中每一项常量都是一个表，<strong>截至JDK13</strong>， 常量表中分别有17种不同类型的常量。<strong>这些表都有一个共同的特点， 表结构起始的第一位是个u1类型的标志位</strong>(tag， 见下表标志列)，代表着当前常量属于哪种常量类型。17种类型如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志（tag）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>５</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>６</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>７</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>８</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>９</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MothodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_Dynamic_info</td>
<td>17</td>
<td>表示一个动态计算常量</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
<tr>
<td>CONSTANT_Module_info</td>
<td>19</td>
<td>表示一个模块</td>
</tr>
<tr>
<td>CONSTANT_Package_info</td>
<td>20</td>
<td>表示一个模块中开发或者导出的包</td>
</tr>
</tbody></table>
<p>常见的11种类型的结构表：（index表示指向第几个常量项）</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125112646190.png" alt="image-20210125112646190"></p>
<blockquote>
<p>在读取常量池时，只要读取每个项的第一个字节（tag）就可得知其类型，得知其类型后就能知道该项占多少字节，也就可以知道下一项从哪里开始，以此类推。</p>
</blockquote>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;【<span class="number">1</span>】<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure>

<p>常量池结束之后紧接着的两个字节代表<strong>访问标志</strong>，这个标志用于识别一些类或者接口层次的访问信息，即一个类或接口使用了哪些访问修饰符（public、abstract等）。</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125113620989.png" alt="image-20210125113620989"></p>
<p>一个类或接口可拥有多个标志，<strong>这时标志值应该为这多个标志值取或</strong>。如 ACC_PUBLIC | ACC_SUPER = 0x0021。</p>
<h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><pre><code>u2             this_class;【1】//当前类
u2             super_class;【1】//父类
u2             interfaces_count;【1】//接口数量
u2             interfaces;【interfaces_count】//一个类可以实现多个接口</code></pre>
<p>类索引和父类索引都是一个u2类型的数据， 而接口索引集合是一组u2类型的数据的集合， Class文件中<strong>由这三项数据来确定该类型的继承关系</strong>。</p>
<ul>
<li><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名</strong>。Java不允许多继承， 所以父类索引只有一个， 除了java.lang.Object之外， 所有的Java类都有父类， 因此除了java.lang.Object外， 所有Java类的父类索引都不为0。<strong>这是两个索引值，指向常量池的对应项</strong>。</p>
</li>
<li><p><strong>接口索引集合</strong>描述这个类实现了哪些接口，集合第一个项是接口计数器，之后是对应数量的接口索引（若计数器为0则不再占用任何字节）。<strong>这些接口索引将按implements关键字（如果该Class文件表示接口， 则是extends）后的接口顺序从左到右排列在接口索引集合中</strong>。</p>
</li>
</ul>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><pre><code>u2             fields_count;【1】//Class 文件的字段属性
field_info     fields;【fields_count】//一个类会可以有多个字段</code></pre>
<p>字段表用于描述接口或类中声明的变量。字段<strong>包括类级变量以及实例变量</strong>，但<strong>不包括在方法内部声明的局部变量</strong>。</p>
<p>一个字段表的结构（来自javaGuide）：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p>
<p>各字段解释：</p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ，<code>private</code>，<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符），可否被序列化（transient 修饰符），可变性（final），可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><strong>name_index:</strong> <strong>对常量池的引用</strong>，表示的字段的简单名称；</li>
<li><strong>descriptor_index:</strong> <strong>对常量池的引用</strong>，表示字段和方法的描述符；</li>
<li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，<strong>适合使用标志位来表示。而字段叫什么名字、字段数据类型都是无法固定的，只能引用常量池中常量来描述</strong>。</p>
<p><strong>字段表中不会列出继承自父类或父接口的字段</strong>。</p>
<blockquote>
<p>关于描述符：描述符用来描述<strong>字段的数据类型</strong>，或方<strong>法的参数列表（包括数量、类型和顺序）和返回值</strong>。基本数据类型以及无返回值void都用一个大写字符表示，对应关系：</p>
<ul>
<li>B- byte， C-char， D- double， F- float， I- int， J- long， s- short， z-boolean， v- void， L-对象类型，如Ljava.lang.String</li>
<li>对于数组，一个维度对应一个 <code>[</code>， + L + 元素类型，如<code>[[I，[[Ljava.lang.String</code>。</li>
</ul>
<p>描述符描述方法时，<strong>按照先参数列表后返回值的顺序</strong>，如<code>()V 、(I)Ljava.lang.String</code>。</p>
</blockquote>
<p>access_flags表示访问标志，即字段的修饰符，其取值如下：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150405202.png" alt="image-20210125150405202"></p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><pre><code>u2             methods_count;【1】
method_info    methods;【methods_count】</code></pre>
<p>分别表示方法数量和方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构与字段表一样，如下：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125150122301.png" alt="image-20210125150122301"></p>
<p><strong>Java方法里的代码，经Javac编译成字节码之后，放在方法属性表集合中一个名为“Code”的属性里面</strong>。</p>
<p>标志位取值：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125173337287.png" alt="image-20210125173337287"></p>
<blockquote>
<p>synchronized关键字 的字节码相关： P46</p>
</blockquote>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="regexp">//</span>此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];<span class="regexp">//</span>属性表集合</span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="一些常见属性"><a href="#一些常见属性" class="headerlink" title="一些常见属性"></a>一些常见属性</h3><p>1.<strong>Code属性</strong> </p>
<p>结构：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210125174146152.png" alt="image-20210125174146152" style="zoom:80%;" />

<ul>
<li><p>attribute_length表示attribute所包含的字节数，不包含 attribute name index和attribute length字段。</p>
</li>
<li><p>max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度</p>
</li>
<li><p>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量</p>
</li>
</ul>
<p>2.<strong>LineNumberTable</strong>属性</p>
<p>用于表示Code中的字节码与源码的行号对应关系（一行对应一个指令）</p>
<p>3.LocalVariableTable</p>
<p>局部变量表，记录局部变量信息，其中的变量名等会引用常量池中的utf8字符串常量。</p>
<p><strong>对于实例方法，在class文件中，每个方法内至少会有一个局部变量：this，即所属对象的引用</strong></p>
<h2 id="To-be-continue"><a href="#To-be-continue" class="headerlink" title="To be continue"></a>To be continue</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>《深入理解JVM》</p>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/?id=java">JavaGuide文档</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="bxxiao">
      <meta itemprop="description" content="nothing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bxxiao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">类加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 14:06:50" itemprop="dateCreated datePublished" datetime="2021-08-25T14:06:50+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 12:58:22" itemprop="dateModified" datetime="2021-08-30T12:58:22+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-类的生命周期"><a href="#1-类的生命周期" class="headerlink" title="1. 类的生命周期"></a>1. 类的生命周期</h2><p><strong>类的生命周期</strong>：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210123141452535.png" alt="image-20210123141452535"></p>
<p>类的加载、连接和初始化都是在<strong><font color="red">程序运行期间</font></strong>完成的。这为 Java 程序提供更大的灵活性。</p>
<p>以下<strong>几种情况</strong>，生命周期将结束：</p>
<ul>
<li>执行了 <code>System.exit()</code>或<code>Runtime.getRuntime().exit()</code> 方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
<li>JVM进程被终止。</li>
</ul>
<h2 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2. 类加载过程"></a>2. 类加载过程</h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，当程序<strong>主动使用</strong>某个类时，若该类未被加载到内存中（<strong>即首次主动使用</strong>），则系统<strong>通过加载、连接、初始化 3 个步骤来对该类进行初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p>类加载过程概览：</p>
<img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210118171003597.png" alt="image-20210118171003597" style="zoom:80%;" />

<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载指<strong>将类的 class 文件读入内存</strong>，将其<strong>放在运行时数据区的方法区内</strong>，并<strong>为之创建一个 <code>java.lang.Class</code> 对象</strong>，<strong>用来封装类在方法区内的数据结构，并提供了方法区内的数据结构的接口</strong>。（JVM 规范并未说明 Class 对象位于哪里， HotSpot 虚拟机将其放在了方法区中）</p>
<p>加载阶段主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口</strong></li>
</ol>
<p>加载 class 文件的方式：</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载 class 文件</li>
<li>从 zip，jar 等归档文件中加载 class 文件</li>
<li>将 Java 源文件<strong>动态编译</strong>为 class 文件（如动态代理）</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><strong>连接阶段负责把类的二进制数据合并到 JRE 中</strong>。包含 3 个步骤：</p>
<ul>
<li><p><strong>验证</strong>：检验被加载的类是否有正确的内部结构并和其他类协调一致。</p>
<ul>
<li><p><strong>Class 文件不一定由 Java 文件编译而来，需要对其进行验证，防止加载错误或恶意的字节码流。</strong> </p>
</li>
<li><p>类的验证的部分内容：类文件的结构检查；语义检查；字节码验证；二进制兼容性的验证等。</p>
</li>
<li><p>图片来自 JavaGuide：</p>
<p><img src="https://gitee.com/bxgitee/noteImage/raw/master/image/image-20210227110905036.png" alt="image-20210227110905036"></p>
</li>
</ul>
</li>
<li><p><strong>准备</strong>：为<strong>类的类变量</strong>分配内存，<strong>并设置默认初始值</strong>。<strong><font color="red">通常情况下，不管有无为静态变量指定初始值，在准备阶段都会先将其初始化为零值</font></strong>。而若是类字段的字段属性表中存在 ConstantValue 属性，则会初始化为该属性指定的初始值，如使用了 <code>final static</code> 的情况。</p>
</li>
<li><p><strong>解析</strong>：将类的二进制数据中的<strong><font color="red">符号引用替换为直接引用</font></strong>。</p>
<ul>
<li><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符</strong> 7 类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是<strong>直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong>。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，<strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量</strong>。(<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">JavaGuide-类的加载过程</a> )</p>
</li>
<li><p><strong>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的</strong>，它们必须按顺序的开始，<strong><font color="red">而解析阶段不一定，它可以在初始化阶段之后再开始</font></strong>。</p>
<blockquote>
<p><strong>这里 “必须按顺序的开始” 的意思是，这些阶段 “开始” 的时机有前后顺序，但它们可以互相交叉的混合进行，会在一个阶段执行的过程中调用、激活另一个阶段</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段，虚拟机对类进行初始化，<strong>主要是对类变量进行初始化（赋指定的值）</strong>。JVM 会<strong>按顺序</strong>执行类文件中的初始化语句（static）。</p>
<p>初始化一个类包含以下步骤：</p>
<ul>
<li>若该类还没被加载和连接，则对该类进行加载和连接。</li>
<li><strong>若该类的直接父类没有被初始化，对该父类执行初始化</strong>。</li>
<li>若类中有初始化语句，则依次执行这些语句。</li>
</ul>
<p><strong>执行第 2 个步骤时，对父类的初始化步骤同样遵循这 3 个步骤</strong>。若父类有直接父类，则进行同样操作，以此类推。<strong>所以 JVM 最先初始化的总是 <code>java.lang.Object</code> 类</strong>。</p>
<p><strong>只有<font color="red">主动使用类时</font>才会对类执行初始化操作</strong>。</p>
<h2 id="3-类的卸载"><a href="#3-类的卸载" class="headerlink" title="3. 类的卸载"></a>3. 类的卸载</h2><p>当一个类被加载、连接和初始化后，它的生命周期就开始了。<strong>当代表该类的 Class 对象不再被引用，即不可触及时该 Class 对象就会被 JVM 垃圾回收机制回收，结束生命周期</strong>， 该类在方法区内的数据也会被卸载，从而结束当前类的生命周期。</p>
<p><strong><font color="red">类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期</font></strong>。</p>
<ul>
<li>每一个类加载器包含被它所加载的 Class 对象的引用。</li>
<li>程序中的每一个对象包含一个其所属类对应的 Class 对象的引用。（<code>obj.class</code>）</li>
</ul>
<p>这两种引用不存在时类才会被卸载。即不存在指向相关类加载器的引用，和不存在该 Class 对应的对象的情况。</p>
<p><strong>由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载</strong>。Java 虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的 Class 对象，因此这些 Class 对象始终是可触及的。<strong>而由用户自定义的类加载器所加载的类是存在被卸载的可能的</strong>。</p>
<p>验证示例：</p>
<p>使用<code>类加载器</code>中的 MyClassLoader，编写测试代码，运行时添加 JVM 参数 <code>-XX:+TraceClassUnloading</code>（跟踪卸载）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String path = <span class="string">&quot;E:\\AAAFrequently-used\\temp\\&quot;</span>;</span><br><span class="line">    MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">    loader.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;classloader.MyTest1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    loader = <span class="keyword">null</span>;</span><br><span class="line">    clazz =<span class="keyword">null</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//没有任何引用指向MyTest1的Class对象，执行垃圾回收，MyTest1的Class对象将被卸载</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 loader、clazz、obj 都置为 null，调用 <code>System.gc()</code> 执行垃圾回收，</p>
<p>会导致 MyTest1 的 Class 对象被卸载，输出：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Unloading <span class="class"><span class="keyword">class</span> <span class="title">classloader</span>.<span class="title">MyTest1</span> 0<span class="title">x0000000100061028</span>]</span></span><br></pre></td></tr></table></figure>



<h2 id="4-主动使用和被动使用"><a href="#4-主动使用和被动使用" class="headerlink" title="4. 主动使用和被动使用"></a>4. 主动使用和被动使用</h2><h3 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h3><p><strong>《JVM规范》严格规定<font color="red">有且只有</font>以下 6 种情况需要立即对类进行初始化</strong>：</p>
<ul>
<li><strong>当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时</strong>。对应以下情况：<ul>
<li>创建类的示例。（JVM 执行 <strong>new 指令</strong>）。</li>
<li>访问某个类的静态变量（JVM 执行 <strong>getstatic 指令</strong>），或为其静态变量赋值（JVM 执行 <strong>putstatic 指令</strong>）（<strong>注意静态常量除外</strong>）。</li>
<li>调用类的静态方法（JVM 执行 <strong>invokestatic 指令</strong>）。</li>
<li><strong style="color:red">注意</strong>：<strong>访问静态内部类的 static 变量，创建静态内部类的实例不会造成外部类的初始化</strong>。这些情况下的 <code>new</code>、<code>getstatic</code> 等针对的是这个静态内部类，只会触发静态内部类的初始化。</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行<strong>反射调用</strong>时。如 <code>Class.forname(&quot;...&quot;)</code>，<code>newInstance()</code> 等。</li>
<li>初始化一个子类时，<strong>若父类未初始化，先触发该父类的初始化</strong>。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (<strong>包含 main 方法的类</strong>)，<strong>虚拟机会先初始化这个类</strong>。</li>
<li>当使用 JDK 7 新加人的动态语言支持时， 如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果为 REF_get Static、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个<strong>接口</strong>中定义了 JDK8 新加入的<strong>默认方法</strong>（被 default 关键字修饰的接口方法）时，<strong>如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</strong>。</li>
</ul>
<p><strong>这六种场景的行为称为对一个类型进行主动引用，其他情况的引用都称为被动引用，不会引起初始化</strong>。</p>
<h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p><strong>除了以上情况，其他情况视为对类的被动使用，不会触发对类的初始化</strong>。一些被动使用的情况：</p>
<ul>
<li><p>通过子类访问父类的静态变量，不会导致子类的初始化。<strong>访问静态变量，只有定义了该变量的类才会被初始化</strong>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">&quot;hello，world&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent1&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str1 = <span class="string">&quot;shit&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Child的static块没有执行</span></span><br><span class="line">        <span class="comment">//访问静态字段，只有定义了该字段的类才会吧被初始化</span></span><br><span class="line">        <span class="comment">// System.out.println(Child.str);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Parent1和Child1的static都执行了</span></span><br><span class="line">        <span class="comment">//访问一个类的静态变量属于主动使用该类，所以初始化了Child</span></span><br><span class="line">        <span class="comment">//初始化一个类的子类时相当于主动访问了其所有父类，所以Parent1被初始化（一个类初始化时，要求其所有父类都要初始化完成）</span></span><br><span class="line">        System.out.println(Child.str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但此时 Child 可能会被加载</strong>。在运行程序时添加 JVM 参数 <code>-XX:+TraceClassLoading</code> 可查看类加载信息。其中可看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Loaded classloader.Child from file:/E:.....]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>创建数组实例时</strong>不会造成数组元素类型的初始化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent3[] parent3s = <span class="keyword">new</span> Parent3[<span class="number">3</span>];</span><br><span class="line">        System.out.println(parent3s.getClass());</span><br><span class="line">        Parent3[][] parent3s1 = <span class="keyword">new</span> Parent3[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        System.out.println(parent3s1.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(parent3s.getClass().getSuperclass());</span><br><span class="line">        System.out.println(parent3s1.getClass().getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent3</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent3.static initializer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> [<span class="title">Lclassloader</span>.<span class="title">Parent3</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">Lclassloader</span>.<span class="title">Parent3</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，数组的类型并不是 Parent3 。</p>
<p>对于数组实例来说，<strong><font color="red">其类型是由 JVM 在运行期动态生成的</font>，表示为<code>[L + 数组元素全限定名 + ;</code>，二维数组则是<code>[[...</code>，且其父类就是<code>java.lang.Object</code>类。即并没有访问数组元素对应的类，因此不会造成其初始化</strong>。</p>
</li>
<li><p>调用 ClassLoader 的 <code>loadClass()</code> 方法。</p>
</li>
</ul>
<p>还有一种 <code>final static</code> 的情况，如下。</p>
<h3 id="关于final-static"><a href="#关于final-static" class="headerlink" title="关于final static"></a>关于final static</h3><p>对于一个 <strong>final 修饰的静态变量</strong>，<strong><font color="red">若该变量的值在编译时就可以确定</font>，那么该变量相当于“宏变量”。Java 编译器会在编译时直接把这个类变量出现的地方替换为它的值。该常量在编译阶段会存入到<font color="red">调用这个常量的方法所在的类的常量池中</font>，本质上，调用类并没有直接引用到定义常量的类，而是在调用常量池中的常量，因此并不会触发定义常量的类的初始化</strong>，且在把常量放入常量池之后，访问常量的类与定义该常量的类已经没有关系，此时将常量所在类的 class 文件删除仍然能运行。</p>
<p>示例：（MyTest2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(FinalStatic.a);<span class="comment">//不会导致类的初始化，static块不执行</span></span><br><span class="line">        System.out.println(FinalStatic.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//。。。。。。</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//ojbk</span></span><br><span class="line"><span class="comment">//FinalStatic&#x27;s static block</span></span><br><span class="line"><span class="comment">//obbk</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalStatic</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String a = <span class="string">&quot;ojbk&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String b = <span class="string">&quot;obbk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalStatic&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从字节码方面看</strong>：</p>
<p>访问非final的静态变量或变量的值编译时不能确定的final static变量，jvm执行的是getstatic指令（在字节码文件中使用getstatic助记符），而对于宏变量则不是。</p>
<p>使用javap命令反编译FinalStaticTest：<code>javap -c FinalStaticTest.class</code> ，在输出的字节码中可看到</p>
<p><code>System.out.println(FinalStatic.b);</code>对应的是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11: getstatic     #6                  // Field classloader/FinalStatic.b:Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<p>而<code>System.out.println(FinalStatic.a);</code>对应的是 <code> 3: ldc           #4                  // String ojbk</code></p>
<p>即String类型的宏变量对应助记符<code>ldc</code>。<strong>即并没用调用getstatic指令，因此不会触发类的初始化</strong>。</p>
<p>而若是 <strong><font color="red">final static 变量的值在编译时不能确定</font></strong>，访问该值依旧会使用 getstatic 指令，所以会造成类的初始化。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalStatic2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalStatic2&#x27;s static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(FinalStatic2.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap命令可看到：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field classloader/FinalStatic2.str:Ljava/lang/String;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-关于准备、初始化阶段的示例"><a href="#5-关于准备、初始化阶段的示例" class="headerlink" title="5. 关于准备、初始化阶段的示例"></a>5. 关于准备、初始化阶段的示例</h2><p>定义类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">        System.out.println(count1);</span><br><span class="line">        System.out.println(count2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;count1 = &quot;</span> + singleton.count1);</span><br><span class="line">        System.out.println(<span class="string">&quot;count2 = &quot;</span> + singleton.count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">count1 = <span class="number">2</span></span><br><span class="line">count2 = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>解析：在使用了Singleton的静态方法<code>getInstance()</code>时，引起了对Singleton的初始化，而初始化之前需要进行加载和连接，其中，<strong><font color="red">在连接阶段的准备阶段，为count1和count2分配了内存，并赋默认值（0）</font></strong>，在<strong>随后的初始化阶段</strong>，<strong>按顺序执行初始化语句，</strong>count被赋值为1，随后执行<code>new Singleton()</code>，将count1、2++，此时的值为2、1，<strong>最后执行<code>count2 = 0</code>，所以最后两个变量的值是2，0</strong>。</p>
<h2 id="6-关于接口的初始化"><a href="#6-关于接口的初始化" class="headerlink" title="6. 关于接口的初始化"></a>6. 关于接口的初始化</h2><p><strong>类的初始化规则不全部适用于接口</strong>，对于接口：</p>
<ul>
<li><strong>当一个接口在初始化时，不会触发其父接口的初始化</strong>，只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会执行父接口的初始化。<strong>即使调用实现类的实现方法也不会触发接口的初始化</strong>。</li>
<li><strong><font color="red">若是一个接口包含default方法，则当其实现类被初始化时，会先初始化接口</font></strong>。（若还没初始化）</li>
<li><strong>在初始化一个类时并不会初始化该类的实现接口（<font color="red">除非该接口包含default方法</font>）</strong>。</li>
<li><strong>接口中的成员变量默认被<code>public static final</code>修饰，所以对于接口变量同样适用上述宏变量的情况</strong>。</li>
</ul>
<p>示例：（若是接口被初始化，则接口中的new Thread()会执行，输出语句）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IParent</span></span>&#123;</span><br><span class="line">    String a = UUID.randomUUID().toString();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IParent.instance initializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IChild</span> <span class="keyword">extends</span> <span class="title">IParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">    String str = UUID.randomUUID().toString();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IChild.instance initializer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imp</span> <span class="keyword">implements</span> <span class="title">IParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Imp.static initializer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.访问宏变量，没有引起两个接口的初始化，output：</span></span><br><span class="line">        <span class="comment">//6</span></span><br><span class="line">        <span class="comment">// System.out.println(IChild.b);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.IChild被初始化，但其父接口并没有被初始化，output：</span></span><br><span class="line">        <span class="comment">//IChild.instance initializer</span></span><br><span class="line">		<span class="comment">//caac858a-e095-4152-abf4-b75f41a24873</span></span><br><span class="line">        <span class="comment">// System.out.println(IChild.str);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.类的初始化并不会触发其实现接口的初始化，output：</span></span><br><span class="line">        <span class="comment">//Imp.static initializer</span></span><br><span class="line">		<span class="comment">//6</span></span><br><span class="line">        System.out.println(Imp.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>参考</p>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV187411B7iv" target="_blank"> 深入理解JVM虚拟机视频</a> </p>
</li>
<li><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">Guide-类的加载过程</a> </p>
</li>
<li><p><a href="https://gu_chun_bo.gitee.io/java-construct/#/jvm%E5%AD%A6%E4%B9%A0/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank">jvm-类加载过程</a> </p>
</li>
<li><p>《疯狂Java讲义》</p>
</li>
<li><p>《深入理解JVM》</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">bxxiao</p>
  <div class="site-description" itemprop="description">nothing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bxxiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
